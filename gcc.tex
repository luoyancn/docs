\chapter{GCC}
\section{定义函数别名}
在gcc当中提供了一系列的扩展功能，包含了定义方法的别名。函数的别名可以是强引用，也可以是弱引用。
\begin{code-block}{c}
void __swap_object(void * first, void * last, size_t size)
{
    void * tmp = malloc(size);
    memcpy(tmp, first, size);
    memcpy(first, last, size);
    memcpy(last, tmp, size);
    free(tmp);
}

// 弱引用别名
void swap_weak(void * first, void *last, size_t size)
        __attribute__ ((weak, alias("__swap_object")));
// 强引用别名
void swap_strone(void * first, void *last, size_t size)
        __attribute__ ((alias("__swap_object")));
\end{code-block}

\section{标记函数被废弃}
在gcc也支持标记函数为废弃，来警示相关人员不要使用这样的函数。
\begin{code-block}{c}
void print_hello() __attribute__ ((deprecated));
void print_hello()
{
    printf("hello\n");
}
\end{code-block}

通过以上的方式进行标记时候，在调用printf\_hello这个方法的时候，编译过程中会提示
如下的信息：
\begin{code-block}{bash}
test.c:74:5: 警告：‘print_hello’ is deprecated [-Wdeprecated-declarations]
     print_hello();
     ^~~~~~~~~~~
test.c:46:6: 附注：在此声明
 void print_hello()
\end{code-block}

\section{特殊的gcc扩展}
有的时候，我们可能需要在执行main方法之前执行一些动作，在执行完main方法之后，再
进行一些扫尾的动作。Gcc提供了这样的支持。
\begin{code-block}{c}
// 进入main方法之前就执行该方法
void hello() __attribute__ ((constructor));
void hello()
{
    printf("hello\n");
}

// 退出main方法之后，执行该方法
void bye() __attribute__ ((destructor));
void bye()
{
    printf("bye\n");
}

int main(int argc, char * argv[])
{
    return 0;
}
\end{code-block}

以上代码编译执行之后，其输出为：
\begin{code-block}{bash}
helllo
bye
\end{code-block}

\section{Gcc内置函数}
GCC提供了一系列的内置函数，用于进行优化程序。
