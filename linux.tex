\chapter{Linux}

\section{启用RC的启动方式}
在redhat/centos 7及其以上版本，rc.local的启动方式已经被废除，这导致一些我们自定义的
服务无法正常使用。但是，redhat/centos 7以及fedora（> 22）提供了一种方式，可以启用rc.local
的启动方式。
\begin{code-block}{bash}
cat >>/etc/rc.d/rc.local<<EOF
#! /bin/bash
mysql -e  "GRANT ALL PRIVILEGES ON *.* TO 'root'@'%'IDENTIFIED BY 'luoyan' WITH GRANT OPTION" mysql
EOF
chmod+x /etc/rc.d/rc.local
cat >>/usr/lib/systemd/system/rc-local.service<<EOF
[Install]
WantedBy=multi-user.target
EOF
systemctl enable rc-local.service
\end{code-block}

\section{设置ssh的kownhosts}
\begin{code-block}{bash}
cd ~/.ssh
cat>config<<EOF
Host *
    StrictHostKeyChecking no
    UserKnownHostsFile=/dev/null
EOF
\end{code-block}

\section{安装windows字体}
在/usr/share/fonts目录下新建一个目录，目录名随意，以zh\_CN为例；将Windows系统文件夹中的Fonts文件夹下的以“sim”开头的文件和tahoma.ttf,verdana.ttf,verdanab.ttf,verdanaz.ttf,tahomabd.ttf,
verdanai.ttf,MSY*等文件复制到新建的目录中，并修改权限为755。
\begin{code-block}{bash}
cd /usr/share/fonts/zh_CN
mkfontscale
mkfontdir
fc-cache -fv
\end{code-block}

\section{Sphinx制作中文的pdf}
Sphinx支持pdf制作，但是需要texlive的支持。另外，sphinx默认不支持中文pdf的制作，需要进行相关修改。
\begin{code-block}{bash}
vi /usr/lib/python2.7/site-packages/sphinx/writers/latex.py +231
            if builder.config.language == 'zh_CN':
                self.elements['babel'] = ''
                self.elements['inputenc'] = ''
                self.elements['utf8extra'] = ''
vi /usr/lib/python2.7/site-packages/sphinx/texinputs/Makefile
%.pdf: %.tex
        xelatex $(LATEXOPTS) '$<'
        xelatex $(LATEXOPTS) '$<'
        xelatex $(LATEXOPTS) '$<'
        -makeindex -s python.ist '$(basename $<).idx'
        xelatex $(LATEXOPTS) '$<'
        xelatex $(LATEXOPTS) '$<'
\end{code-block}

然后，在使用sphinx生成的doc文档的conf.py文件中，做如下的修改：
\begin{code-block}{python}
language = 'zh_CN'
latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',
# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',
# Additional stuff for the LaTeX preamble.
'preamble': r'''
     \usepackage{xeCJK}
     \setCJKmainfont{SimSun}
     \XeTeXlinebreaklocale "zh"
     \XeTeXlinebreakskip = 0pt plus 1pt
     \setcounter{tocdepth}{4}  #设置生成的pdf的目录的最深层级
''',
}
\end{code-block}

如果需要修改sphinx的页眉样式，可以做如下的修改：
\begin{code-block}{bash}
vi /usr/lib/python2.7/site-packages/sphinx/texinputs/sphinx.sty +122
\fancyhead[LE,RO]{{\py@HeaderFamily \@title}}
\end{code-block}

如果还需要删除release信息，则可以如下修改：
\begin{code-block}{python}
vi /usr/lib/python2.7/site-packages/sphinx/writers/latex.py +192
'releasename':  _(' '),
\end{code-block}

\section{Latex制作中文的pdf}
同样的，latex默认也是不支持中文的，因此需要做部分的修改。
\begin{code-block}{bash}
vi /usr/share/texlive/texmf-dist/web2c/texmf.cnf
OSFONTDIR = /usr/share/fonts
vi /usr/share/texmf-dist/tex/latex/ctex/fontset/ctex-xecjk-winfonts.def
:%s/\[SIMKAI.TTF\]/KaiTi/g
:%s/\[SIMFANG.TTF\]/FangSong/g
\end{code-block}

\section{OpenStack社区的git设置}
由于各种原因，如果使用ssh的方式，社区的gerrit是无法正常连接的。但是，社区的gerrit
提供了https的连接方式，可以使用这种方式绕开相关的限制。首先，需要登录review.openstack.org，
然后在Settings -> HTTP Password里，生成一个HTTP密码，应该是一个大小写加数字的随机字符串。
最后，再在git当中做如下的设置即可。
\begin{code-block}{bash}
git config user.name zhangjl
git config user.email zhangjl@awcloud.com
git config gitreview.scheme https
git config gitreview.port 443
git remote add gerrit https://zhangjl:******@review.openstack.org/openstack/nova.git
git review -s

# 如果需要通过代理
# git config --global http.proxy http://localhost:8123
# git config --global http.sslVerify false
\end{code-block}

\section{禁用ipv6}
\begin{code-block}{bash}
cat >> /etc/sysctl.conf <<EOF
net.ipv6.conf.all.disable_ipv6 = 1
net.ipv6.conf.default.disable_ipv6 = 1
EOF
vi /etc/default/grub
GRUB_CMDLINE_LINUX="ipv6.disable=1 rd.lvm.lv=rhel/root vconsole.keymap=us vconsole.font=latarcyrheb-sun16 rhgb quiet"
grub2-mkconfig -o /boot/grub2/grub.cfg
reboot
\end{code-block}

\section{rabbitmq设置}
\begin{code-block}{bash}
yum install rabbitmq-server -y
systemctl enable rabbitmq-server
systemctl start rabbitmq-server
rabbitmq-plugins enable rabbitmq_management
mv /etc/rabbitmq/rabbitmq.config /etc/rabbitmq/rabbitmq.config_bak
cat >/etc/rabbitmq/rabbitmq.config<<EOF
[
{rabbit, [{loopback_users, []}]}
].
EOF
systemctl restart rabbitmq-server
\end{code-block}

\section{修改操作系统连接数}
\begin{code-block}{bash}
cat>>/etc/security/limits.conf<<EOF
*               soft    nproc           65535
*               hard    nproc           65535
*               soft    nofile          655350
*               hard    nofile          655350
*               soft    core            unlimited
*               hard    core            unlimited
EOF

cat>>/etc/security/limits.d/20-nproc.conf<<EOF
*          soft    nproc     65535
root       soft    nproc     unlimited
EOF
\end{code-block}

\section{google-chrome-stable}
\begin{code-block}{bash}
cat << EOF > /etc/yum.repos.d/google-chrome.repo
[google-chrome]
name=google-chrome - \$basearch
baseurl=http://dl.google.com/linux/chrome/rpm/stable/\$basearch
enabled=1
gpgcheck=1
gpgkey=https://dl-ssl.google.com/linux/linux_signing_key.pub
EOF
dnf install google-chrome-stable -y
\end{code-block}

\section{kdump调试分析}
通常的，当一个操作系统崩溃之后，可以使用kdump对crash的原因进行分析，以规避问题。
由于kdump是内核的转存文件，因此需要安装kernel的debug软件包。另外，kernel-debug一定
要和kernel的版本一致，否则是分析不出来的。
\begin{code-block}{bash}
# 开启kdump
vi /etc/default/grub
#GRUB_CMDLINE_LINUX="rd.lvm.lv=rhel/swap crashkernel=auto rd.lvm.lv=rhel/root rhgb quiet"
GRUB_CMDLINE_LINUX="rd.lvm.lv=rhel/swap crashkernel=2048M rd.lvm.lv=rhel/root rhgb quiet"

grub2-mkconfig -o /boot/grub2/grub.cfg
reboot
systemctl enable kdump;systemctl start kdump

yum install kernel-debuginfo crash gdb -y
cd /var/crash/xxx
crash /usr/lib/debug/lib/modules/3.10.0-327.18.2.el7.x86_64/vmlinux vmcore
\end{code-block}

通过以上的命令，即可分析core dump的问题根源。

\section{Libvirt tls迁移}
\begin{code-block}{bash}
mkdir -p /etc/pki/libvirt/private;
mkdir -p /opt/libvirttls;
cd /opt/libvirttls
certtool --generate-privkey > cakey.pem
cat >ca.info<<EOF
cn = Awcloud
expiration_date = "2100-01-01 00:00:00"
ca
cert_signing_key
EOF
certtool --generate-self-signed --load-privkey cakey.pem --template ca.info --outfile cacert.pem
\end{code-block}

将生成的cakey.pem和cacert.pem复制到所有node节点的/etc/pki/CA下

制作服务器证书
\begin{code-block}{bash}
cd /opt/libvirttls
certtool --generate-privkey > serverkey.pem
export host=`hostname`
cat> server.info<<EOF
organization = Awcloud
cn = $host
expiration_date = "2100-01-01 00:00:00"
tls_www_server
encryption_key
signing_key
EOF
certtool --generate-certificate --load-privkey serverkey.pem \
    --load-ca-certificate /etc/pki/CA/cacert.pem \
    --load-ca-privkey /etc/pki/CA/cakey.pem \
    --template server.info --outfile servercert.pem
mv servercert.pem /etc/pki/libvirt;
mv serverkey.pem /etc/pki/libvirt/private;
\end{code-block}

制作客户端证书
\begin{code-block}{bash}
cd /opt/libvirttls
certtool --generate-privkey > clientkey.pem
export host=`hostname`
cat> client.info<<EOF
country = CN
state = HB
locality = Beijing
organization = Awcloud
cn = $host
expiration_date = "2100-01-01 00:00:00"
tls_www_client
encryption_key
signing_key
EOF
certtool --generate-certificate --load-privkey clientkey.pem \
    --load-ca-certificate /etc/pki/CA/cacert.pem \
    --load-ca-privkey /etc/pki/CA/cakey.pem \
    --template client.info --outfile clientcert.pem
mv clientcert.pem /etc/pki/libvirt;
mv clientkey.pem /etc/pki/libvirt/private;
\end{code-block}

修改libvirt配置文件
\begin{code-block}{bash}
vi /etc/sysconfig/libvirtd
LIBVIRTD_ARGS="--listen"

vi /etc/libvirt/libvirtd.conf
listen_tls = 1
tls_port = "16514"
key_file = "/etc/pki/libvirt/private/serverkey.pem"
cert_file = "/etc/pki/libvirt/servercert.pem"
ca_file = "/etc/pki/CA/cacert.pem"
tls_no_verify_certificate = 1
\end{code-block}

重启libvirt
\begin{code-block}{bash}
/etc/init.d/libvirtd restart
\end{code-block}

如果出现16514，则说明libvirt配置成功。执行操作
\begin{code-block}{bash}
virsh -c qemu+tls://<hostname>/system
\end{code-block}

如果能够连接成功，说明libvirt的tls连接配置正确。

\section{kvm嵌套虚拟化}
\begin{code-block}{bash}
# 升级kernel到4.10以上版本
vi /etc/default/grub
GRUB_CMDLINE_LINUX="rd.lvm.lv=rhel/swap crashkernel=2048M rd.lvm.lv=rhel/root rhgb quiet kvm-intel.nested=1"

grub2-mkconfig -o /boot/grub2/grub.cfg

# 或者直接修改grub文件
vi /boot/grub2/grub.cfg
linux16 /vmlinuz-4.12.3-1.el7.elrepo.x86_64 root=/dev/mapper/system-lv_root ro rd.lvm.lv=system/lv_root \
    rhgb quiet LANG=en_US.UTF-8 kvm-intel.nested=1

# 或者修改启动参数
cat << EOF > /etc/modprobe.d/kvm_intel.conf
options kvm-intel nested=1
options kvm-intel enable_shadow_vmcs=1
options kvm-intel enable_apicv=1
options kvm-intel ept=1
EOF

# 另外，为了与嵌套的VM通信，需要禁用反向路径过滤，否则RHEL将丢弃任何网络数据包，以防止不对称路由
cat << EOF > /etc/sysctl.d/98-rp-filter.conf
net.ipv4.conf.default.rp_filter = 0
net.ipv4.conf.all.rp_filter = 0
EOF

# 然后重启服务器
reboot

# 检查嵌套虚拟化是否生效
systool -m kvm_intel -v   | grep -i nested
cat /sys/module/kvm_intel/parameters/nested
# 如果都显示Y，则说明成功

# 创建支持嵌套虚拟化的虚拟机
#可以使用这种
  <cpu mode='custom' match='exact'>
    <model fallback='allow'>core2duo</model>
    <feature policy='require' name='vmx'/>
  </cpu>
#这种方式为虚拟机定义需要模拟的CPU类型"core2duo",并且为虚拟机添加"vmx"特性

#也可以使用这种
  <cpu mode='host-model'>
    <model fallback='allow'/>
  </cpu>
#或者这样
 <cpu mode='host-passthrough'>
    <topology sockets='2' cores='2' threads='2'/>
 </cpu>
\end{code-block}

\section{常用命令}
\begin{outline}[enumerate]
\1 递归比较文件夹
\begin{code-in-enumerate}{bash}
diff -ruNa nova-2.2/ nova-2.3 > update
\end{code-in-enumerate}

\1 查看rpm的changelog
\begin{code-in-enumerate}{bash}
rpm -q openstack-nova-compute --changelog
\end{code-in-enumerate}

\1 挂载iso
\begin{code-in-enumerate}{bash}
mount -o loop cloudbase-init.iso /mnt/
\end{code-in-enumerate}

\1 解压ramdisk文件
\begin{code-in-enumerate}{bash}
mkdir tmp
mv ramdisk tmp
cd tmp
zcat /boot/initrd-2.6.18-164.6.1.el5.img | cpio -idmv
\end{code-in-enumerate}

\1 xargs的for循环
\begin{code-in-enumerate}{bash}
neutron agent-list | grep xxx | awk '{print $2}' | xargs -I {} neutron agent-show {}
nova list | grep cirros | awk '{print $2}'| xargs -I {} nova reset-state {} --active
\end{code-in-enumerate}

\1 解压rpm文件
\begin{code-in-enumerate}{bash}
rpm2cpio mysql-community-common-5.6.28-2.el7.x86_64.rpm | cpio -idmv
\end{code-in-enumerate}

\1 解压xz文件
\begin{code-in-enumerate}{bash}
xz -k -d xxx.xz
\end{code-in-enumerate}

\1 通过qemu-guest-agent执行命令
\begin{code-in-enumerate}{bash}
# 获取agent支持的命令列表
virsh qemu-agent-command 25 '{"execute":"guest-info"}' --pretty
# 获取monitor支持的命令列表
virsh qemu-monitor-command 25 '{"execute":"query-commands"}' --pretty
\end{code-in-enumerate}

\end{outline}

\section{Linux Kernel}
\subsection{Kernel编译}
\subsubsection{安装必要的软件包}
\begin{code-block}{bash}
yum install ncurses-devel bison flex elfutils-libelf-devel bc openssl-devel -y
\end{code-block}

\subsubsection{设置编译选项}
\begin{code-block}{bash}
make menuconfig
\end{code-block}

\subsubsection{编译内核}
\begin{code-block}{bash}
make
# 如果是在多核服务器上进行编译，可以增加编译参数，提高编译速度
# make -j32 #32表示cpu的核数
\end{code-block}

\subsubsection{安装内核模块}
\begin{code-block}{bash}
make modules_install
\end{code-block}

安装内核模块的操作，会将编译生成的内核模块复制到/lib/modules/\{kernel-version\}/下。

\subsubsection{安装内核}
\begin{code-block}{bash}
make install
\end{code-block}

安装内核的过程主要完成了以下的工作：将编译内核时生成的内核镜像bzImage拷贝到/boot目录下，
并将这个镜像命名为vmlinuz-\{kernel-version\}。如果使用x86的cpu，则该镜像位于arch/x86/boot/目录下；
将目录下的System.map拷贝到/boot/目录下，重新命名为System.map-\{kernel-version\}，该文件中存放了内核的符号表。
将目录下的.config拷贝到/boot/目录下，重新命名为config-\{kernel-version\}

\subsubsection{创建initrd.img文件}
\begin{code-block}{bash}
mkinitrd  /boot/initrd.img-{kernel-version} {kernel-version}
\end{code-block}

initrd.img即为初始化的ramdisk文件，它是一个镜像文件。

\subsubsection{修改grub}
\begin{code-block}{bash}
grub2-mkconfig -o /boot/grub2/grub.cfg
\end{code-block}

修改完成之后，重启服务器，即可发现新编译的内核，如下图：
图 \nameref{fig:new-kernel}
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.6]{new-kernel.png}
  \caption{新编译内核 \protect\footnotemark}
  \label{fig:new-kernel}
\end{figure}

\subsection{编写自己的内核模块}
在编写自己的内核模块的时候，一般需要2个文件：一个c代码文件，包含了自己的内核模块
内在逻辑实现；一个makefile文件，用于编译自己的内核模块。以最简单的hello world为例。
C代码如下：
\begin{code-block}{c}
// hello_kernel.c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>

// 必须，标明模块的许可声明
MODULE_LICENSE("GPL");

// 模块的加载函数，即加载该模块之后，执行的操作
static int hello_init(void)
{
    printk(KERN_ALERT "hello,I am zhangjl\n");
    return 0;
}

// 模块的卸载函数，即该模块卸载之后，应当执行什么操作
static void hello_exit(void)
{
    printk(KERN_ALERT "goodbye,kernel\n");
}

// 注册模块对应的操作
module_init(hello_init);
module_exit(hello_exit);

// 可选，表示该模块的作者和其他信息
MODULE_AUTHOR("zhangjl");
MODULE_DESCRIPTION("This is a simple example!\n");
MODULE_ALIAS("A simplest example");
\end{code-block}

Makefile文件内容如下：
\begin{code-block}{make}
obj-m += hello_kernel.o
#generate the path
CURRENT_PATH:=$(shell pwd)
#the current kernel version number
LINUX_KERNEL:=$(shell uname -r)
#the absolute path
LINUX_KERNEL_PATH:=/usr/src/kernels/$(LINUX_KERNEL)
#complie object
all:
        make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules
#clean
clean:
        make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean
\end{code-block}

然后执行make。执行完毕之后，会在当前目录生成hello\_kernel.ko，这个文件即是我们
所需要的内核模块。执行insmod hello\_kernel.ko，在/var/log/message当中，会发现有hello的输出，执行
rmmod hello\_kernel，在/var/log/message当中，会发现有goodbyd的输出。整个简单的模块
就算完成了。

\subsection{Linux的进程遍历}
一个进程是由进程控制块（PCB），代码段和数据段组成的；并且，OS通常是通过PCB来感知
一个进程的存在。其实PCB就是操作系统对每个进程的代码描述。linux内核中使用task\_struct
结构来描述一个PCB（具体可以在linux/kernel/sched.c查看源码）；多个进程则常常使用双链表
等来进行组织。比如可运行状态的进程组成可运行队列，等待状态的进程组成等待队列等。

list\_head为linux内核当中常用的数据结构，用于构造双链表，关于list\_head的具体用法，可以
参见c部分的宏定义高级使用部分。而task\_struct的定义类似于如下的代码：
\begin{code-block}{c}
struct task_struct {
        struct thread_info    thread_info;
        struct list_head      tasks;
};
\end{code-block}

由于该结构体当中存在list\_head的变量，因此，我们可以利用该变量来访问整个task\_strut,
进而获取我们需要的信息。完整代码如下：
\begin{code-block}{c}
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/sched.h>
#include <linux/sem.h>
#include <linux/list.h>

MODULE_LICENSE("GPL");
static int hello_init(void)
{
        printk(KERN_ALERT "hello,I am zhangjl\n");
        return 0;
}

static int traverse_init(void)
{
       struct task_struct *pos;
       struct list_head *current_head;
       int count=0;
       printk("Traversal module is working..\n");
       current_head=&(current->tasks);
       list_for_each_entry(pos,current_head,tasks)
       {
              count++;
              printk("[process %d]: %s\'s pid is %d\n",count,pos->comm,pos->pid);
       }
       printk(KERN_ALERT"The number of process is:%d\n",count);
       return 0;
}

static void hello_exit(void)
{
    printk(KERN_ALERT "goodbye,kernel\n");
    traverse_init();
}

module_init(hello_init);
module_exit(hello_exit);
MODULE_AUTHOR("zhangjl");
MODULE_DESCRIPTION("This is a simple example!\n");
MODULE_ALIAS("A simplest example");

\end{code-block}

其中，current是一个宏，即为系统内正在运行的进程。编译该文件，然后加载该模块，在
系统日志当中，即可发现对应的输出。
