\section{多线程}
Rust也同样支持常见的并行和并发操作，也同样分为进程，线程以及消息通信等等。

\subsection{线程}
Rust的线程操作必须使用闭包完成。在之前看到的闭包当中，通常采用的都是有参的闭包，
而在Rust的线程操作当中，则经常会遇到无参数的闭包；Rust的线程使用thread::spawn函数
进行实现：
\begin{code-block}{rust}
use std::thread;
use std::time::Duration;
fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });
    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
\end{code-block}
和其他语言的线程概念一样，当主线程结束时，所有的线程都会被终止。因此上述代码当中，
子线程（spawn）无法将所有的循环执行完成。为了达成所有进/线程执行完成之后才退出主
进/线程的目的，和其他的开发语言相同，需要在主进程当中调用join函数：
\begin{code-block}{rust}
fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });
    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
    handle.join().unwrap();
}
\end{code-block}
Thread::spawn的返回值是JoinHandle，是一个拥有所有权的值，当对其调用join方法时，
它会等待对应线程结束；而join的返回值是一个Result，可以按照之前介绍的方式进行处理。
同时，Join函数是一个阻塞式函数，只有当该函数运行结束之后，才会继续进行后续的操作。

多数情况下，Rust的线程不可能只会在内部运行，而和外部没有数据交互。但是，如果我们
直接使用外部数据，则会出现错误，比如下方的代码：
\begin{code-block}{rust}
fn main() {
    let v = vec![1, 2, 3];
    let handle = thread::spawn(|| {
        println!("Here's a vector: {:?}", v);
    });
    handle.join().unwrap();
}
\end{code-block}
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_thread_out_params.png}
  \caption{试图访问线程外部资源}
  \label{fig:rust_thread_out_params}
\end{figure}
线程使用的是闭包，从闭包的定义来说，是可以捕获并使用外部变量和数据的；但是，Rust
不知道这个线程到底会运行多长时间，因此无法知道对外部变量的引用是否一直有效，比如
下方的代码：
\begin{code-block}{rust}
fn main() {
    let v = vec![1, 2, 3];
    let handle = thread::spawn(|| {
        println!("Here's a vector: {:?}", v);
    });
    drop(v);
    handle.join().unwrap();
}
\end{code-block}
启动线程的同时，立即将v进行丢弃，线程内部无法知道v在运行阶段是否继续有效，就会
出现错误，因此，如果在线程当中使用默认的闭包模式，则无法对应的闭包是无法捕获以及
使用外部的变量和数据的。此时，则需要使用move闭包进行替换，即强制闭包获取外部变量
的所有权，而不是由Rust进行借用推断。但是需要注意，一旦使用move之后，在线程之外，
变量将无法再进行使用：
\begin{code-block}{rust}
fn main() {
    let v = vec![1, 2, 3];
    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });
    // 下方代码无法再进行执行
    // println!("{:?}", v);
    handle.join().unwrap();
}
\end{code-block}

\subsection{消息通信和消息传递}
每个线程做自己的事情，但是，不管什么编程语言，都需要考虑线程之间的数据交互问题。
Rust向Golang进行了学习，使用通信替换共享内存，来进行线程之间的数据传输。同样的，
Rust当中用于消息传递并发的主要工具是通道，该概念和Golang的通道概念相同。Rust的通道
分为2个角色：发送者和接收者，发送者发送消息，接收者接收消息，当发送者或者接收者任一
被丢弃时，则对应的通道被视为关闭。

Rust的通道采用mpsc::channel函数实现，mpsc表示多个生产者，单个消费者，因此，Rust
标准库实现通道的方式意味着一个通道可以有多个产生值的发送（sending）端，但只能有
一个消费这些值的接收（receiving）端。通道的实现示例如下：
\begin{code-block}{rust}
use std::sync::mpsc;

fn main() {
    let (sender, recevier) = mpsc::channel();
}
\end{code-block}
其中，函数的第一个返回值为发送者，第二个参数为接收者。使用通道发送数据通信的示例
如下：
\begin{code-block}{rust}
use std::sync::mpsc;
use std::thread;

fn main() {
    let (sender, recevier) = mpsc::channel();

    thread::spawn(move || {
        let val = "lucifer".to_string();

        match sender.send(val) {
            Ok(_) => println!("Send success"),
            Err(error) => println!("Send failed :{:?}", error),
        }
    });

    let res = match recevier.recv() {
        Ok(s) => s,
        Err(error) => {
            println!("Cannot recevie anything from sender: {:?}", error);
            "".to_string()
        }
    };

    println!("The result of channel is {}", res);
}
\end{code-block}
接收者接收消息有2种模式：默认的recv是阻塞式，返回一个Result<T, E>，当通道关闭时，
将返回Result当中的Error；而try\_recv是非阻塞式，同样是返回一个Result<T, E>，但是，
Result当中的Error表示没有接收到任何消息，可以使用for循环进行反复的尝试读取操作。
另外需要注意的是，Send函数会改变变量的所有权，当该函数执行之后，被发送的消息
（变量）将无法再使用。

但是，通道可以反复使用，而且和Golang的类似，Rust的通道也是可以进行迭代的，特别
是在接收消息时，通常采用for循环进行操作，减少了错误处理的代码，使得代码更具可读性：
\begin{code-block}{rust}
use std::sync::mpsc;
use std::thread;

fn main() {
    let (sender, recevier) = mpsc::channel();

    let handler = thread::spawn(move || {
        let vals = vec!["lucifer", "titans", "garuda"];
        for val in vals {
            match sender.send(val) {
                Ok(_) => println!("Send success"),
                Err(error) => println!("Send failed :{:?}", error),
            }
        }
    });

    for msg in recevier {
        println!("The msg is {}", msg);
    }

    match handler.join() {
        Err(error) => println!("Error{:?}", error),
        _ => (),
    }
}
\end{code-block}

同样的，由于Rust的通道默认是多生产者/单消费者，因此，可以通过多个发送端向单个接
收端发送消息。实际使用当中的多个发送端，则通常是某个发送端的克隆对象，如下：
\begin{code-block}{rust}
use std::sync::mpsc;
use std::thread;

fn main() {
    let (sender, recevier) = mpsc::channel();
    let sender_copy = sender.clone();

    let handler = thread::spawn(move || {
        let vals = vec!["lucifer", "titans", "garuda"];

        for val in vals {
            match sender.send(val) {
                Ok(_) => println!("Send success"),
                Err(error) => println!("Send failed :{:?}", error),
            }
        }
    });
    let handler_copy = thread::spawn(move || {
        let vals = vec!["zhangjl", "luoyan", "zhangzz"];

        for val in vals {
            match sender_copy.send(val) {
                Err(error) => println!("Send failed :{:?}", error),
                _ => (),
            }
        }
    });
    for msg in recevier {
        println!("The msg is {}", msg);
    }
    match handler_copy.join() {
        Err(error) => println!("Error{:?}", error),
        _ => (),
    }
    match handler.join() {
        Err(error) => println!("Error{:?}", error),
        _ => (),
    }
}
\end{code-block}

\subsection{共享状态}
在其他语言当中，有些特殊的场景，还是必须使用原有的线程并发概念——锁——来进行资源的
访问/读写控制。Rust当中同样存在锁，比较常见的就是互斥锁（互斥器，Mutex）以及原子
计数器（Arc）。在基本的操作上，互斥锁的使用和其他语言当中没有太大的区别：
\begin{code-block}{rust}
use std::sync::Mutex;
fn main() {
    let m = Mutex::new(5);
    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }
    println!("m = {:?}", m);
}
\end{code-block}
注意，上述代码如果将内部大括号去除，则运行结束之后，m的状态还是锁定状态；但是，
有大括号，则表示大括号内部的段是一个有效的生命周期，当该生命周期结束之后，互斥
锁将自动释放。一旦获取了锁，就可以将返回值（在这里是num）视为一个其内部数据的
\colorblock{可变引用}。类型系统确保了我们在使用m中的值之前
获取锁：Mutex<i32>并不是一个i32，所以必须获取锁才能使用这个i32值。

实质上，Mutex是一个智能指针，lock调用返回一个叫做MutexGuard的智能指针。这个智能
指针实现了Deref来指向其内部数据；同时也提供了一个Drop实现，使得MutexGuard离开作
用域时自动释放锁，即锁的释放是自动发生的。

但是默认情况下，Mutex是无法用于进行线程间的数据共享，如下：
\begin{code-block}{rust}
use std::rc::Rc;
use std::sync::Mutex;
use std::thread;
fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];
    for _ in 0..10 {
        let counter = Rc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
    }
    println!("Result: {}", *counter.lock().unwrap());
}
\end{code-block}
上述代码会出现下面的类似错误：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_mutex_share_error.png}
  \caption{试图通过Rc共享Mutex的数据}
  \label{fig:rust_mutex_share_error}
\end{figure}
即之前提到的，Rc类型只能用于单线程/单进程环境。

而共享引用计数则需要使用Arc，它是可以安全的用于并发环境的类型，即原子引用计数，
可以在线程间进行共享所有权。Arc和Rc有相同的API，基本使用方法上类似。所有，可以直
接对上述代码进行修改：
\begin{code-block}{rust}
use std::sync::{Arc, Mutex};
use std::thread;
fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
    }
    println!("Result: {}", *counter.lock().unwrap());
}
\end{code-block}
通过这样简单的修改，成功实现了10个进程当中对同一个数值进行加法操作的功能。

虽然Rust本身的线程/进程管理非常完善，但是，thread::spawn产生的线程没有名称，并且
其栈空间大小默认为2M，如果需要需要针对线程/进程进行粒度更细的操作，比如自定义
线程名称，自定义线程的资源等等，此时，就需要使用thread::Builder进行修改，具体示例
如下：
\begin{code-block}{rust}
let mut v_thread = vec![];
for id in 1..5 {
    let thread_name = format!("child-{}", id);
    let size: usize = 1024;
    // 定义线程的名称，设置线程占用的栈大小为1M(1024)
    let builder = Builder::new().name(thread_name).stack_size(size);
    // builder.spawn返回的是Result<JoinHander, std::io::Error>
    // 需要进行处理，取出真正的线程句柄
    match builder.spawn(move || {
        info!(
            "In the child: {}, and the child name is {}",
            id,
            current().name().unwrap()
        );
    }) {
        Ok(child) => v_thread.push(child),
        Err(error) => error!("Cannot create the thread {} because: {:?}", id, error),
    };
}
// 其他的同普通的线程，
for child in v_thread {
    child.join().unwrap();
}
\end{code-block}

由于线程包含自己的资源空间，因此，存在一个特殊的存储空间——线程本地存储（Thread Local Storage，TLS），
存放在该区域的资源，其他线程无法访问，而是每个线程独占的数据：
\begin{code-block}{rust}
use std::cell::RefCell;
use std::thread;
fn main() {
    // 在线程本地存储定义一个FOO变量，最终的类型是thread::LocalKey
    thread_local!(static FOO: RefCell<u32> = RefCell::new(1));
    // 提供了一个with方法，可以通过给该方法传入闭包
    // 来操作线程本地存储中包含的变量
    FOO.with(|f| {
        info!("The f borrow is {}", *f.borrow());
        *f.borrow_mut() = 2;
    });
    let handler = thread::spawn(move || {
        // 子线程也有一个线程本地存储实例FOO，为主线程的副本
        // 也可以使用thread_local!宏在该子线程中重新创建一个LocalKey实例
        FOO.with(|f| {
            info!("In the handler thread The f borrow is {}", *f.borrow());
            *f.borrow_mut() = 3;
        });
    });
    // 主线程当中FOO实例并没有被子线程修改为3
    // thread local!宏定义单个线程内的一些独享数据
    FOO.with(|f| {
        info!("The f borrow is {}", *f.borrow());
    });
    handler.join().unwrap();
}
\end{code-block}

在同步原语支持方面，Rust也有自己的实现方式，通过使用std::thread当中的park函数提供
阻塞线程的能力，但并不能永久的阻塞线程，存在时间限制；而std::thread::part\_timeout
则可以显式的指定阻塞的超时时间；std::thread::Thread::unpark则可以将阻塞的线程重启；
如果需要让出当前线程的时间片，则需要使用std::thread::yeild\_now，让其他线程进行执行。
简单的阻塞例子如下：
\begin{code-block}{rust}
use std::thread::{self, Builder};
use std::time::Duration;
fn main() {
    let parked_thread = Builder::new()
        .spawn(|| {
            info!("Parking the thread ...");
            // 阻塞当前线程
            thread::park();
            info!("Thread parked");
        })
        .unwrap();
    thread::sleep(Duration::from_secs(5));
    info!("Unparking the thread");
    // 从JoinHandle中得到具体的线程
    parked_thread.thread().unpark();
    // 将该线程重新启动，该线程会继续沿着之前暂停的上下文执行
    parked_thread.join().unwrap();
}
\end{code-block}

除了常见的互斥锁（Mutex）之外，Rust也支持读写锁（RwLock）。读写锁的基本示例如下：
\begin{code-block}{rust}
use std::sync::RwLock;
fn main() {
    let rw_lock = RwLock::new(5);
    // 读写锁的使用必须使用{}进行区分，即便是单独使用读或者写也是一样
    // 通过代码块{}，让读写锁自动释放，否则会出现死锁
    {
        let read_1 = rw_lock.read().unwrap();
        let read_2 = rw_lock.read().unwrap();
        info!("The read_1 is {}, and read_2 is {}", read_1, read_2);
    }
    {
        let mut write = rw_lock.write().unwrap();
        *write = 100;
    }
    info!("The data is {:?}", rw_lock);
}
\end{code-block}

而针对于同步的需求，Rust提供了屏障（Barrier）和条件变量（Condition Variable）原语。
屏障，是要求所有的条件全部满足之后，再进行后续操作，即在满足某个条件前，阻塞全部的
线程，通常用于线程同步，如下：
\begin{code-block}{rust}
use std::sync::{Arc, Barrier};
use std::thread;
fn main() {
    let mut vec = vec![];
    let barrier = Arc::new(Barrier::new(5));
    for id in 0..5 {
        let barrier_copy = barrier.clone();
        vec.push(thread::spawn(move || {
            info!("Thread {} Waiting the other threads...", id);
            // wait阻塞了所有的线程，当所有线程的wait之前部分全部执行完成之后
            // wait操作才算执行完成，才会执行每个线程后续的操作
            barrier_copy.wait();
            info!("{} After wait...", id);
        }));
    }
    for handler in vec {
        handler.join().unwrap();
    }
}
\end{code-block}

而条件变量与屏障稍微的区别在于，它不是阻塞所有的线程，而是在满足特定条件前，阻塞
一个得到了互斥锁的线程，如下：
\begin{code-block}{rust}
use std::sync::{Arc, Condvar, Mutex};
use std::thread;
use std::time::Duration;
fn main() {
    // 生成包含互斥锁的条件变量condvar
    let pair = Arc::new(((Mutex::new(false)), Condvar::new()));
    let pair_clone = pair.clone();
    let handler = thread::spawn(move || {
        let &(ref lock, ref cvar) = &*pair_clone;
        // 获得互斥锁
        let mut started = lock.lock().unwrap();
        info!("In the child thread");
        thread::sleep(Duration::from_secs(5));
        *started = true;
        // 通知主线程
        cvar.notify_one();
    });
    let &(ref lock, ref cvar) = &*pair;
    let mut started = lock.lock().unwrap();
    while !*started {
        info!("Waiting for the started singal {} ...", started);
        // 使用条件变量的wait阻塞当前线程，一直到cvar退出
        started = cvar.wait(started).unwrap();
        info!("Started singal finished {} ...", started);
    }
    handler.join().unwrap();
}
\end{code-block}
相比于单纯的互斥锁必须多次出入临界区才能获取到某个状态的信息，条件变量减少了系统
资源的浪费，但是需要注意，每个条件变量每次只能和一个互斥锁（体）一起使用。

除了使用锁、屏障以及条件变量，关于同步的问题，还可以使用原子操作。Rust目前只提供了
4个原子操作类型：AtomicBool、Atomiclsize、AtomicPtr和AtomicUsize。需要注意，虽然原子
操作类型本身可以保证操作的原子性，但是其本身并没有提供跨线程的共享方法，如果需要
使得原子数据类型也可以在线程间共享，则应当使用Arc进行封装，比如下面，使用原子类型
实现一个自旋锁：
\begin{code-block}{rust}
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
fn main() {
    let spinlock = Arc::new(AtomicUsize::new(1));
    let spinlock_clone = spinlock.clone();
    let handler = thread::spawn(move || {
        // 将原子类型的数据设置为0
        spinlock_clone.store(0, Ordering::SeqCst);
    });
    // 使用spinlock的load方法读取其内部原子类型的值，如果不为0，
    // 则不停地循环测试锁的状态，直到其状态被置为0为止
    // 所谓“自旋”就是指在语义上表示这种不断循环获取锁状态的行为
    while spinlock.load(Ordering::SeqCst) != 0 {}
    handler.join().unwrap();
}
\end{code-block}
代码当中的Ordering表示内存参数顺序，可以通过该参数来控制底层线程执行顺序。默认的，
Rust支持5种内存顺序，归为3大类：
\begin{itemize}
  \item 排序一致性顺序——SeqCst：最简单直观，要求必须先存储，后读取，在多线程环境下，所有的原子写操作都必须在读操作之前完成，强行指定了线程的执行顺序，保证了多线程中所有操作的全局一致性，但是存在性能损耗，其实质类似于餐厅点餐，相当于强制要求所有需要结账的客人，必须等所有点单的客户完成之后才可以结账
  \item 自由顺序——Relaxed：和SeqCst相反，完全不会对线程的顺序进行干涉，线程只进行原子操作，但是，线程之间会存在竞态条件，使用这种内存顺序会比较危险，只有在明确了解当前使用场景且必须使用它的情况下（比如只有读操作），才可使用自由顺序
  \item 获取-释放顺序——Release，Acquire和AcqRel： 是除排序一致性顺序之外的优先选择，默认情况下，不会对全部线程进行统一强制性的执行顺序要求，store表示释放（release），而load表示获取（acquire），通过这2种操作的协作实现线程同步。Release表示使用该顺序的store操作，之前所有的操作对于使用Acquire顺序的load操作都可见；反之，使用使用Aquire顺序的load操作，对于使用Release的store操作都是可见的；AcqRel表示读时使用Acquire顺序的load操作，写时使用Release顺序的store操作。获取释放顺序虽然不像排序一致性顺序那样对全局线程统一排序，但是它让每个线程都能接固定的顺序执行。
\end{itemize}

在此之前，已经谈到Rust支持channel通信来解决多线程环境所遇到的问题，比如之前的小例子：
\begin{code-block}{rust}
use std::thread;
use std::sync::mpsc::channel;
fn main() {
    let (tx, rx) = channel();
    let handler = thread::spawn(move || {
        tx.send(10).unwrap();
    });
    let res = rx.recv().unwrap();
    handler.join().unwrap();
}
\end{code-block}
像这种只有2个线程间通信的channel，称之为流通道，在流通道的内部，默认使用的是单生产者
单消费者的模式来提升性能。在此之前，我们看到多个发送者（生产者）单个接收者（消费者）
模式的通道，则称之为共享通道。而由于统一使用的channel函数生成通道，这样的通道又
称之为异步通道，即所有的操作都可以异步的进行处理，不会出现线程阻塞的情况。

同步通道的例子则如下：
\begin{code-block}{rust}
use std::thread;
use std::sync::mpsc::sync_channel;
fn main() {
    // 创建缓冲区为1的同步通道
    let (tx, rx) = sync_channel(1);
    tx.send(1).unwrap();
    let handler = thread::spawn(move || {
        tx.send(2).unwrap();
    });
    let res1 = rx.recv().unwrap();
    info!("The result is {}", res1);
    let res2 = rx.recv().unwrap();
    info!("The result2 is {}", res2);
    handler.join().unwrap();
}
\end{code-block}
在上述代码当中，由于channel的缓冲区设置为1，所以，当第一条信息被消费（recv）之前，
后续的消息发送会被一直阻塞，直到缓冲区可用为止。

虽然channel解决了很多的多线程同步和共享问题，但是，channel并没有解决死锁的问题，
当设计不周到的时候，channel同样会出现死锁的问题：
\begin{code-block}{rust}
use std::thread;
use std::sync::mpsc::channel;
fn main() {
    let (tx, rx) = channel();
    let mut handlers = vec![];
    for i in 0..5 {
        let tc = tx.clone();
        let handler = thread::spawn(move || {
            tc.send(i).unwrap();
        });
        handlers.push(handler);
    }
    // 如果注释下面代码，主线程将一直不退出
    // drop(tx);
    for j in rx.iter() {
        info!("{:?}", j);
    }
    for handler in handlers {
        handler.join().unwrap();
    }
}
\end{code-block}
因为rx的iter方法会阻塞线程，只要tx还没有被析构，该迭代器就会一直等待新的消息，
只有tx被析构之后，迭代器才能返回None，从而结束退出main主线程。由于上述代码的tx
一直没有析构，所以迭代器依旧会进行等待，但是tx也没有发送信息，从而造成死锁的状态。
显式调用drop之后，死锁将不会存在。

\section{异步实现-Futures}
Rust目前的版本当中，异步/同步的支持比较完善，目前，Futures\footnote{\url{https://github.com/rust-lang/futures-rs}}
提供了完整实现，Tokio\footnote{\url{https://github.com/tokio-rs/tokio}}也提供了
比较完整的平台支持，Async-Std\footnote{\url{https://github.com/async-rs/async-std}}也提供了
相关的支持。多线程的劣势主要体现在操作系统调度开销，难度较大，线程切换以及
跨线程共享数据会产生很多的额外开销，这些就是异步并发（async/await）发挥作用的
重要场景。

\subsection{Future的基本原理与实现机制}
所谓的Futrue，从字面上讲，就是一些将来完成的操作，也就是一些并不是当前立即结束
的操作，以此指代Rust的异步操作。Rust的异步操作实现基于轮询机制，每个异步任务分成
了3个阶段：
\begin{enumerate}
  \item 轮询阶段（Poll）：一个Future被轮询之后，会开始执行，直到被阻塞。轮询Future通常被称为执行器（executor）
  \item 等待阶段：事件源（即需要使用Future的对象，通常称为reactor）注册等待事件发生，并确保当对应的事件发生或准备好时唤醒对应的Future
  \item 唤醒阶段：事件发生，相应的Future被唤醒，执行器执行，直至完成
\end{enumerate}

例如对大文件进行操作，如果采用普通的文件打开方式，操作大文件，需要将文件内容打开
（全部在内存展开）之后，才能操作；而异步的文件打开，则相当于将文件句柄返回给调用
者，而后续的内容，在调用者需要进行使用时，再加载到内存当中。两者的具体的情况如下
所示：
\begin{figure}[H]
  \centering
  % 禁止svg当中的特殊文字转换
  \includesvg[inkscapelatex=false, width=\linewidth]{rust_async}
  \caption{同步与异步执行的区别\protect\footnotemark}
  \label{fig:rust_async}
\end{figure}
\footnotetext{同/异步：\url{https://os.phil-opp.com/async-await/async-example.svg}}
上述例子当中，轮询阶段就相当于询问文件是否被打开，而等待阶段，则相当于等待文件的
内容加载内存当中，唤醒，则是调用者访问文件内容。

Rust的异步实现依赖于Future。在标准库当中，Rust提供了Future的
Trait以及\codeinlinebg{rust}{async}和\codeinlinebg{rust}{await}2个异步并发的关键字，
但是并没有提供具体的实现（即运行时），运行时则是由其他的库提供的，常见的就包括
上面提到的Async-Std和Tokio，以及Rust官方提供的futures（不在Rust的标准库当中）。
Rust的异步运行时可以分为2部分：执行器（executor）和反应器（reactor），
这2部分则是由Waker（唤醒器）进行交互。

以futures为例，一个简单的异步应用大致如下：
\begin{code-block}{rust}
extern crate futures;
async fn foo() -> u8 { 8 }
async fn hello() {
    let res = foo().await;
    println!("The res is {}", res);
}

fn main() {
    let future = hello();
    futures::executor::block_on(future);
}
\end{code-block}
在上述的例子当中，使用关键字\codeinlinebg{rust}{async}修饰的函数都是异步函数，这些
函数都会返回一个Future Trait，如果不使用\codeinlinebg{rust}{async}关键字，实际上
也是可以实现异步函数的定义的，只不过，会相对比较麻烦，并且需要显式的使用Future，
比如下面的代码：
\begin{code-block}{rust}
use futures::future::{self, Future};
fn async_read_file(name: &str) -> impl Future<Output = String> {
    future::ready(String::from(name))
}
fn async_with_lifetime<'a>(input: &'a u8) -> impl Future<Output = u8> + 'a {
    future::ready(*input)
}
\end{code-block}

Rust的Future Trait的定义如下\footnote{定义：\url{https://doc.rust-lang.org/std/future/trait.Future.html}}：
\begin{code-block}{rust}
pub trait Future {
    type Output;
    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output>;
}
\end{code-block}
其中，Output指的是异步函数的返回数据类型，而\codeinlinebg{rust}{poll}函数则是整个
Future工作机制的核心。该函数的实质是一个有限状态机，返回的Poll实际上是状态的描述。
Poll的定义如下：
\begin{code-block}{rust}
pub enum Poll<T> {
    Ready(T),
    Pending,
}
\end{code-block}
当异步函数的执行结果完成并且可用时，\codeinlinebg{rust}{poll}函数将返回一个Ready
包裹的结果，表示完成；如果执行还没有结束，则会返回一个Pending，表示执行还将继续，
相关的数据还没有准备完成，需要继续等待或者轮询，并且从当前的context当中，克隆一个
waker，一旦future状态有新的变化，waker函数将被唤醒。注意，如果状态不是Ready，poll函数
会被再次调用（间隔一定时间），直到返回Ready之后，poll函数将不再被调用。如果用普通的
Rust代码进行表示，其内在的逻辑可以模拟如下（但是性能非常差）：
\begin{code-block}{rust}
let future = async_read_file("foo.txt");
let file_content = loop {
    match future.poll(…) {
        Poll::Ready(value) => break value,
        Poll::Pending => {}, // do something
    }
}
\end{code-block}

而另一种思路，则是使用future的组合，比如下方的例子：
\begin{code-block}{rust}
use std::future::{self,Future};
use std::task::{Context, Poll};
use std::pin::Pin;
fn main() {
    let _ = file_len();
}
struct StringLen<F> {
    inner_future: F,
}
impl<F> Future for StringLen<F> where F: Future<Output = String>{
    type Output = usize;
    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        match self.inner_future.poll(cx) {
            Poll::Ready(s) => Poll::Ready(s.len()),
            Poll::Pending => Poll::Pending,
        }
    }
}
fn string_len(string: impl Future<Output = String>)
    -> impl Future<Output = usize>
{
    StringLen {
        inner_future: string,
    }
}
fn file_len() -> impl Future<Output = usize> {
    let file_content_future = async_read_file("foo.txt");
    string_len(file_content_future)
}
fn async_read_file(name: &str) -> impl Future<Output = String> {
    future::ready(String::from(name))
}
\end{code-block}
\important{
上述代码只是演示了一种Future可能的处理方式，但是，代码本身不可使用，原因在于在
上述代码当中还没有处理pin（固定）。
}

通过future的组合，可以实现非常高效的代码，但是，在某些情况下，由于Rust的类型系统
以及基于闭包的接口，会使得future的组合使用起来比较难，比如下面的代码：
\begin{code-block}{rust}
use futures::future::{self, Either, Future, FutureExt};
fn main() {
    let _ = example(100);
}
fn example(min_len: usize) -> impl Future<Output = String> {
    async_read_file("foo.txt").then(move |content| {
        if content.len() < min_len {
            Either::Left(async_read_file("bar.txt").map(|s| content + &s))
        } else {
            Either::Right(future::ready(content))
        }
    })
}
fn async_read_file(name: &str) -> impl Future<Output = String> {
    future::ready(String::from(name))
}
\end{code-block}
上述代码的功能很简单，读取foo.txt文件，然后使用\codeinlinebg{rust}{then}连接第二个
future：如果foo.txt的内容长度小于给定的最小值，则读取另一个文件bar.txt的内容，并将
其长度追加到返回结果当中，否则，只返回foo.txt的内容。上述操作当中，必须使用\codeinlinebg{rust}{move}
关键字，否则会存在一个生命周期的错误；另外，if/else必须返回相同的类型，但是，
上述代码当中，if返回的是\codeinlinebg{rust}{futures::future::Map}，而else返回的是\codeinlinebg{rust}{futures::future::Ready}，
必须使用\codeinlinebg{rust}{Either}将结果进行封装，转换成所期望的future。

\subsection{Future的async/await模式}
从上面的各种例子都可以看到，使用普通的方式实现Rust的异步编程可能会涉及到非常复杂的
代码，于是，Rust官方使用\codeinlinebg{rust}{async/await}等关键字，来简化异步编程的实现，
屏蔽了繁琐的实现细节。使用上述两个关键字之后，Rust的编译器会在编译过程当中进行
自动转换，转换成Future的模式，比如：
\begin{code-block}{rust}
async fn foo() -> u32 {
    0
}
// 编译器内部会自动转换成这种模式
fn foo() -> impl Future<Output = u32> {
    future::ready(0)
}
\end{code-block}

但是，这个转换过程对于开发者而言是透明无感的，以上面代码为例，使用async/await
进行改写之后的结果大致如下：
\begin{code-block}{rust}
async fn example(min_len: usize) -> String {
    let content = async_read_file("foo.txt").await;
    if content.len() < min_len {
        content + &async_read_file("bar.txt").await
    } else {
        content
    }
}
\end{code-block}
可以看到，代码更加的简练，并且逻辑上也是非常清晰。

但是，不管怎么变换，Future的内在还是一个有限状态机。\codeinlinebg{rust}{async}负责
将对应的函数转换成有限状态机，而\codeinlinebg{rust}{await}调用代表了不同的状态。
在上述代码当中，编译器将创建一个具有4个状态的状态机：
\begin{figure}[H]
  \centering
  \includesvg[inkscapelatex=false, width=\linewidth]{async-state-machine-states}
  \caption{异步状态机\protect\footnotemark}
  \label{fig:async-state-machine-states}
\end{figure}
\footnotetext{状态机：\url{https://os.phil-opp.com/async-await/async-state-machine-states.svg}}
\begin{enumerate}
  \item Start/End表示函数执行的开始和结束
  \item \colorblock{Waiting on foo.txt}状态表示该函数当前正在等待第一个async\_read\_file结果，表示一个暂停点
  \item \colorblock{Waiting on bar.txt}状态表示函数等待第二个async\_read\_file结果，同样也是一个暂停点
\end{enumerate}

有限状态机通过调用\codeinlinebg{rust}{poll}函数实现状态的切换，从而实现Future Trait：
\begin{figure}[H]
  \centering
  \begin{minipage}{\textwidth}
  \includesvg[inkscapelatex=false, width=\linewidth]{async-state-machine-basic}
  \caption{状态机切换\protect\footnotemark}
  \label{fig:async-state-machine-basic}
  \end{minipage}
\end{figure}
\footnotetext{状态转换：\url{https://os.phil-opp.com/async-await/async-state-machine-basic.svg}}

为了从最后一个等待状态继续，状态机必须在自身内部保持对当前状态的跟踪。此外，还必须
保存将在下一次poll调用当中需要被使用到的全部变量。幸运的是Rust编译器知道什么时候
使用哪些变量，因此，它可以自动生成包含了所需变量的结构体，注意，是\colorblock{自动生成}。
同样以上面的代码为例，如果深入到Rust编译器内部，看到的代码可能会是下面的样子：
\begin{code-block}{rust}
async fn example(min_len: usize) -> String {
    let content = async_read_file("foo.txt").await;
    if content.len() < min_len {
        content + &async_read_file("bar.txt").await
    } else {
        content
    }
}
// 注意，下面的代码是编译器自动生成的，不是开发者手动编写的
struct StartState {
    min_len: usize,
}
struct WaitingOnFooTxtState {
    min_len: usize,
    foo_txt_future: impl Future<Output = String>,
}
struct WaitingOnBarTxtState {
    content: String,
    bar_txt_future: impl Future<Output = String>,
}
struct EndState {}
\end{code-block}

在\colorblock{start}和\colorblock{Waiting on foo.txt}状态下，需要保存min\_len参数，
是因为在后面需要和content的长度进行比较，\colorblock{Waiting on foo.txt}状态保存
了另外一个foo\_txt\_future，代表了async\_read\_file的调用所返回的future，而这个
future会被状态机继续轮询，因此需要保留；\colorblock{Waiting on bar.txt}状态包含
内容变量，因为在bar.txt准备好后，字符串连接操作需要它。它还存储一个bar\_txt\_future，
表示bar.txt的正在进行的加载。该结构不包含min\_len变量，因为在content.len()比较之
后不再需要它。 在\colorblock{stop}状态下，不存储任何变量，因为该函数已经运行完成。

同样的，编译器也会自动生成状态机相关的代码，以上面的代码为例，Rust编译器会在内部
生成类似如下的状态机代码：
\begin{code-block}{rust}
enum ExampleStateMachine {
    Start(StartState),
    WaitingOnFooTxt(WaitingOnFooTxtState),
    WaitingOnBarTxt(WaitingOnBarTxtState),
    End(EndState),
}
\end{code-block}

使用编译器已经生成的各种状态结构体，利用enum将其进行封装成顶层的状态机，在此基础上，
为了完成/实现状态之前的切换，Rust编译器会根据上面的example函数自动生成其Future Trait
的实现，注意，下列代码也是Rust自动生成的，但并不代表编译器生成的代码就一定是下面
的样子：
\begin{code-block}{rust}
impl Future for ExampleStateMachine {
    type Output = String; // return type of `example`
    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {
        loop {
            match self { // TODO: handle pinning
                ExampleStateMachine::Start(state) => {…}
                ExampleStateMachine::WaitingOnFooTxt(state) => {…}
                ExampleStateMachine::WaitingOnBarTxt(state) => {…}
                ExampleStateMachine::End(state) => {…}
            }
        }
    }
}
\end{code-block}

状态机的Future实现关联数据类型Output为String，原因是异步函数example的返回类型是
String；同样的，由于Future Trait的定义当中包含了poll函数，因此，编译器又不辞辛劳
的生成或者说是实现了poll函数，在该函数体当中，使用loop-match对当前的状态进行轮询
和切换。当然，为了简单起见，这些编译器生成的代码都没有包含pin（固定，后续会专门
进行讲解），所有权以及生命周期等，因此，这些代码应当被视为不可运行的伪代码，而
编译器生成的真实代码，毫无疑问是可以处理上述的所有特性和问题的。

为了更进一步的理解Future Trait的内部实现机制，接下来会针对match的不同分支进行分析：
\begin{outline}[enumerate]
\1 Start分支

Rust编译器生成的Start分支的代码可能如下：
\begin{code-in-enumerate}{rust}
ExampleStateMachine::Start(state) => {
    // from body of `example`
    let foo_txt_future = async_read_file("foo.txt");
    // `.await` operation
    let state = WaitingOnFooTxtState {
        min_len: state.min_len,
        foo_txt_future,
    };
    *self = ExampleStateMachine::WaitingOnFooTxt(state);
}
\end{code-in-enumerate}
在example函数开始的时候，状态机实际上处于Start状态，在这种状态下，会执行example函数
体当中的代码，直到遇到第一个await关键字，即执行\codeinlinebg{rust}{async_read_file("foo.txt")}
这句，而为了处理该函数后面的await操作，编译器需要将状态机的状态修改为WaitingOnFooTxtState。
由于loop-match操作，状态机会跳入到WaitingOnFooTxtState分支。

\1 WaitingOnFooTxtState分支

同样的，该分支的代码（编译器自动生成）的可能如下：
\begin{code-in-enumerate}{rust}
ExampleStateMachine::WaitingOnFooTxt(state) => {
    match state.foo_txt_future.poll(cx) {
        Poll::Pending => return Poll::Pending,
        Poll::Ready(content) => {
            // from body of `example`
            if content.len() < state.min_len {
                let bar_txt_future = async_read_file("bar.txt");
                // `.await` operation
                let state = WaitingOnBarTxtState { content, bar_txt_future, };
                *self = ExampleStateMachine::WaitingOnBarTxt(state);
            } else {
                *self = ExampleStateMachine::End(EndState));
                return Poll::Ready(content);
            }
        }
    }
}
\end{code-in-enumerate}
注意，从该分支开始，poll函数被第一次调用，这是因为我们要获得foo\_txt\_future这个
future的真实结果，如果该结果没有准备好，则退出循环，返回pending状态；由于本次
循环当中，状态机实例（self）还是处于WaitingOnFooTxt状态，因此，下一次的轮询调用
仍然会执行当前的分支，不会进行状态切换（即进入其他的分支）。当foo\_txt\_future
准备就绪之后，结果将赋给content变量，如果content的长度满足最小长度，则状态机的
状态将被切换成EndState，直接返回一个Ready，结束轮询；否则，将异步读取bar.txt文件，
并再次通过await关键字将状态进行切换成为WaitingOnBarTxtState，而后续的轮询操作将进入
WaitingOnBarTxt这个分支。该分支的执行情况与本分支的类似。

\1 End分支

End分支应该是最为简单的分支，编译器生成的代码可能如下：
\begin{code-in-enumerate}{rust}
ExampleStateMachine::End(_) => {
    panic!("poll called after Poll::Ready was returned");
}
\end{code-in-enumerate}

实际上，一旦状态机变成了End状态，或者返回了Ready状态，就不能也不应该再次进行轮询，
而是直接退出循环和轮询，因此，如果是在End状态再次调用了poll函数，应当直接进行panic
处理。
\end{outline}

通过上述的模拟和分析大致理解编译器生成的状态机以及Future Trait的实现机制可能是
什么样的，实际上，编译器可以使用多种不同的方式实现或者生成Futrure Trait的代码，
目前看到的例子是基于生成器实现的。

目前还缺少异步函数本身的处理，要知道，原始的异步函数定义本身是下面的样式：
\begin{code-block}{rust}
async fn example(min_len: usize) -> String
\end{code-block}
由于完整的函数体是由状态机实现的（编译器内部/编译器视角），因此，编译器目前对原始
的异步函数做的唯一事情就是初始化状态机并返回它。编译器自动生成的相关代码可能如下：
\begin{code-block}{rust}
fn example(min_len: usize) -> ExampleStateMachine {
    ExampleStateMachine::Start(StartState { min_len, })
}
\end{code-block}
这个函数不再包含async关键字，取而代之的，则是返回状态机类型（ExampleStateMachine），
毫无疑问这个类型实现了Future Trait。如同上面的示例显示的一样，状态机在Start状态
当中被构造，并且使用min\_len参数初始化相应的状态结构体，一个Future在Rust编译器当
中是如何实现以及转换的大致过程就如同上述描述的过程。

\subsection{Future的pinning（锚点/固定）}
在之前的介绍当中已经提到了pinning，那pinning到底是什么。不过，先决条件是，需要了解
自引用结构（Self-Referential Structs）。所谓自引用结构，就是一个结构体当中包含了一个
字段，该字段直接引用了当前结构体当中的其他字段，或者该字段直接指向了当前结构体当中
的某个字段。

比如上面的Rust编译器实现的状态机，当其进行状态转换需要将每个暂停点的局部变量存储
在一个结构中，就属于一种简单的自引用结构的实际应用。对于类似于example这样的小函数，
一般不会出现问题，然而，当出现变量相互引用时，情况会变得更加的复杂，比如下面的代码：
\begin{code-block}{rust}
async fn pin_example() -> i32 {
    let array = [1, 2, 3];
    let element = &array[2];
    async_write_file("foo.txt", element.to_string()).await;
    *element
}
\end{code-block}

该函数创建了一个数组，然后创建了一个对数组最后一个元素的引用（地址），将其存储
在一个变量当中，并将该变量转换成字符串异步的写入一个文件当中，最后再返回该变量
所引用的数据。由于该函数只使用了一个await操作，因此，Rust编译器生成的状态机只有
3种：start，end和“wait on write”；由于该函数无参数传入，因此，start状态的结构体
是空的，与end状态的结构体类似，但是，“wait on write”的状态结构体会存在比较大的变化：
\begin{code-block}{rust}
struct WaitingOnWriteState {
    array: [1, 2, 3],
    element: 0x1001c, // array数组最后一个元素的地址
}
\end{code-block}

因为要返回array的元素值，并且返回的元素由element所代表的地址所引用，因此编译器
需要同时存储结构体的array和element。由于element本身代表了一个地址引用，存储的是
一个指向被引用元素的指针（内存地址），在这里使用0x1001c作为示例内存地址。该地址
指向数组array的最后一个元素，因此，它的实际内容取决于结构体在内存当中的位置。像
这种具有这种指向内部的结构体被称为\colorblock{自引用结构}，这种结构体可以使用自身的一个字段
来引用或者指向自己。

一般情况下，自引用结构在使用时和普通的结构并没有太大的区别，但是它在内存排列和管理
上，会带来一些问题，下图是上面的自引用结构体的内存示意图：
\begin{figure}[H]
  \centering
  \includesvg[inkscapelatex=false, width=\linewidth]{self-referential-struct}
  \caption{自引用结构的内存分布示意图\protect\footnotemark}
  \label{fig:self-referential-struct}
\end{figure}
\footnotetext{内存分布：\url{https://os.phil-opp.com/async-await/self-referential-struct.svg}}
如图，结构体当中的array的首地址是0x10014（每个元素4个长度），而element字段的地址
是0x10020，但是element存储的地址是0x1001c（即array最后一个元素的地址）。一切都表现
得很好。不过，一旦结构体在内存当中的地址发生了变化（比如将该结构体当作参数传递，
或者赋值给其他变量），结果就不一样了：
\begin{figure}[H]
  \centering
  \includesvg[inkscapelatex=false, width=\linewidth]{self-referential-struct-moved}
  \caption{移动后的内存分布示意图\protect\footnotemark}
  \label{fig:self-referential-struct-moved}
\end{figure}
\footnotetext{移动后的内存分布：\url{https://os.phil-opp.com/async-await/self-referential-struct-moved.svg}}
字段array的首地址已经变成了0x10024，但是，element字段当中存储的地址还是0x1001c，
这就导致使用element字段引用array的元素时，指向的地址是一个未经初始化的地址，即
指针悬空（相当于C/C++当中常见的野指针），这会直接导致在状态机的下一次轮询的时候
发生未定义的行为。

很显然，这种行为在Rust当中是不安全的，也是编译器严格禁止的，因此需要解决这种不
安全的行为。从现有的理论和实践当中，主要的做法有3种：
\begin{itemize}
  \item 移动时更新内部的指针

  其思想是在结构体在内存中移动时更新内部指针，以便在移动后它仍然有效，比较类似于
  C/C++当中对链表的删除/插入操作。但是，这种做法需要对Rust进行大量的修改，并且会
  造成较大的性能损失，其原因就在于需要跟踪所有结构字段的类型，并检查每个移动操作
  是否需要进行指针更新。

  \item 存储偏移地址而非绝对地址

  即不进行内部指针的更新，内部指针存储的不再是绝对的地址，而是从结构体首地址开始的
  偏移量。由于整体移动结构时，结构内部的地址排列和偏移并不会发生改变，因此，无需
  进行内部指针的更新。但是，这种实现方式要求编译器检查所有的自引用，因为引用的值
  可能来自于用户的输入，因此，这种检查方式几乎是不可能的。

  \item 禁止结构体移动

  如同上面所说，只有在内存当中发生了自引用结构体的移动才会出现悬空指针，当完全
  禁用了自引用结构上的移动操作，自然就避免了悬空指针的出现。这种方式可以在类型
  系统上直接实现。
\end{itemize}

由于第三种方式提供了零成本的抽象，没有增加额外的运行成本，因此被Rust采用，这就是
所谓的\colorblock{Pining（固定/锚点）}。

禁止内存地址移动，或者说固定内存地址，通常可以采取的一种方式是将其放在内存的堆区（heap），
因为堆区分配的值在大多数情况下已经有一个固定的内存地址，在调用allocate时被创建，
直到调用deacllocate将其释放，在此之间，指针指向的堆值将保持在相同的内存地址，
因此可以利用该特性在堆区上创建自引用数据结构：
\begin{code-block}{rust}
fn main() {
    let mut heap_value = Box::new(SelfReferential {
        self_ptr: 0 as *const _, // 使用0x00当作初始的地址
    });
    // *heap_value表示从Box指针当中取出真正的元素
    // &*heap_value表示对Box当中的真正元素进行引用（取地址）操作
    // as *const 表示将其转换成对应类型的指针
    let ptr = &*heap_value as *const SelfReferential;
    // 将自身的地址赋给自己的字段
    heap_value.self_ptr = ptr;
    println!("heap value at: {:p}", heap_value);
    println!("internal reference: {:p}", heap_value.self_ptr);
}

struct SelfReferential {
    self_ptr: *const Self,
}
\end{code-block}

结构体SelfReferential包含了一个字段self\_ptr，该字段指向实例本身的地址，构成了
一个自己对自己的引用，如果执行上述代码，可以发现，结构体实例（self）和结构体字段
（self\_ptr）的地址实际上是一样的：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{self_ref_on_heap.png}
  \caption{堆区实现自引用结构}
  \label{fig:self_ref_on_heap}
\end{figure}

这是一个有效的自引用结构，并且，由于heap\_value只是一个指针，对它的移动操作（
比如赋值给其他变量，或者作为参数传递）并不会改变结构本身的地址，所以，self\_ptr
会一直保持有效。但是，这种“固定效果”很容易被打破或者破坏，比如将Box包裹的数据解引用
或者直接替换：
\begin{code-block}{rust}
use std::mem;
fn main() {
    let mut heap_value = Box::new(SelfReferential {
        self_ptr: 0 as *const _,
    });
    let ptr = &*heap_value as *const SelfReferential;
    heap_value.self_ptr = ptr;
    println!("heap value at: {:p}", heap_value);
    println!("internal reference: {:p}", heap_value.self_ptr);

    // break it
    let stack_value = mem::replace(&mut *heap_value, SelfReferential {
        self_ptr: 0 as *const _,
    });
    println!("value at: {:p}", &stack_value);
    println!("internal reference: {:p}", stack_value.self_ptr);
    let hp = *heap_value;
    println!("heap value at: {:p}", &hp);
    println!("internal reference: {:p}", &(hp.self_ptr));
}
struct SelfReferential {
    self_ptr: *const Self,
}
\end{code-block}
则可以观察到，对应的结构体的内存地址全部发生了变化：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{self_ref_on_heap_break.png}
  \caption{自引用结构的内存破坏}
  \label{fig:self_ref_on_heap_break}
\end{figure}

\warn{
这种操作是比较危险的，利用mem::replace函数，将原本由堆分配的值替换成新的结构体实例，
即将原始的heap\_value移动到了栈区，此时，self\_ptr变成了悬空指针，仍然指向了原始的
堆区地址，因此，使用堆区分配的方式，并不足以保障自引用结构的安全。
}

造成上述问题的根本原因在于Box<T>允许开发者获得一个针对在堆上分配的T的\&mut T的引用，
这使得利用诸如mem::replace/mem::swap这样的函数通过\&mut T实现对堆区数据进行修改
成为可能，从而使得在堆区分配的值失效。为此，针对自引用结构，禁止创建\&mut T这样
的引用是必须的。



\section{优秀的并发-Crossbeam}
默认情况下，Rust标准库的多线程并发是非常安全和方便的，但是，也存在一些特殊情况，
会导致标准库的多线程使用起来受到诸多的限制，比如，在递归函数当中使用多线程：
\begin{code-block}{rust}
use std::thread;
const THRESHOLD: usize = 4;
// 由于Rust的跨线程通信的限制，要求input参数必须是static的生命周期
pub fn find_max(input: &'static [i32]) -> Option<i32> {
    if input.len() <= THRESHOLD {
        return input.iter().cloned().max();
    }
    let middle = input.len() / 2;
    let (left, right) = input.split_at(middle);
    // 由于thread限制，必须使用move关键字
    let thread_left = thread::spawn(move || find_max(left));
    let thread_right = thread::spawn(move || find_max(right));
    let max_left = thread_left.join().unwrap().unwrap();
    let max_right = thread_right.join().unwrap().unwrap();
    Some(max_left.max(max_right))
}
fn main() {
    static ARRAY_REF: &[i32] = &[12, 3, 45, 98, 100, 23, 878, 8765, 123, -897, 866666, 1241];
    let res = find_max(ARRAY_REF);
    info!("The res is {:?}", res);
}
\end{code-block}
由于诸多的限制，上述代码当中，如果需要对多个数组进行排序，则这些数组必须使用static
关键字进行标识，无法处理普通的数组，并且最终会导致生成的二进制文件比较大。

除此之外，比如Rust的通道，只存在多生产者单消费者这一种模式，这也并不符合现实生活
当中的多生产者多消费者的模型。为了改进Rust的并行/并发，目前大多数的开发者使用
Crossbeam\footnote{\url{https://github.com/crossbeam-rs/crossbeam}}替代标准库的thread，
比如，上述的递归函数当中使用多线程，就可以修改为如下的模式：
\begin{code-block}{rust}
extern crate crossbeam;
pub fn find_max_crossbeam(input: &[i32]) -> Option<i32> {
    if input.len() <= THRESHOLD {
        return input.iter().cloned().max();
    }
    let middle = input.len() / 2;
    let (left, right) = input.split_at(middle);
    crossbeam::scope(|s| {
        let thread_left = s.spawn(|_| find_max_crossbeam(left));
        let thread_right = s.spawn(|_| find_max_crossbeam(right));
        let max_left = thread_left.join().unwrap().unwrap();
        let max_right = thread_right.join().unwrap().unwrap();
        Some(max_left.max(max_right))
    })
    .unwrap()
}
fn main() {
    static ARRAY_REF: &[i32] = &[12, 3, 45, 98, 100, 23, 878, 8765, 123, -897, 866666, 1241];
    let res = short_lived::find_max_crossbeam(ARRAY_REF);
    info!("The res is {:?}", res);
    let array = [
        12, 3, 45, 98, 100, 23, 878, 8765, 123, -897, 866666, 12411234,
    ];
    let res = short_lived::find_max_crossbeam(&array);
    info!("The res is {:?}", res);
}
\end{code-block}
通过这样修改的函数，不管是针对static生命周期的还是普通生命周期的数据，都能够自如的处理。

同样的，也可以对Rust标准库的通道（Channel）进行优化，此时，则需要配合使用
\href{https://github.com/crossbeam-rs/crossbeam}{Crossbeam-Channel}。比如下面的例子：
启动2个并行的通道，一个通道负责消息的生产发送，一个通道负责消息的接收和处理。

\input{rust_part_8}
