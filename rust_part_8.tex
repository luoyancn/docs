\section{超越Unsafe}
Rust屏蔽了一系列的不安全操作来换取应用程序的稳定性和可靠性，但是，可以通过关键字
unsafe，切换到不安全的运行环境当中，并且在unsafe的代码块当中运行。常见的不安全操作
如下：
\begin{enumerate}
  \item 解引用裸指针
  \item 使用不安全的方法/函数
  \item 访问/修改可变的静态变量
  \item 实现不安全的Trait
  \item 访问union的字段
\end{enumerate}
在使用的时候，原则需要明确：保持unsafe块尽可能小，将不安全代码封装进一个安全的
抽象并提供安全API是一种常见的安全操作和手段。

所谓的裸指针，和普通的指针和智能指针相比，存在如下的区别：
\begin{enumerate}
  \item 允许忽略借用规则，可以同时拥有不可变和可变的指针，或多个指向相同位置的可变指针
  \item 不保证指向有效的内存
  \item 允许为空
  \item 不能实现任何自动清理功能
\end{enumerate}
Rust当中存在2个裸指针：分别写作*const T（不可变）和*mut T（可变），其基本的定义方式
如下：
\begin{code-block}{rust}
let mut num = 5;
let r1 = &num as *const i32; // 不可变的裸指针
let r2 = &mut num as *mut i32; // 可变的裸指针
\end{code-block}

裸指针的定义是安全的，但是，它的使用是不安全的，因此裸指针的使用必须在unsafe块
当中：
\begin{code-block}{rust}
fn main() {
    let mut num = 5;
    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;
    unsafe {
        *r2 = 10;
        // r1，r2和num都会变更为10
        println!("{},{}", *r1, *r2);
    }
}
\end{code-block}
同样的，unsafe也可以用于定义函数/方法，不过也需要在unsafe块当中使用；但是，unsafe
的方法可以作为安全方法进行导出，在使用时，则不需要使用unsafe进行标记：
\begin{code-block}{rust}
fn main() {
    let mut num = 5;
    // 定义裸指针
    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;
    // 使用不安全的函数/方法
    unsafe {
        unsafe_change(r1, r2);
    }
    println!("{}", num);
    safe_change(r1, r2);
    println!("{}", num);
}
// 定义不安全的函数/方法
unsafe fn unsafe_change(r1: *const i32, r2: *mut i32) {
    *r2 = 10;
    println!("{},{}", *r1, *r2);
}
// 将不安全的函数/方法封装进安全的方法当中
fn safe_change(r1: *const i32, r2: *mut i32) {
    unsafe {
        *r2 = 100;
    }
}
\end{code-block}

作为不安全的一部分，某些时候直接在Rust当中调用C语言的类库可以获得更好的性能，此时，
则同样需要在unsafe块当中使用，比如在Rust当中调用标准C的abs（绝对值）函数：
\begin{code-block}{rust}
extern "C" {
    fn abs(input: i32) -> i32;
}
fn main() {
    unsafe {
        println!("The unsafe from C: {}", abs(-200));
    }
}
\end{code-block}
上述代码出现的extern关键字，有助于创建和使用外部函数接口（Foreign Function
Interface，FFI）。外部函数接口是一个编程语言用以定义函数的方式，其允许不同（外部）
编程语言调用这些函数。Extern块中声明的函数在Rust代码中总是不安全的，

特别需要注意的是，Rust当中的可变全局变量（static）同样是不安全的，需要在unsafe
代码块当中使用；而不可变的全局常量（const和static）则不需要在unsafe块当中；另外，
全局变量同样可以是任意数据类型的：
\begin{code-block}{rust}
use std::fmt;
struct Version {
    major: u8,
    minor: u8,
}
impl fmt::Display for Version {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "The version of this bin is {}.{}",
            self.major, self.minor
        )
    }
}
// 不可变的全局常量
const __CONST_NUM__: Version = Version { major: 1, minor: 4 };
const __VERSION__: &str = "v1.4.0";
static __NAME__: &str = "lucifer";
// 可变的全局变量
static mut __COUNTER__: u8 = 1;
fn main() {
    println!("{}", __CONST_NUM__);
    println!("{}", __NAME__);
    unsafe {
        println!("{}", __COUNTER__);
    }
}
\end{code-block}

但是，并不是所有情形都适合使用unsafe，Rust本身也无法从编译器层面，保证unsafe的
代码块是完全正确的，不会出现任何错误的。比如，我们在使用裸指针*const T和*mut T
的时候，如果不够仔细，非常容易造成错误的结果：
\begin{code-block}{rust}
let mut y: u32 = 1;
let x = 1_i32;
// 将y转换成u32的裸指针，再转换成i32的裸指针，最后转换成i64的裸指针
let raw_mut = &mut y as *mut u32 as *mut i32 as *mut i64;
unsafe {
    // 对裸指针进行修改，类似于C/C++当中对指针数据的操作
    *raw_mut = -1;
}
info!("The x is {:X} and y is {:X}", x, y);
\end{code-block}
按照我们本来的设想，x会保持不变，始终为1，而y则可能变换成其他的数值，但是，实际
的结果却如下：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_raw_pointer.png}
  \caption{具有潜在错误的裸指针示例}
  \label{fig:rust_raw_pointer}
\end{figure}
x变成和y一样的值的原因在于：对指向y的指针类型做了转换，让它以为自己指向的是i64
类型，恰巧x就在y旁边，y被修改的同时，就顺带把x也修改了。因此，使用unsafe必须特别
小心。

在通常的情况下，虽然可以通过引用+mut的方式，可以阻止大部分的内存不安全问题，但是
由于引用+mut的强限制性，也为带来一些比较麻烦和无奈的问题，比如下面的代码：
\begin{code-block}{rust}
#[derive(Debug)]
struct Tuple {
    first: u8,
    second: u8,
    third: u8,
}
fn main() {
    let mut t = Tuple {
        first: 0,
        second: 1,
        third: 2,
    };
    let pa = &mut t.first;
    let pb = &mut t.second;
    let pc = &mut t.third;
    *pc += 10;
    info!("{:?}", t);
}
\end{code-block}
上述代码是正确无误的，可以正常编译和运行，但是，如果我们将结构体变成数组，问题就
出现了：
\begin{code-block}{rust}
fn main() {
    let mut array_x = [1_i32, 2, 8];
    let pa = &mut array_x[0];
    let pb = &mut array_x[1];
    *pb += 10;
    info!("{:?}", t);
}
\end{code-block}
上述代码在Rust 1.50.0版本之前就会出现错误：
\begin{code-block}{bash}
error: cannot borrow `x[..]` as mutable more than once at a time
\end{code-block}
原因在于，在Rust 1.50.0版本之前的结构体当中，pa，pb和pc指向不同的内存区域；
但是在数据当中，Rust编译器会将[\_]识别为一个整体，而\&[0], \&[1]之间都属于重叠，
将pa和pb判断为存在别名关系，即pa和pb实质上相同，违反了借用规则，因此无法通过编译。
采用引用分割才能进行解决：
\begin{code-block}{bash}
let mut array_x = [1_i32, 2, 3];
// 通过split_at_mut将数组切分成2个一定不会重叠的切片
let (first, rest): (&mut [i32], &mut [i32]) = array_x.split_at_mut(1);
let (second, third): (&mut [i32], &mut [i32]) = rest.split_at_mut(1);
first[0] += 100;
second[0] += 200;
third[0] += 300;
info!("{:?}", array_x);
\end{code-block}

由于Rust的目标是系统级的语言，必然需要具备操作硬件，以及裸设备的能力。而这些能力，
在C/C++的表述当中，通常是采用共用体（Union）实现的。为了与之兼容，Rust当中也引入了
Union数据结构，其主要的使用形式如下：
\begin{code-block}{rust}
#[repr(C)]
pub union U {
    pub i: u32,
    pub f: f32,
}

#[repr(C)]
pub struct Value {
    pub tag: u8,
    pub value: U,
}
\end{code-block}
其中，\#[repr(C)]必须使用，因为union的使用场景本身就是为了和C/C++进行对接，表示
该联合体使用和C/C++一样的内存布局。由于在字段当中使用了union，因此，结构体Value
也必须添加repr属性，否则会出现未定义的错误。而在使用的时候，则更加需要注意，只要
是涉及到读取联合体的字段，则必须使用unsafe：
\begin{code-block}{rust}
// 禁用illegal_floating_point_literal_pattern警告
#[allow(illegal_floating_point_literal_pattern)]
pub fn is_zero(v: &Value) -> bool {
    unsafe {
        match &v {
            Value {
                tag: Tag::I,
                value: U { i: 0 },
            } => true,
            Value {
                tag: Tag::F,
                // 会出现#[warn(illegal_floating_point_literal_pattern)]警告
                // 目前rust正在修复该问题
                value: U { f: 0.0 },
            } => true,
            _ => false,
        }
    }
}
\end{code-block}

Rust所有的unsafe实际都来源于性能和C的结合（比如写linux内核模块），因此原生指针
在unsafe当中最为常用。其主要的用途如下：
\begin{itemize}
  \item 在必要的时候跳过Rust安全检查：有的情况下，程序逻辑不会有任何内存安全的问题，原生指针可以跳过安全检查，提升性能
  \item 与C语言进行交互，必须使用原生指针
\end{itemize}

空指针在C语言当中非常常见，Rust当中也可以创建原生的空指针，也可以利用原生指针修改
数据：
\begin{code-block}{rust}
// 创建一个指向unsigned char的原生null指针
let pointer: *const u8 = std::ptr::null();
// 判断指针是否为空
assert!(pointer.is_null());

let mut s = [1, 2, 3];
// 创建一个可变的指针，该指针指向一个unsigned int的数组
let pointer: *mut u32 = s.as_mut_ptr();
assert!(!pointer.is_null());

unsafe {
    // 访问s[1]
    info!("The offset 1 is {}", *pointer.offset(1));
    // 访问s[2]
    info!("The offset 2 is {}", *pointer.offset(2));
    // 修改s[2]
    *pointer.offset(2) = 4;
    info!("The offset 2 is {}", *pointer.offset(2));
    // 将s[2]先转换成u8，然后再转换成char
    info!("The offset 2 is {}", *pointer.offset(2) as u8 as char);
}

info!("The final result of s is {:?}", s);
\end{code-block}

\section{常见错误处理方法}
由于很多代码都是第三方的，而Rust本身也在不断的发展，有可能出现版本不兼容或者特性
不兼容的情况，此时，则需要进行相关的修改。比如下面的一种错误：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_feature_error.png}
  \caption{缺少特性支持编译失败}
  \label{fig:rust_feature_error}
\end{figure}
遇到这种错误，则需要直接修改对应的类库的源代码。以上述错误为例，编译的help表示
需要添加代码\codeinline{bash}{add `#![feature(array_value_iter_slice)]` to the crate attributes to enable}，
则我们应当在对应的crate的lib.rs的头部当中，添加内容如下：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_feature_add.png}
  \caption{增加特性支持}
  \label{fig:rust_feature_add}
\end{figure}

\section{死灵书与实践}

\subsection{随机数实践}
Rust的随机数模块并不包含在标准库当中，需要使用rand这个crate，其基本的使用如下：
\begin{code-block}{rust}
use rand::distributions::{Distribution, Uniform};
use rand::seq::IteratorRandom;
use rand::Rng;
fn main() {
    let mut rng = rand::thread_rng();
    // 生成随机数
    info!("The float64 rand number is {}", rng.gen::<f64>());
    info!("The u32 rand number is {}", rng.gen::<u32>());
    info!("The i32 rand number is {}", rng.gen::<i32>());
    info!("The u8 rand number is {}", rng.gen::<u8>());
    // 从指定区间生成随机数
    info!("The range rand number is {}", rng.gen_range(0..100));
    info!(
        "The range rand float number is {}",
        rng.gen_range(10.0..50.0)
    );
    // 从[0, 5]生成随机数
    info!("The range rand number is {}", rng.gen_range(0..=5));
    // 定义[1, 7)的均匀分布
    let die = Uniform::from(1..7);
    // 从该分布当中生成采样
    let throw = die.sample(&mut rng);
    info!("The sample of uniform is {:>width$}", throw, width = 5);
    // 生成多个随机数
    let tuple: (u8, u8, u8) = rng.gen();
    info!("The tuple of random is {:?}", tuple);
    // 生成随机数组
    let array: [u8; 6] = rng.gen();
    info!("The array of random is {:?}", array);
    let mut exsit_array: [u8; 5] = [1, 2, 34, 5, 6];
    // 使用随机数填充已存在的数组
    rng.fill(&mut exsit_array);
    info!("The array of random is {:?}", exsit_array);
    // 从均匀分布当中随机采样3个数据
    // 得到的结果可能出现重复的情况
    let samples: Vec<u8> = (&mut rng).sample_iter(die).take(3).collect();
    info!("The samples of sample range 1..7 is {:?}", samples);
    let v = vec![1, 2, 3, 4, 5];
    // 从vec当中采样4个数据，得到的结果不会重复
    let sample = v.iter().choose_multiple(&mut rng, 4);
    info!("The samples of sample range 1..5 is {:?}", sample);
    let sample: Vec<u8> = (1..=10).choose_multiple(&mut rng, 4);
    info!("The samples of sample range 1..10 is {:?}", sample);
}
\end{code-block}

Rust的rand crate不仅可以生成随机数，也可以生成自定义的随机数据，比如：
\begin{code-block}{rust}
use rand::distributions::{Distribution, Standard, Uniform};
use rand::seq::IteratorRandom;
use rand::Rng;
struct Point {
    x: u8,
    y: u8,
}
impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "x: {}, y: {}", self.x, self.y)
    }
}
// 在 Point 类型之上，对Standard实现Distribution trait，使得Point可以被gen函数随机生成
impl Distribution<Point> for Standard {
    // 默认的实现方法
    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Point {
        let (rand_x, rand_y) = rng.gen();
        Point {
            x: rand_x,
            y: rand_y,
        }
    }
}
fn main() {
    let mut rng = rand::thread_rng();
    let rand_point = rng.gen::<Point>();
    info!("The rand_point is {}", rand_point);
}
\end{code-block}

同样的，可以生成随机的字符串：
\begin{code-block}{rust}
use rand::distributions::{Alphanumeric, Distribution, Standard, Uniform};
use rand::seq::IteratorRandom;
use rand::Rng;
fn main() {
    let mut rng = rand::thread_rng();
    let rand_string: String = (&mut rng)
        // 从a-z，A-Z以及0-9当中进行选择
        .sample_iter(&Alphanumeric)
        // 获取其中的10个元素
        .take(10)
        // 默认的结果是char类型，需要继续转换成String
        .map(char::from)
        .collect();
    info!("The rand_string is {}", rand_string);
}
\end{code-block}

如果默认的字符集不满足要求，还可以自定义字符集，比如下面的示例：
\begin{code-block}{rust}
use rand::distributions::{Alphanumeric, Distribution, Standard, Uniform};
use rand::seq::IteratorRandom;
use rand::Rng;
const CHARSET: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\
    abcdefghijklmnopqrstuvwxyz\
    0123456789)(*&^%$#@!~";
const PASSWORD_LEN: usize = 10;
fn main() {
    let mut rng = rand::thread_rng();
    let password: String = (0..PASSWORD_LEN)
        .map(|_| {
            let idx = rng.gen_range(0..CHARSET.len());
            CHARSET[idx] as char
        })
        .collect();
    info!("The password is {}", password);
    // 也可以更换成之前的采样函数，看起来更为精炼
    let passwd: String = CHARSET
        .choose_multiple(&mut rng, 10)
        .map(|r| *r as char)
        .collect();
    info!("The password is {}", passwd);
}
\end{code-block}

同样的，针对自定义的数据类型，同样可以采用采样方法，进行随机数据的提取：
\begin{code-block}{rust}
use rand::distributions::{Alphanumeric, Distribution, Standard, Uniform};
use rand::seq::IteratorRandom;
use rand::Rng;
#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}
fn main() {
    let mut rng = rand::thread_rng();
    let persons = vec![
        Person {
            name: "lucifer".to_string(),
            age: 18,
        },
        Person {
            name: "titans".to_string(),
            age: 19,
        },
        Person {
            name: "garuda".to_string(),
            age: 36,
        },
    ];
    // 从person的vec当中，随机抽取2个元素
    let rand_person: Vec<_> = persons.choose_multiple(&mut rng, 2).collect();
    info!("The rand person is {:?}", rand_person);
}
\end{code-block}

\subsection{类型再论}
Rust的类型比较多，char，字符串，整数，浮点数等等。这些基础类型和其他语言比较类似，
但是也包含了自己的特点：比如，char类型占据4个字节，可以存放任何一个unicode字符；
对于ASCII字符，只需要一个字节即可，而一个字节的数据，则可以放在u8类型的数据当中，
因此，对于ASCII类型的字符串/字符数组，可以使用u8类型（即单字节）的数组进行存放，
这样，占用的资源空间会比char的数组小：
\begin{code-block}{rust}
fn main() {
    // 字符串前面的b，表示将对应的字面量存放在u8类型当中
    let s: &[u8] = b"hello";
    info!("{:?}", s);
}
\end{code-block}
同时，Rust支持的整数类型比较广泛，包括8bit，16bit，32bit，64bit，最大可以支持到
128bit；而特殊的isize和usize，则是和平台相关。如果平台是32位的，则isize和usize为
32位，如果是64位，则其数据宽度为64位。

整个Rust的类型当中，只有空类型占据的空间是最小的，都是0。Rust的空类型包括单元类型
（unit，即空元组）以及空结构体：
\begin{code-block}{rust}
// empty是空元组类型
let empty : () = ();
// 空结构体
struct Empty();
\end{code-block}
为了查看类型所占用的空间，可以使用size\_of函数进行查看：
\begin{code-block}{rust}
use std::mem;
struct Empty();
fn main() {
    info!("The Empty struct size is {}", mem::size_of::<Empty>());
    // 查看空元组所占据的内存大小
    info!("The none tuple size is {}", mem::size_of::<()>());
}
\end{code-block}

在Rust当中，浮点类型是非常特殊的数据类型。浮点类型当中，存在一个特殊的值：NaN，
即非法的浮点数值，因为该数据的存在，浮点数不具备全序关系（total order）。所谓的
全序，偏序，Rust当中的定义如下：对于集合X当中的元素a，b，c
\begin{itemize}
  \item 如果a<b，则!(a>b)一定成立；反之，如果a>b，则!(a<b)一定成立，即反对称性
  \item 如果a<b，b<c，则a<c，即传递性
  \item 对于X当中的所有元素，都存在a<b，或者a>b，或者a==b，三者必居其一，即完全性
\end{itemize}
如果X集合只满足前面2条，则称之为偏序；具备上述所有特征，则为全序。由于浮点数的NaN
不满足上述第3条规则，因此，Rust的浮点数属于偏序，而非全序，这回导致一个问题：浮点
数无法排序——非NaN的数值无法与NaN进行比较：
\begin{code-block}{rust}
let nan = std::f32::NAN;
let x = 0.4f32;
// 下列结果全部为false
info!("{}", nan > x);
info!("{}", nan < x);
info!("{}", nan == x);
\end{code-block}
为此，Rust设计了2个Trait表示全序与偏序：\codeinlinebg{rust}{std::cmp::Ord}（全序）以及
\codeinlinebg{rust}{std::cmd::PartialOrd}（偏序）。
PartialOrd这个Trait的partial\_cmp方法返回的是Option<Ordering>，而Ord返回的却是
Ordering。Rust的f32和f64都只实现了PartialOrd，因此，浮点类型无法进行排序，也同样无法
求取最值，如下列代码，则是无法运行的：
\begin{code-block}{rust}
let f_vec = vec![1f32, 2.0, 4.0, 0.0, -1.2];
let bigest_f = f_vec.iter().max();
\end{code-block}
对上诉代码进行编译，会直接提示如下类似的错误：
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.2]{rust_float_cmp_error.png}
  \caption{浮点数的最值错误求解}
  \label{fig:rust_float_cmp_error}
\end{figure}
浮点数的排序只能通过partial\_cmp（比较相等关系）进行变换处理，如下方代码：
\label{float_sort}
\begin{code-block}{rust}
let mut f_vec = vec![1f32, 2.0, 4.0, 0.0, -1.2];
// 升序排列
f_vec.sort_by(|first, second| first.partial_cmp(second).unwrap());
// 获取排序后的最后一位
let max = f_vec.last().unwrap();
// 或者如下进行
// let max = f_vec.as_slice().last().unwrap();
// 降序排列
f_vec.sort_by(|first, second| second.partial_cmp(first).unwrap());
\end{code-block}

作为常用数据类型之一，Rust的数组也存在自己的特点，比如同类型的数组之间可以相互赋值：
\begin{code-block}{rust}
let mut array: [u32; 4] = [1, 23, 4, 5];
let array_copy: [u32; 4] = [5, 6, 7, 8];
array = array_copy;
\end{code-block}
支持数组之间的直接比较，只是数组当中的元素本身就可以进行比较才行：
\begin{code-block}{rust}
let array: [u32; 4] = [1, 23, 4, 5];
let array_copy: [u32; 4] = [5, 6, 7, 8];
info!("{:?}", array < array_copy);
\end{code-block}

Rust当中的函数也可以称之为类型的一种，并且，每个函数都有自己单独的类型，函数的类型
是fn。但是，函数的参数列表会影响fn类型的判断和表达，比如下面的例子：
\begin{code-block}{rust}
fn add_tuple(t: (u32, u32)) -> u32 {
    t.0 + t.1
}
fn add_two((x, y): (u32, u32)) -> u32 {
    x + y
}
fn add_normal(x: u32, y: u32) -> u32 {
    x + y
}
\end{code-block}
实际上，add\_tuple和add\_two这2个函数被fn类型识别成为具有相同签名的类型，因此，
在理论上，我们可以使用同一个变量，接收这2个函数的指针：
\begin{code-block}{rust}
fn main() {
    let mut func = add_tuple;
    func = add_two;
    ...
}
\end{code-block}
但是，上述代码却是错误的：虽然签名相同，但是，类型不同：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_func_type.png}
  \caption{相同签名的不同函数类型}
  \label{fig:rust_func_type}
\end{figure}
解决方法，则是将其转换成通用的fn类型：
\begin{code-block}{rust}
fn main() {
    // 显示指定func的类型
    let mut func: fn((u32, u32)) -> u32 = add_tuple;
    // 使用as进行类型的转换
    // let mut func = add_tuple as fn((u32, u32)) -> u32;
    func = add_two;
    ...
}
\end{code-block}
但是，需要注意，add\_normal的功能看上去和前面两个函数的功能相同，但是，他们的
函数签名完全不同，因此，不能将其转换成func。

函数是Rust的头等公民，可以在函数/方法当中定义函数，也可以在函数/方法当中定义结构
体，甚至于定义结构体的方法和实现，以及静态变量，常量等：
\begin{code-block}{rust}
fn func_as_first(x: u32, y: u32) -> (u32, u32) {
    struct Point {
        x: u32,
        y: u32,
    };
    impl Point {
        fn area(&self) -> u32 {
            self.x * self.y
        }
        fn cycle(&self) -> u32 {
            self.x + self.y
        }
    };
    let p = Point { x: x, y: y };
    (p.area(), p.cycle())
}
\end{code-block}

常规的函数类型，都会存在返回值，这些返回值要么是特定的类型，要么就是()，即类似
C/C++的返回void。如果需要什么都不返回，则可以使用!，这种函数称之为发散函数，比如
在处理panic时，有时就需要使用发散函数：
\begin{code-block}{rust}
fn diverges() -> ! {
    panic!("This function never returns!");
}
\end{code-block}
Panic操作会直接导致软件栈展开，因此，后续的操作都不会执行，其返回的就是一个!。
发散函数的最大特点，就是可以被转换成任意一个类型，虽然执行的时候最终还是会崩溃，
如下：
\begin{code-block}{rust}
let x : i32 = diverges();
let y : String = diverges();
\end{code-block}
但是，发散函数最大的作用，在于解决编译器的类型检查：
\begin{code-block}{rust}
let p = if x {
    panic!("error");
} else {
    100
};
\end{code-block}
对于let-if而言，if-else的每个分支都必须是相同的数据类型，通过发散函数的任意类型
转换特性即!与任何类型兼容，所以上述代码才能编译通过。

所有的Rust变量，函数都是类型的一种，都可以通过一定的手段和方式，获得类型的具体信息。
常见的方式有两种，一种是使用错误信息进行推断，一种则是使用标准库函数进行获得。

通过构造一个特殊的函数，然后调用该函数，则可以获得相关的类型信息：
\begin{code-block}{rust}
// 接收一个unit参数
fn type_id(_: ()) {}

fn main() {
    let ref i = 5;
    type_id(i);
}
\end{code-block}

而另外的方式，则是使用标准库函数，不过，这个标准库函数在Rust的默认stable分支当中
是不可用的，需要在nightly分支当中进行编译使用，并且，还需要启用一些特性：
\begin{code-block}{rust}
#![feature(core_intrinsics)]
use std;
// 使用泛型参数进行不同类型的数据接收
fn print_type<T>(_arg: &T) {
    println!(
        "The type name of arg is {}",
        std::intrinsics::type_name::<T>()
    );
}
fn main() {
    let ref x = 5;
    print_type(&x);
}
\end{code-block}
编译上述代码时，则需要对编译指令进行部分的调整：
\codeinlinebg{bash}{cargo +nightly build}，
然后即可实现对参数类型的打印输出。

在Rust当中，与Python不同，函数/方法并不存在默认参数，但是，结构体当中的字段，却可以
有默认值，只是，这个默认值的实现，必须和Default Trait相结合，如下：
\begin{code-block}{rust}
struct ColoredString {
    input: String,
    fg_color: String,
    bg_color: String,
}
impl Default for ColoredString {
    fn default() -> Self {
        ColoredString {
            input: String::default(),
            fg_color: String::default(),
            bg_color: String::default(),
        }
    }
}
fn main() {
    let color = ColoredString::default();
}
\end{code-block}
从上述代码当中可以看出，实际上，并不是Rust的结构体字段赋予了初始值，而是通过一个
名为default的方法，构造一个我们认为应该具有默认值的结构体。在Rust当中，常用的基本
数据类型都实现了Default Trait，可以直接使用对应的default方法。

\subsection{Trait类型与泛型再论}
关于类型，Trait也是比较重要的一个话题。在之前的示例当中，Trait全部是在具体的类型
上实现的，但是，Trait本身也可以在智能指针（Box）上实现，比如：
\begin{code-block}{rust}
trait Shape {
    fn area(self: Box<Self>) -> f64;
}
struct Circle {
    radius: f64,
}
impl Shape for Circle {
    fn area(self: Box<Self>) -> f64 {
        PI * self.radius * self.radius
    }
}
fn main() {
    let c = Box::new(Circle { radius: 4f64 });
    info!("{}", c.area());
    // 由于trait实现是在智能指针box上，因此，下面的使用是错误的
    // let c = Circle { radius: 4f64 }
    // c.area()
}
\end{code-block}
甚至在Trait上实现Trait，比如下方：
\begin{code-block}{rust}
trait Shape {
    fn area(&self) -> f64;
}
trait Round {
    fn get_radius(&self) -> f64;
}
struct Circle {
    radius: f64,
}
impl Round for Circle {
    fn get_radius(&self) -> f64 {
        self.radius
    }
}
impl Shape for dyn Round {
    fn area(&self) -> f64 {
        let radius = self.get_radius();
        PI * radius * radius
    }
}
\end{code-block}
Shape是一个Trait，Round同样也是一个Trait，Circle实现了Round，Round实现了Shape，
但是，由于Round本身是一个Trait，拥有不确定性，因此，在实现Shape的时候，需要添加
dyn关键字，提示这个Round不是普通的类型，而是一个Trait。上述代码当中，Circle间接
的实现了Shape，但是，Circle的类型无法直接使用Shape的方法，只能通过智能指针的方
式，将Circle转换成Round的类型，再进行使用，如下：
\begin{code-block}{rust}
fn main() {
    let c: Box<dyn Round> = Box::new(Circle { radius: 4f64 });
    info!("{}", c.area());
}
\end{code-block}
如果再把这个例子改得复杂一些，让Circle和Sphere同时实现Round，则我们可以使用Round
指针计算2个不同类型数据的结果：
\begin{code-block}{rust}
trait Shape {
    fn area(&self) -> f64;
}
trait Round {
    fn calc(&self) -> f64;
}
struct Circle {
    radius: f64,
}
impl Round for Circle {
    fn calc(&self) -> f64 {
        PI * self.radius * self.radius
    }
}
struct Sphere {
    radius: f64,
}
impl Round for Sphere {
    fn calc(&self) -> f64 {
        4f64 * PI * self.radius * self.radius
    }
}
impl Shape for dyn Round {
    fn area(&self) -> f64 {
        self.calc()
    }
}
fn main() {
    let circle: Box<dyn Round> = Box::new(Circle { radius: 4f64 });
    info!("The Circle area is {}", circle.area());
    let sphere: Box<dyn Round> = Box::new(Sphere { radius: 4f64 });
    info!("The Sphere area is {}", sphere.area());
}
\end{code-block}

Trait不仅仅用于实现类型，约束类型，还可以用于为其他现有的数据类型添加方法/函数，
比如：
\begin{code-block}{rust}
impl Round for i32 {
    fn calc(&self) -> f64 {
        *self as f64
    }
}
fn main() {
    let i_struct = 4i32;
    i_struct.calc();
}
\end{code-block}
这种类型的函数/方法，则称之为扩展方法/函数。从上述例子当中，我们似乎可以使用Trait
对任意类型进行函数/方法的扩展，但是，这个是存在前提的：
\begin{itemize}
  \item impl和trait的声明/定义在同一个crate当中
  \item 或者，impl的实现需要和类型的声明在同一个crate当中
\end{itemize}
如果不满足上述条件，则容易出现bug和问题，也会违反Rust的规则。

Rust的Trait支持多种特性，自然也支持继承，但是注意，Rust的结构体和enum数据类型并不
存在继承的概念。Trait的继承方式如下：
\begin{code-block}{rust}
trait Base {}
trait Derived : Base {}
\end{code-block}
当一个结构体实现了上述的Derived这个Trait，则必须同样实现Base这个Trait，否则就会
出现语法错误：
\begin{code-block}{rust}
trait Base {}
trait Derived : Base {}
struct T;
impl Derived for T {}
impl Base for T {}
\end{code-block}

Rust的Trait不仅可以包括函数的定义，同样可以直接定义函数：
\begin{code-block}{rust}
trait Page {
    fn set_page(&self) {
        info!("Page Default: 1");
    }
}
trait PerPage {
    fn set_per_page(&self) {
        info!("Per Page Default: 1");
    }
}
struct Paginate {
    page: u32,
}
impl Page for Paginate {}
impl PerPage for Paginate {}
fn main() {
    let page = Paginate { page: 8 };
    page.set_page();
    page.set_per_page();
    page.set_skip_page();
}
\end{code-block}

甚至于，Trait可以直接给结构体提供更多的组合方法：
\begin{code-block}{rust}
trait PaginateMore: Page + PerPage {
    fn set_skip_page(&self) {
        info!("Skip the page");
    }
}
fn main() {
    ...
    page.set_skip_page();
}
\end{code-block}
结构体根本不用自行实现Trait PaginateMore，就可以直接使用该Trait当中的方法。

Trait不仅仅可以用于接口实现，在Rust当中，更重要的则是类型限定，限定某些数据只能
做某些事情。比如下方的代码：
\begin{code-block}{rust}
...
fn static_dispatch<T>(t: &T) where T: Bar {
    ...
}
fn dynamic_dispatch(t : &Bar) {
    ...
}
\end{code-block}
对于实现了Trait Bar的类型来说，上述2个函数，都可以被调用，但是，从语法上，static\_dispatch
由于使用了where，表示参数必须限定在Trait Bar类型，在编译时就能够确定；而dynamic\_dispatch
则从语法上表示，输入的参数必须是Bar的对象，即Trait Object。运行时，Trait Object会根据虚表
指针从虚表当中查出正确的指针，再进行动态调用，属于在运行时确定。

但是并不是每一个Trait都可以当着Trait Object使用，这个和类型大小是否确定有关系。每一个
Trait的隐藏类型参数Self默认限定为?Sized，?Sized trait包括了所有动态大小类型以及所有
可确定大小的类型。Rust当中大部分类型都是默认可确定大小的，即<T:Sized>。当trait对象
在运行期进行动态分发时，也必须确定大小，否则无法分配内存。只有同时满足下列条件的
trait，才可以当作Trait Object使用：
\begin{itemize}
  \item Trait的Self不能被限定为Sized
  \item Trait当中的所有方法都必须是对象安全的
\end{itemize}

而所谓的对象安全，则必须满足如下的条件\colorblock{之一}：
\begin{itemize}
  \item 当Trait的Self被限定为Sized时，方法受Self:Sized约束
  \item Trait的方法签名必须\colorblock{同时满足以下3点}
  \begin{enumerate}
    \item 不包含任何泛型参数（Self）
    \item 第一个参数必须为Self类型或可解引用为Self类型
    \item Self不能出现在除第一个参数之外的其他地方
  \end{enumerate}
  \item Trait当中不能包含关联常量
\end{itemize}

比如下面的代码，就属于标准的对象安全：
\begin{code-block}{rust}
trait Bar {
    fn bax(self, x: u32);
    fn bay(&self);
    fn baz(&mut self);
}
\end{code-block}
Trait Bar不受Sized限制，Trait的方法没有额外的Self类型参数，没有泛型参数，因此是安全的。
相对应的，不安全的Trait如下：
\begin{code-block}{rust}
// 对象不安全
trait Foo {
    fn bad<T>(&self, x:T);
    fn new() -> Self;
}
// 对象安全
trait Foo {
    fn bad<T>(&self, x: T);
    fn new() -> Self
    where
        Self: Sized;
}
\end{code-block}

当然，Sized约束也可以用于Trait定义当中。比如，自行实现一个类似any的Any Trait。
\begin{code-block}{rust}
use std::ops::Fn;
trait CustomAny {
    fn custom_any<F>(&self, f: F) -> bool
    where
        Self: Sized,
        F: Fn(u32) -> bool;
}
impl CustomAny for Vec<u32> {
    fn custom_any<F>(&self, f: F) -> bool
    where
        Self: Sized,
        F: Fn(u32) -> bool,
    {
        for &x in self {
            if f(x) {
                return true;
            }
        }
        false
    }
}
fn main() {
    let v: Vec<u32> = vec![1, 2, 3];
    info!("{}", v.iter().any(|&x| x == 3));
    info!("{}", v.custom_any(|x| x == 3));
}
\end{code-block}

Trait当中不仅可以包含函数和方法，同样可以包含变量和常量，即所谓的关联变量以及关联
常量。关联常量的使用稍微有些特殊，在Trait当中可以定义关联常量，但是，使用的时候，
却是通过Trait的实现对象来使用这些关联常量的：
\begin{code-block}{rust}
trait Colorize {
    // 定义关联常量
    const FG_RED: &'static str = "31";
    const BG_YELLOW: &'static str = "43";
    fn red(self) -> ColoredString;
    fn on_yellow(self) -> ColoredString;
}
impl Colorize for ColoredString {
    fn red(self) -> ColoredString {
        ColoredString {
            // 使用关联常量，如果是Colorize::FG_RED，则会提示错误
            fg_color: String::from(ColoredString::FG_RED),
            ..self
        }
    }
    fn on_yellow(self) -> ColoredString {
        ColoredString {
            bg_color: String::from(ColoredString::BG_YELLOW),
            ..self
        }
    }
}
\end{code-block}

Trait不仅仅可以实现泛型，泛型也不仅限于Trait和<T>，对于函数/方法，也可以使用在
泛型、生命周期以及Trait当中，比如，显式的指定闭包的生命周期：
\begin{code-block}{rust}
// 将函数作为泛型参数
struct Pick<F> {
    data: (u32, u32),
    func: F,
}
impl<F> Pick<F>
where
    // for<>只能用于标记生命周期
    F: for<'f> Fn(&'f (u32, u32)) -> &'f u32,
{
    fn call(&self) -> &u32 {
        (self.func)(&self.data)
    }
}

fn max(data: &(u32, u32)) -> &u32 {
    if data.0 > data.1 {
        return &data.0;
    }
    &data.1
}
fn main() {
    let pick = Pick {
        data: (32, 34),
        func: max,
    };
    info!("{}", pick.call());
}
\end{code-block}

\subsection{常见的设计模式}
建造者模式是Rust当中最常用的设计模式之一，其主旨思想在于将可变和不可变进行分离，
一种基本的示例如下：
\begin{code-block}{rust}
use std::f64::consts;
pub struct Circle {
    radius: f64,
}
pub struct CircleBuilder {
    radius: f64,
}
impl Circle {
    pub fn new() -> CircleBuilder {
        CircleBuilder { radius: 0.0 }
    }
    pub fn area(&self) -> f64 {
        self.radius * self.radius * consts::PI
    }
}
impl CircleBuilder {
    pub fn radius(&mut self, radius: f64) -> &mut CircleBuilder {
        self.radius = radius;
        self
    }
    pub fn build(&self) -> Circle {
        Circle {
            radius: self.radius,
        }
    }
}
\end{code-block}

\subsection{排序}
Rust的整数型数组和向量（Vector）的排序是相同的，可以使用相同的方式进行，即采用
sort以及sort\_unstable进行。其中，sort是稳定排序（即不重新排序相等的元素），
sort\_unstable是不稳定排序，\colorblock{但是通常情况下速度更快}，并且不会进行辅助内存的分配。
\begin{code-block}{rust}
let mut v = vec![2, 21, 12, 32, 12, 45, 90];
v.sort_unstable();
info!("The sorted vector is {:?}", v);
let mut array = [2, 23, 12, 12, 98, 100, 21];
array.sort_unstable();
info!("The sorted array is {:?}", array);
\end{code-block}
默认情况下，排序操作使用的是升序，但是可以通过定制，修改排序方式：
\begin{code-block}{rust}
let mut v = vec![2, 21, 12, 32, 12, 45, 90];
// 降序排列，可替换成v.sort_by
v.sort_unstable_by(|a, b| b.cmp(a));
info!("The sorted vector is {:?}", v);
let mut array = [2i32, -23, 12, 12, 98, -100, 21];
// 根据绝对值升序排列，可以根据其他关键字进行排序
array.sort_unstable_by_key(|k| k.abs());
info!("The sorted array is {:?}", array);
// 根据字符顺序排列，带有缓存cache，闭包函数通常只执行一次，比无缓存的快速
let mut xx = [-5i32, 4, 32, -3, 2];
xx.sort_by_cached_key(|k| k.to_string());
// 字符串排序
let mut array = ["lucifer", "titans", "asura", "garuda"];
array.sort_unstable_by_key(|item| item.to_string());
info!("The string array is {:?}", array);
let mut array = [
    "lucifer".to_string(),
    "titans".to_string(),
    "asura".to_string(),
    "garuda".to_string(),
];
// 可以转换成切片
// array[..].sort_unstable_by_key(|item| item.to_string());
// info!("The string array is {:?}", array);
array.sort_unstable_by_key(|item| item.to_string());
info!("The string array is {:?}", array);
\end{code-block}

浮点数的排序和最值操作，参见\colorunderlineref{float_sort}

除了基础数据类型可以进行排序，同样可以针对复合数据类型进行排序。在针对复合数据
类型排序时，需要实现\colorblock{Eq，PartialEq，Ord和PartialOrd}这几个trait：
\begin{code-block}{rust}
#[derive(Eq, PartialEq, Ord, PartialOrd, Debug)]
struct Student {
    name: String,
    age: u8,
}
fn main() {
    let mut stu = [
        Student {
            name: "lucifer".to_string(),
            age: 18,
        },
        Student {
            name: "garuda".to_string(),
            age: 36,
        },
    ];
    // 按照自然序列（name）
    stu.sort();
    info!("The students is {:?}", stu);
    // 根据年龄
    stu.sort_unstable_by(|first, second| first.age.cmp(&second.age));
    info!("The students is {:?}", stu);
}
\end{code-block}

\subsection{压缩与解压}
Rust可以实现文件的压缩与解压，在Linux环境下，通常使用\href{https://github.com/alexcrichton/tar-rs}{tar}（归档）
和\href{https://github.com/rust-lang/flate2-rs}{flate2}（压缩解压），比如Linux下常见的tar.gz文件的处理：
\begin{code-block}{rust}
use flate2::read::GzDecoder;
use flate2::write::GzEncoder;
use flate2::Compression;
use tar::Archive;

let path = "/root/py3.tar.gz";
let targz = match File::open(path) {
    Ok(file) => file,
    Err(error) => {
        crit!("Failed to open the file {}: {}", path, error.to_string());
    }
};
// gz文件的解码器
let tar = GzDecoder::new(targz);
// tar的管理器
let mut archive = Archive::new(tar);
// 将tar.gz解压
match archive.unpack(".") {
    Ok(_) => info!("Sucess to unpack the tar.gz file"),
    Err(error) => {
        crit!("Failed to unpark the tar.gz file: {:?}", error);
    }
}
// 创建tar.gz文件
let targz = match File::create("log.tar.gz") {
    Ok(file) => file,
    Err(error) => {
        crit!(
            "Failed to create the log.tar.gz file : {}",
            error.to_string()
        );
    }
};
// 创建gz文件的编码器，压缩算法使用默认
let encoder = GzEncoder::new(targz, Compression::default());
let mut tarfile = tar::Builder::new(encoder);
// 将文件添加到tar.gz文件当中
match tarfile.append_dir_all("log", "/var/log") {
    Ok(_) => info!("log.tar.gz created sucessful"),
    Err(error) => {
        fs::remove_file("log.tar.gz").unwrap_or_else(|why| {
            error!("Cannot remove the log.tar.gz: {:?}", why.to_string())
        });
        crit!("Failed to park the tar.gz file: {:?}", error);
    }
}
\end{code-block}

当然，归档和压缩也可以单独使用：
\begin{code-block}{rust}
use flate2::read::GzDecoder;
use flate2::write::GzEncoder;
use flate2::Compression;
use tar::Archive;
let tarf = match File::create("log.tar") {
    Ok(file) => file,
    Err(error) => {
        crit!("Failed to create the log.tar file : {}", error.to_string());
    }
};
// 注意和gz文件不一样，只是归档，则不需要创建编码器
let mut tar_file = tar::Builder::new(tarf);
match tar_file.append_dir_all("log", "/var/log") {
    Ok(_) => info!("log.tar created sucessful"),
    Err(error) => {
        fs::remove_file("log.tar")
            .unwrap_or_else(|why| error!("Cannot remove the log.tar: {:?}", why.to_string()));
        crit!("Failed to park the tar.gz file: {:?}", error);
    }
}
let path = "/root/log.tar";
let tarball = match File::open(path) {
    Ok(file) => file,
    Err(error) => {
        crit!("Failed to open the file {}: {}", path, error.to_string());
    }
};
// 同样的，解压tar文件，不需要创建解码器
let mut archive = Archive::new(tarball);
match archive.unpack(".") {
    Ok(_) => info!("Sucess to unpack the tar file"),
    Err(error) => {
        crit!("Failed to unpark the tar file: {:?}", error);
    }
}
\end{code-block}
