\chapter{Linux Kernel}
\section{Kernel编译}
\subsection{安装必要的软件包}
\begin{code-block}{bash}
yum install ncurses-devel bison flex elfutils-libelf-devel bc openssl-devel -y
\end{code-block}

\subsection{设置编译选项}
\begin{code-block}{bash}
make menuconfig
\end{code-block}

\subsection{编译内核}
\begin{code-block}{bash}
make
# 如果是在多核服务器上进行编译，可以增加编译参数，提高编译速度
# make -j32 #32表示cpu的核数
\end{code-block}

\subsection{安装内核模块}
\begin{code-block}{bash}
make modules_install
\end{code-block}

安装内核模块的操作，会将编译生成的内核模块复制到/lib/modules/\{kernel-version\}/下。

\subsection{安装内核}
\begin{code-block}{bash}
make install
\end{code-block}

安装内核的过程主要完成了以下的工作：将编译内核时生成的内核镜像bzImage拷贝到/boot目录下，
并将这个镜像命名为vmlinuz-\{kernel-version\}。如果使用x86的cpu，则该镜像位于arch/x86/boot/目录下；
将目录下的System.map拷贝到/boot/目录下，重新命名为System.map-\{kernel-version\}，该文件中存放了内核的符号表。
将目录下的.config拷贝到/boot/目录下，重新命名为config-\{kernel-version\}

\subsection{创建initrd.img文件}
\begin{code-block}{bash}
mkinitrd  /boot/initrd.img-{kernel-version} {kernel-version}
\end{code-block}

initrd.img即为初始化的ramdisk文件，它是一个镜像文件。

\subsection{修改grub}
\begin{code-block}{bash}
grub2-mkconfig -o /boot/grub2/grub.cfg
\end{code-block}

修改完成之后，重启服务器，即可发现新编译的内核，如下图\colorunderlineref{fig:new-kernel}
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.2]{new-kernel.png}
  %\caption{新编译内核 \protect\footnotemark}
  \caption{新编译内核}
  \label{fig:new-kernel}
\end{figure}

\section{编写自己的内核模块}
在编写自己的内核模块的时候，一般需要2个文件：一个c代码文件，包含了自己的内核模块
内在逻辑实现；一个makefile文件，用于编译自己的内核模块。以最简单的hello world为例。
C代码如下：
\begin{code-block}{c}
// hello_kernel.c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>

// 必须，标明模块的许可声明
MODULE_LICENSE("GPL");

// 模块的加载函数，即加载该模块之后，执行的操作
static int hello_init(void)
{
    printk(KERN_ALERT "hello,I am zhangjl\n");
    return 0;
}

// 模块的卸载函数，即该模块卸载之后，应当执行什么操作
static void hello_exit(void)
{
    printk(KERN_ALERT "goodbye,kernel\n");
}

// 注册模块对应的操作
module_init(hello_init);
module_exit(hello_exit);

// 可选，表示该模块的作者和其他信息
MODULE_AUTHOR("zhangjl");
MODULE_DESCRIPTION("This is a simple example!\n");
MODULE_ALIAS("A simplest example");
\end{code-block}

Makefile文件内容如下：
\begin{code-block}{make}
obj-m += hello_kernel.o
#generate the path
CURRENT_PATH:=$(shell pwd)
#the current kernel version number
LINUX_KERNEL:=$(shell uname -r)
#the absolute path
LINUX_KERNEL_PATH:=/usr/src/kernels/$(LINUX_KERNEL)
#complie object
all:
        make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules
#clean
clean:
        make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean
\end{code-block}

然后执行make。执行完毕之后，会在当前目录生成hello\_kernel.ko，这个文件即是我们
所需要的内核模块。执行insmod hello\_kernel.ko，在/var/log/message当中，会发现有hello的输出，执行
rmmod hello\_kernel，在/var/log/message当中，会发现有goodbyd的输出。整个简单的模块
就算完成了。另外，printk函数带缓冲，如果格式化是不添加换行符，则printk所打印的日志并不会
立刻打印出来，有可能会等到模块退出，或者遇到另外一个换行符才会输出。

需要注意这里的license问题。如果license存在问题，或者没有license，会导致编译的内核模块
被加载时，会提示被污染。而合法可用的license如下：
\begin{itemize}
  \item GPL-1.0
  \item ISC
  \item Linux-OpenIB
  \item X11
  \item Apache-2.0
  \item CDDL-1.0
  \item MPL-1.1
  \item GCC-exception-2.0
  \item BSD-2-Clause
  \item Linux-syscall-note
  \item BSD-3-Clause
  \item BSD-3-Clause-Clear
  \item GPL-2.0
  \item LGPL-2.0
  \item LGPL-2.1
  \item MIT
  \item Proprietary
\end{itemize}

其中Proprietary表示私有协议。

\section{导出内核函数}
\begin{code-block}{c}
#include <linux/init.h>
#include <linux/module.h>

#define DRIVER_VERSION  "1.0.0"
#define DRIVER_AUTHOR   "zhangjl luoyan_cn@outlook.com"
#define DRIVER_DESC     "export for example"
#define DRIVER_LICENSE  "Apache-2.0"

int add_int(int a, int b)
{
        return a+b;
}

int sub_int(int a, int b)
{
        return a-b;
}

MODULE_VERSION(DRIVER_VERSION);
MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_LICENSE(DRIVER_LICENSE);

EXPORT_SYMBOL(add_int); // 导出函数
EXPORT_SYMBOL(sub_int); // 导出函数
\end{code-block}

该模块进行编译之后，通过insmod加载到内核空间之后，可以通过grep指令进行查询。
\begin{code-block}{bash}
grep add_int /proc/kallsyms
\end{code-block}
一切正常的话，结果大致如下图\colorunderlineref{fig:export}所示：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{export.png}
  \caption{内核函数导出}
  \label{fig:export}
\end{figure}

在其他的内核模块当中使用导出的函数，则需要修改相关的定义即可，大致的代码如下：
\begin{code-block}{c}
#include <linux/module.h>
...
extern int add_int(int, int);
extern int sub_int(int, int);
...
static __init int hello_init(void)
{
    int result = 0;
    result = add_int(4, 5);
...
}
\end{code-block}

\section{内核模块参数支持}
\begin{code-block}{c}
#include <linux/module.h>
#include <linux/init.h>

#define DRIVER_VERSION  "1.0.0"
#define DRIVER_AUTHOR   "zhangjl luoyan_cn@outlook.com"
#define DRIVER_DESC     "Params Modules for example"
#define DRIVER_LICENSE  "Apache-2.0"

static char * book_name = "Dive into Linux Kernel";
static int num = 400;

static __init int params_init(void)
{
        printk(KERN_INFO "This is my params modules\n");
        printk(KERN_INFO "Book name is %s\n", book_name);
        printk(KERN_INFO "Book num is %d\n", num);
        return 0;
}

static __exit void params_exit(void)
{
        printk(KERN_INFO "Goodbye, my kernel module\n");
}

module_param(num, int, S_IRUGO); // 表示内核加载时可以接收参数，参数类型为int
module_param(book_name, charp, S_IRUGO); // 表示内核加载的参数为chapr，即char*类型

MODULE_VERSION(DRIVER_VERSION);
MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_LICENSE(DRIVER_LICENSE);

module_init(params_init);
module_exit(params_exit);
\end{code-block}

内核模块编译完成之后，可以使用modinfo进行查看，比如modinfo params.ko，其结果大致
如下图\colorunderlineref{fig:params}所示：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{params.png}
  \caption{内核模块函数参数}
  \label{fig:params}
\end{figure}

使用的时候，可以直接在insmod之后添加参数：
\begin{code-block}{bash}
insmod params.ko book_name=zhangjl num=100
# 传递包含空格的字符串
insmod params.ko book_name='"zhangjl and his family"' num=100
\end{code-block}
内核模块加载之后，查看日志，会有如下图\colorunderlineref{fig:params_out}的输出：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{params_out.png}
  \caption{内核模块函数参数}
  \label{fig:params_out}
\end{figure}

\section{内核模块与版本号}
每一个版本的内核都有自己的版本号描述，而这些版本号描述，会直接影响内核模块的工作。
而内核的版本号是根据git信息自动生成的，具体是通过内核代码当中的scripts/setlocalversion
这个脚本生成的。执行该脚本，其输出如下图\colorunderlineref{fig:version}所示：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{version.png}
  \caption{获取内核代码版本信息}
  \label{fig:version}
\end{figure}
其中，上述信息的最后部分，刨去开头的g这个字母，剩下的部分，则表示对应的git commit id。
除此之外，内核的版本信息，在进行内核代码编译的时候，也会使用这个脚本进行生成，生成的版本
信息id会保存在内核代码的include/generated/utsrelease.h和include/config/kernel.release文件当中，
在编译内核模块时，如果需要修改这个版本信息，只需要修改include/generated/utsrelease.h当中的
信息即可。

\section{代码判断内核版本号和系统架构}
不同的内核版本，头文件路径可能不同，结构体定义可能不同，函数或者宏定义也可能不同。因此，针对
不同的版本，相应的内核驱动代码通常需要进行适配。而这个适配工作可以直接在代码当中自动完成。如下
代码所示：
\begin{code-block}{c}
#include <linux/version.h>

// 如果内核代码版本小于5.0.0版本
#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 0, 0)
#include <linux/device.h>
#endif

...
#if defined(__arm__)
        printk(KERN_INFO
                "The count of user namespace write is %d\n", count);
#else
        printk(KERN_INFO
                "The count of user namespace write is %ld\n", count);
#endif
\end{code-block}

\section{字符设备驱动开发}
字符设备的注册，需要在init函数当中调用register\_chrdev函数，该函数有几个参数：
\begin{itemize}
    \item \mint{c}|unsigned int major| 表示字符设备的主设备号。
    \item \mint{c}|const char *name|表示字符设备的名称
    \item \mint{c}|const struct file_operations *fops| 表示字符设备的对应操作函数结构体
\end{itemize}

在Linux当中，每个设备都对应了一个设备号，而设备号分为主设备号与次设备号。主设备号
表示某一个具体的驱动，次设备号表示使用该驱动的各个设备。表示设备号的数据结构是dev\_t，
其定义在include/linux/types.h当中，不过实际上，dev\_t就是unsigned int的这么一个无符号的32位
整型数据。而dev\_t的高12位为主设备号，低20位为次设备号，因此，主设备号的取值范围为1-4095（2的12次方）。
而关于设备号的处理，在include/linux/kdev\_t.h当中提供了几个宏定义：

\begin{code-block}{c}
#define MINORBITS     20     // 表示次设备号位数
#define MINORMASK     ((1U << MINORBITS) - 1) // 次设备号掩码
#define MAJOR(dev)    ((unsigned int) ((dev) >> MINORBITS)) // 从dev_t当中获取主设备号
#define MINOR(dev)    ((unsigned int) ((dev) & MINORMASK))  // 从dev_t当中获取次设备号
#define MKDEV(ma,mi)  (((ma) << MINORBITS) | (mi)) // 使用主设备号与次设备号组合成dev_t的设备号
\end{code-block}
在使用的时候，通常无需直接导入kdev\_t.h，只需要使用include/linux/fs.h即可。

默认情况下，使用register\_chrdev会注册字符设备，但是不会创建对应的设备文件（/dev），因此，需要
手动的创建。手动创建字符设备的操作如下：
\begin{code-block}{bash}
mknod /dev/starter c 200 0
\end{code-block}
其中，c表示字符设备，200表示对应设备的主设备号，0表示对应设备的次设备号。

而结构体file\_operations包含了很多的文件操作函数，这些操作函数与用户空间的特定的操作函数
是一一对应的。
\begin{itemize}
    \item open对应open函数（fcntl.h）
    \item release对应close函数（unistd.h）
    \item read对应read函数（unistd.h）
    \item write对应write函数（unistd.h）
\end{itemize}

除了这些常用的函数之外，内核当中的file\_operations包含的函数操作以及相关含义如下：
\begin{itemize}
    \item \mint[linenos=false,breaklines=true,breakanywhere,breaksymbolleft=,breakanywheresymbolpre=,]{c}|loff_t (*llseek) (struct file *, loff_t, int)|llseek方法用作改变文件中的当前读/写位置,
        并且新位置作为(正的)返回值.  loff\_t 参数是一个“long offset”,
        并且就算在32位平台上也至少64位宽. 错误由一个负返回值指示.
        如果这个函数指针是NULL,seek调用会以潜在地无法预知的方式修改file结构中的位置计数器
    \item \mint[linenos=false,breaklines=true,breakanywhere,breaksymbolleft=,breakanywheresymbolpre=,]{c}|unsigned int (*poll) (struct file *, struct poll_table_struct *)|poll方法是3个系统调用的后端:
        poll, epoll, 和 select, 都用作查询对一个或多个文件描述符的读或写是否会阻塞。
        poll方法应当返回一个位掩码指示是否非阻塞的读或写是可能的, 并且, 可能地,
        提供给内核信息用来使调用进程睡眠直到 I/O 变为可能。如果一个驱动的poll方法为NULL,
        设备假定为不阻塞地可读可写。
    \item \mint[linenos=false,breaklines=true,breakanywhere,breaksymbolleft=,breakanywheresymbolpre=,]{c}|int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long)|ioctl系统调用提供了
        发出设备特定命令的方法(例如格式化软盘的一个磁道, 这不是读也不是写)。
        另外, 几个ioctl命令被内核识别而不必引用fops表。如果设备不提供ioctl方法,
        对于任何未事先定义的请求(-ENOTTY, 设备无这样的ioctl), 系统调用返回一个错误。
    \item \mint[linenos=false,breaklines=true,breakanywhere,breaksymbolleft=,breakanywheresymbolpre=,]{c}|int (*mmap) (struct file *, struct vm_area_struct *)|mmap用来请求将设备内存映射
        到进程的地址空间. 如果这个方法是NULL, mmap系统调用返回-ENODEV。
    \item \mint[linenos=false,breaklines=true,breakanywhere,breaksymbolleft=,breakanywheresymbolpre=,]{c}|int (*flush) (struct file *)|flush操作在进程关闭它的设备文件描述符的拷贝时调用;
        它应当执行(并且等待)设备的任何未完成的操作。这个必须不要和用户查询请求的fsync操作混淆了。
        当前, flush 在很少驱动中使用。
    \item \mint[linenos=false,breaklines=true,breakanywhere,breaksymbolleft=,breakanywheresymbolpre=,]{c}|int (*fsync) (struct file *, struct dentry *, int)|这个方法是fsync系统调用的后端,
        用户调用来刷新任何挂着的数据。如果这个指针是NULL, 系统调用返回-EINVAL。
    \item \mint[linenos=false,breaklines=true,breakanywhere,breaksymbolleft=,breakanywheresymbolpre=,]{c}|int (*fasync) (int, struct file *, int)|这个操作用来通知设备它的FASYNC标志的改变
    \item \mint[linenos=false,breaklines=true,breakanywhere,breaksymbolleft=,breakanywheresymbolpre=,]{c}|int (*lock) (struct file *, int, struct file_lock *)|lock 方法用来实现文件加锁;
        加锁对常规文件是必不可少的特性, 但是设备驱动几乎从不实现它。
\end{itemize}

一个简单的字符驱动的框架大致如下：
\begin{code-block}{c}
#include <linux/fs.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/module.h>

#define MARJOR 200
#define DEV_NAME "starter"

static int open_starter_chrdev(struct inode *inodep, struct file *filep)
{
        printk(KERN_INFO "Open the starter char dev \n");
        return 0;
}

static int release_starter_chrdev(struct inode *inodep, struct file *filp)
{
        printk(KERN_INFO "Close the starter char dev \n");
        return 0;
}

static ssize_t read_starter_chrdev(struct file *filp,
                char __user * buffer, size_t count, loff_t *ppos)
{
        printk(KERN_INFO "Read the starter char dev \n");
        return 0;
}

static ssize_t write_starter_chrdev(struct file *filp,
                const char __user *buffer, size_t count, loff_t *ppos)
{
        printk(KERN_INFO "Write the starter char dev \n");
        return 0;
}

static struct file_operations starter_fops = {
        .owner = THIS_MODULE,
        .open = open_starter_chrdev,
        .release = release_starter_chrdev,
        .read = read_starter_chrdev,
        .write = write_starter_chrdev,
};

static int __init starter_init(void)
{
        int result = 0;
        result = register_chrdev(MARJOR, DEV_NAME, &starter_fops);
        if (0 > result) {
                printk(KERN_ERR
                        "Failed to register the starter char device\n");
                return result;
        }
        printk(KERN_INFO
                "This is a starter module for char dev init function\n");
        return 0;
}

static void __exit starter_exit(void)
{
        printk(KERN_INFO
                "This is a starter module for char dev exit function\n");
        unregister_chrdev(MARJOR, DEV_NAME);
}

MODULE_LICENSE("Apache-2.0");
MODULE_AUTHOR("zhangjl");
MODULE_DESCRIPTION("This is a simple example!\n");
MODULE_ALIAS("A simplest example");

module_init(starter_init);
module_exit(starter_exit);
\end{code-block}

\section{驱动的读写操作函数}
在Linux驱动的操作函数当中，read/write是比较常用的。其中内核驱动的read/write函数接口定义如下：
\begin{code-block}{c}
ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
\end{code-block}
read函数，通常的功能在于，从内核空间读取数据到用户空间；而write则反过来，从用户
空间写数据到内核空间。常见的read/write函数的实现大致如下：
\begin{code-block}{c}
// linux/uaccess.h copy_to_user, copy_from_user

/*
*** buffer：用户空间缓冲区，在内核空间当中，无法直接访问，不能进行printk
*** count：用户空间读取的缓冲区大小
*** ppos：偏移地址
*/
static ssize_t read_starter_chrdev(struct file *filp,
        char __user * user_buffer, size_t count, loff_t *ppos)
{
        int ret = 0;
        struct chrdev * char_device = (struct chrdev*)filp->private_data;
#if defined(__arm__)
        printk(KERN_INFO "The count of user"
                        " namespace requested is %d\n", count);
#else
        printk(KERN_INFO "The count of user"
                        " namespace requested is %ld\n", count);
#endif
        // 偏移量超过了最大的长度
        if (*ppos > BUFFER_LEN) {
                return count ? -ENXIO : 0;
        }
        // 偏移量超过了剩余长度
        if (count > (BUFFER_LEN - *ppos)) {
                count = BUFFER_LEN - *ppos;
        }
        // *ppos表示偏移量的地址
        if ((ret = copy_to_user(
                user_buffer, (void *)(char_device->buffer + *ppos), count))) {
                printk(KERN_ERR "Faichrdev to read data from kernel\n");
                return -EFAULT;
        }
        *ppos += count; // 必须进行该操作，否则会出现不可预知的问题
#if defined(__arm__)
        printk(KERN_INFO "The count of copy_to_user is %d\n", count);
#else
        printk(KERN_INFO "The count of copy_to_user is %ld\n", count);
#endif
        return count;
}

/*
*** buffer：用户空间缓冲区，在内核空间当中，无法直接访问，不能进行printk
*** count：用户空间写入的缓冲区大小
*** ppos：偏移地址
*/
static ssize_t write_starter_chrdev(struct file *filp,
        const char __user * user_buffer, size_t count, loff_t *ppos)
{
        int ret = 0;
        struct chrdev * char_device = (struct chrdev*)filp->private_data;
#if defined(__arm__)
        printk(KERN_INFO
                "The count of user namespace write is %d\n", count);
#else
        printk(KERN_INFO
                "The count of user namespace write is %ld\n", count);
#endif
        if (count >= BUFFER_LEN) {
                return count ? -ENXIO : 0;
        }
        if (count > (BUFFER_LEN - *ppos)) {
                count = BUFFER_LEN - *ppos;
        }

        if ((ret = copy_from_user(char_device->buffer+*ppos,
                                user_buffer, count))) {
                printk(KERN_ERR "Faichrdev write to char device\n");
                return -EFAULT;
        }

        *ppos += count; // 必须进行该操作，否则会出现不可预知的问题
        printk(KERN_INFO "Write to the chrdev"
                " char dev with content %s\n",                                                                                                                               char_device->buffer);
        return count;
}
\end{code-block}

需要注意，用户空间缓冲区，在内核空间是不能直接进行操作的，必须通过copy\_to\_user和copy\_from\_user
进行，否则会导致操作系统直接卡住。除此之外，需要特别注意，read/write函数的返回值，如果一切运行正常，
返回值应当为操作的数量（即count），不能随意返回0，否则，在使用cat/echo等命令对字符设备文件进行操作时，
会导致操作系统卡住（使用代码进行读写的方式运行正常）。

另外，在上述的代码当中，首次出现了一个-EFAULT的标记，这个表示Linux的内核错误代码。在Linux内核代码当中，
存在一系列关于各种错误的定义，这些错误的定义全部都在include/uapi/asm-generic/errno-base.h当中，而典型的
Linux错误代码包括如下的内容：
\begin{code-block}{c}
#define EPERM   1  /* Operation not permitted */
#define ENOENT  2  /* No such file or directory */
#define ESRCH   3  /* No such process */
#define EINTR   4  /* Interrupted system call */
#define EIO     5  /* I/O error */
#define ENXIO   6  /* No such device or address */
#define E2BIG   7  /* Argument list too long */
#define ENOEXEC 8  /* Exec format error */
#define EBADF   9  /* Bad file number */
#define ECHILD  10 /* No child processes */
#define EAGAIN  11 /* Try again */
#define ENOMEM  12 /* Out of memory */
#define EACCES  13 /* Permission denied */
#define EFAULT  14 /* Bad address */
#define ENOTBLK 15 /* Block device required */
#define EBUSY   16 /* Device or resource busy */
#define EEXIST  17 /* File exists */
#define EXDEV   18 /* Cross-device link */
#define ENODEV  19 /* No such device */
#define ENOTDIR 20 /* Not a directory */
#define EISDIR  21 /* Is a directory */
#define EINVAL  22 /* Invalid argument */
#define ENFILE  23 /* File table overflow */
#define EMFILE  24 /* Too many open files */
#define ENOTTY  25 /* Not a typewriter */
#define ETXTBSY 26 /* Text file busy */
#define EFBIG   27 /* File too large */
#define ENOSPC  28 /* No space left on device */
#define ESPIPE  29 /* Illegal seek */
#define EROFS   30 /* Read-only file system */
#define EMLINK  31 /* Too many links */
#define EPIPE   32 /* Broken pipe */
#define EDOM    33 /* Math argument out of domain of func */
#define ERANGE  34 /* Math result not representable */
\end{code-block}

\section{设备号的动态分配}
在上述操作当中，我们必须手动的指定设备号，并且手动的创建设备节点，才可以对其进行
操作和访问。但是，Linux提供了一套设备驱动的框架，支持进行自动的设备号分配，以及
设备节点的自动创建。

自动申请设备号采用下列函数进行操作：
\begin{code-block}{c}
/**
* dev 表示设备号，
* baseminor 表示基础的次设备号，即从多少开始进行次设备号的分配
* count 表示申请多少个
* name 表示设备的名称
*/
int alloc_chrdev_region(dev_t *dev, unsigned baseminor,
    unsigned count, const char *name);

// 其使用方式大致如下：

ret = alloc_chrdev_region(&devid, 0, MAX_COUNT, "device_name");
// 获取主设备号
major = MAJOR(devid);
minor = MINOR(devid);
\end{code-block}

如果指定了主设备号，但是自动分配次设备号，可以采用下面的类似代码进行：
\begin{code-block}{c}
int register_chrdev_region(dev_t from, unsigned count, const char *name);

// 其使用方式大致如下：
devid = MKDEV(major,0);
ret = register_chrdev_region(devid, MAX_COUNT, "device_name");
\end{code-block}

相应的，卸载设备则应该使用对应的函数：
\begin{code-block}{c}
void unregister_chrdev_region(dev_t from, unsigned count)
\end{code-block}

\section{字符设备的注册}
虽然可以使用register\_chrdev进行字符设备的注册，但是，很多时候，我们通常采用的是
更为现代的方式和函数。新的字符设备的注册，需要使用到一个特殊的结构体——cdev：
\begin{code-block}{c}
// linux/cdev.h
struct cdev {
        struct kobject kobj;
        struct module *owner;
        const struct file_operations *ops;
        struct list_head list;
        dev_t dev;
        unsigned int count;
} __randomize_layout;
\end{code-block}
然后，使用cdev\_init函数对字符设备进行注册，随后使用cdev\_add函数将字符设备添加到
Linux操作系统当中。基本的操作大致如下，定义一个设备结构体，包含上述的cdev结构体，并且
包含主设备号，次设备号以及本身的设备号dev\_id：
\begin{code-block}{c}
struct devframework {
        dev_t dev_id;
        unsigned int major;
        unsigned int minor;
        struct cdev frame_cdev;
};

static struct devframework item;

static struct file_operations devframework_fops = {
        .owner = THIS_MODULE,
        .open = open_devframework_chrdev,
        .release = release_devframework_chrdev,
        .read = read_devframework_chrdev,
        .write = write_devframework_chrdev,
};

static int __init devframework_init(void)
{
        int result = 0;
        // 从Linux系统当中申请设备号
        result = alloc_chrdev_region(&item.dev_id, 0, 1, DEV_NAME);
        if (result) {
                printk(KERN_ERR
                        "Faild devframework to register"
                        " the devframework char device\n");
                return -EFAULT;
        }

        // 获取主设备号与次设备号
        item.major = MAJOR(item.dev_id);
        item.minor = MINOR(item.dev_id);
        item.frame_cdev.owner = THIS_MODULE;
        // 初始化设备，进行注册，包含了设备的文件操作函数
        cdev_init(&item.frame_cdev, &devframework_fops);
        // 添加设备到操作系统当中
        if ((result = cdev_add(&item.frame_cdev, item.dev_id, 1))){
                printk(KERN_ERR "Faild to add devframework"
                                " into Linux system\n");
                return -ENODEV;
        }
        printk(KERN_INFO
                "This is a devframework module"
                " for char dev init function,"
                " and major is %d, minor is %d\n",
                item.major, item.minor);
        return result;
}

static void __exit devframework_exit(void)
{
        printk(KERN_INFO
                "This is a devframework module"
                " for char dev exit function\n");
        // 从操作系统当中卸载设备
        cdev_del(&item.frame_cdev);
        // 回收注册的设备号
        unregister_chrdev_region(item.dev_id, 1);
}
\end{code-block}

\section{自动创建设备文件}
之前创建设备采用的是mknod的方式（即devfs），属于静态创建的方式。从Linux2.6之后，
采用了udev的方式，进行设备的创建。而udev的方式，直接可以管理/dev下的设备文件，并且支持
热插拔方式，因此，得到极大的发展。自动创建设备文件，通常采用函数device\_create完成。
将上述的内容的综合到一起，得到一个比较完整的字符驱动（以框架的形式运行），其代码大致如下：
\begin{code-block}{c}
#include <linux/version.h>
#include <linux/cdev.h>
#include <linux/fs.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/uaccess.h>

#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 0, 0)
#include <linux/device.h>
#endif

#define DEV_NAME "chrdev"
#define BUFFER_LEN 1024

// 定义设备结构体
// 定义设备结构体
struct chrdev {
        dev_t          dev_id;  // 设备id
        unsigned int   major;   // 主设备号
        unsigned int   minor;   // 次设备号
        struct device  *device; // device结构体指针，用于创建对应的设备文件
        struct class   *class;  // class结构体指针，用于创建对应的设备类型
        struct cdev    *cdev;   // cdev结构体指针，用于注册字符设备
        char           buffer[BUFFER_LEN];
};

static struct chrdev char_device;
// 默认的主设备号为0
static unsigned int major = 0;
// 添加内核模块的参数支持，支持通过参数传递major的数值
module_param(major, uint, S_IRUGO)

static int open_chrdev(struct inode *inodep, struct file *filp)
{
        // 设置文件的私有变量，后续在驱动的其他操作当中，可以直接
        // 使用filp指针，而无需操作全局的char_device变量
        filp->private_data = &char_device;
        printk(KERN_INFO "Open the char dev named chrdev\n");
        return 0;
}

static int release_chrdev(struct inode *inodep, struct file *filp)
{
        // 从文件的私有变量当中提取设备结构体
        struct chrdev *char_device = (struct chrdev*)filp->private_data;
        printk(KERN_INFO "Close the chrdev char dev \n");
        return 0;
}

static ssize_t read_chrdev(struct file *filp,
        char __user *user_buffer, size_t count, loff_t *ppos)
{
        int ret = 0;
        struct chrdev *char_device = (struct chrdev*)filp->private_data;
#if defined(__arm__)
        printk(KERN_INFO "The count of user"
                " namespace requested is %d\n", count);
#else
        printk(KERN_INFO "The count of user"
                " namespace requested is %ld\n", count);
#endif
        if (*ppos > BUFFER_LEN) {
                return count ? -ENXIO : 0;
        }
        if (count > (BUFFER_LEN - *ppos)) {
                count = BUFFER_LEN - *ppos;
        }
        if ((ret = copy_to_user(user_buffer,
                (void *)(char_device->buffer), count))) {
                printk(KERN_ERR "Faichrdev to read data from kernel\n");
                return -EFAULT;
        }
        *ppos += count;
#if defined(__arm__)
        printk(KERN_INFO "The count of copy_to_user is %d\n", count);
#else
        printk(KERN_INFO "The count of copy_to_user is %ld\n", count);
#endif
        return count;
}

static ssize_t write_chrdev(struct file *filp,
        const char __user *user_buffer, size_t count, loff_t *ppos)
{
        int ret = 0;
        struct chrdev *char_device = (struct chrdev*)filp->private_data;
#if defined(__arm__)
        printk(KERN_INFO
                "The count of user namespace write is %d\n", count);
#else
        printk(KERN_INFO
                "The count of user namespace write is %ld\n", count);
#endif
        if (count >= BUFFER_LEN) {
                return count ? -ENXIO : 0;
        }

        if ((ret = copy_from_user(
                char_device->buffer+*ppos, user_buffer, count))) {
                printk(KERN_ERR "Faichrdev write to char device\n");
                return -EFAULT;
        }

        *ppos += count;
        printk(KERN_INFO "Write to the chrdev"
                " char dev with content %s\n", char_device->buffer);
        return count;
}

static struct file_operations chrdev_fops = {
        .owner   = THIS_MODULE,
        .open    = open_chrdev,
        .release = release_chrdev,
        .read    = read_chrdev,
        .write   = write_chrdev,
};

static int __init chrdev_init(void)
{
        int result = 0;
        if (major > 0) {
                // 根据insmod xxx.ko major=yyy的参数，得到major
                // 然后生成字符设备的设备号
                char_device.dev_id = MKDEV(major, 0);
                // 注册设备的设备号到操作系统
                result = register_chrdev_region(
                        char_device.dev_id, 1, DEV_NAME);
        } else {
                // 申请设备号，0表示次设备号的起始编号，1表示设备的数量
                result = alloc_chrdev_region(
                        &char_device.dev_id, 0, 1, DEV_NAME);
        }
        if (result) {
                printk(KERN_ERR
                        "Faild chrdev to register"
                        " the chrdev char device\n");
                result = -EFAULT;
                goto dev_id_fail;
        }

        char_device.cdev = cdev_alloc();
        if (!char_device.cdev) {
                printk(KERN_ERR "Faild to alloc cdev struct \n");
                result = -EFAULT;
                goto alloc_cdev_fail;
        }

        // 获取主设备号
        char_device.major = MAJOR(char_device.dev_id);
        // 获取次设备号
        char_device.minor = MINOR(char_device.dev_id);
        char_device.cdev->owner = THIS_MODULE;

        // 初始化字符设备，包含字符设备的操作函数
        cdev_init(char_device.cdev, &chrdev_fops);

        // 添加字符设备到操作系统，1表示添加的数量
        if ((result = cdev_add(char_device.cdev, char_device.dev_id, 1))) {
                printk(KERN_ERR "Faild to add chrdev"
                                " into Linux system\n");
                result = -EFAULT;
                goto dev_add_fail;
        }

        // 创建字符设备类型
        char_device.class = class_create(THIS_MODULE, DEV_NAME);
        if(IS_ERR(char_device.class)){
                result = PTR_ERR(char_device.class);
                goto dev_class_fail;
        }

        // 创建字符设备文件，即/dev/下的文件，device_create的4个参数
        // 第一个表示设备类型
        // 第二个表示设备的父设备
        // 第三个表示设备号
        // 第四个表示设备数据
        // 第五个为可变参数，即可以是多个，表示设备的名称
        char_device.device = device_create(char_device.class, NULL,
                char_device.dev_id, NULL, DEV_NAME);
        if (IS_ERR(char_device.device)) {
                result = PTR_ERR(char_device.device);
                goto dev_device_fail;
        }

        memset(char_device.buffer, 0, BUFFER_LEN);

        printk(KERN_INFO "This is a chrdev module"
                " for char dev init function,"
                " and major is %d, minor is %d\n",
                char_device.major, char_device.minor);
        return result;

dev_device_fail:
        class_destroy(char_device.class);
dev_class_fail:
        cdev_del(char_device.cdev);
dev_add_fail:
alloc_cdev_fail:
        unregister_chrdev_region(char_device.dev_id, 1);
dev_id_fail:
        return result;
}

static void __exit chrdev_exit(void)
{
        printk(KERN_INFO
                "This is a chrdev module"
                " for char dev exit function\n");
        // 销毁设备文件
        device_destroy(char_device.class, char_device.dev_id);
        // 销毁设备类型
        class_destroy(char_device.class);
        // 从系统当中删除字符设备
        cdev_del(char_device.cdev);
        // 回收申请到的设备号
        unregister_chrdev_region(char_device.dev_id, 1);
}

module_init(chrdev_init);
module_exit(chrdev_exit);

MODULE_LICENSE("GPL"); // 必须为GPL的license
MODULE_AUTHOR("zhangjl");
\end{code-block}

需要注意的是，一旦使用了上述的这种方式，则内核模块的license必须为GPL，原因是
device\_destroy和class\_destroy都属于GPL的导出函数，与其他的协议不兼容。如果
强制使用其他的协议，则会出现类似下列的错误：
\begin{code-block}{bash}
FATAL: modpost: GPL-incompatible module private.ko uses GPL-only symbol 'device_destroy'
scripts/Makefile.modpost:93: recipe for target '__modpost' failed
make[2]: *** [__modpost] Error 1
\end{code-block}
利用上述的框架，除了在/dev下生成对应的设备文件之外，在/sys/class下也会生成对应的
文件。

如果将上述代码再次进行改写，全部使用指针的形式，则需要在内核当中使用kmalloc/kzalloc/kfree等函数，
用于在内核空间当中申请对应的内存空间，具体的代码如下：
\begin{code-block}{c}
#include <linux/version.h>
#include <linux/cdev.h>
#include <linux/fs.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/uaccess.h>

#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 0, 0)
#include <linux/device.h>
#endif

#define DEV_NAME "chrdev"
#define BUFFER_LEN 1024

struct chrdev {
        dev_t         dev_id;
        unsigned int  major;
        unsigned int  minor;
        struct device *device;
        struct class  *class;
        struct cdev   *cdev;
        char          buffer[BUFFER_LEN];
};

// 定义设备结构体指针，而不再是结构体
static struct chrdev *dev;
static unsigned int major = 0;
module_param(major, uint, S_IRUGO);

static int open_chrdev(struct inode *inodep, struct file *filp)
{
        filp->private_data = dev;
        printk(KERN_INFO "Open the char dev named chrdev\n");
        return 0;
}

static int release_chrdev(struct inode *inodep, struct file *filp)
{
        struct chrdev *dev = (struct chrdev*)filp->private_data;
        printk(KERN_INFO "Close the char dev \n");
        return 0;
}

static ssize_t read_chrdev(struct file *filp,
        char __user * user_buffer, size_t count, loff_t *ppos)
{
        int ret = 0;
        struct chrdev *dev = (struct chrdev*)filp->private_data;
#if defined(__arm__)
        printk(KERN_INFO "The count of user"
                " namespace requested is %d\n", count);
#else
        printk(KERN_INFO "The count of user"
                " namespace requested is %ld\n", count);
#endif
        if (*ppos > BUFFER_LEN) {
                return count ? -ENXIO : 0;
        }

        if (count > (BUFFER_LEN - *ppos)) {
                count = BUFFER_LEN - *ppos;
        }

        if ((ret = copy_to_user(
                user_buffer, (void *)(dev->buffer+*ppos), count))) {
                printk(KERN_ERR "Failed to read data from kernel\n");
                return -EFAULT;
        }

        *ppos += count;
        return count;
}

static ssize_t write_chrdev(struct file *filp,
        const char __user *user_buffer, size_t count, loff_t *ppos)
{
        int ret = 0;
        struct chrdev *dev = (struct chrdev*)filp->private_data;
#if defined(__arm__)
        printk(KERN_INFO "The count of user namespace write is %d\n", count);
#else
        printk(KERN_INFO "The count of user namespace write is %ld, %lld\n",
                count, *ppos);
#endif
        if (count >= BUFFER_LEN) {
                return count ? -ENXIO : 0;
        }
        // 如果需要每次都覆盖内存当中的内容，需要进行原始内容清空
        // memset(dev->buffer, 0, BUFFER_LEN);
        if ((ret = copy_from_user(dev->buffer+*ppos, user_buffer, count))) {
                printk(KERN_ERR "Faichrdev write to char device\n");
                return -EFAULT;
        }
        *ppos += count;
        printk(KERN_INFO "Write to the char dev with content %s\n",
                dev->buffer);
        return count;
}

static struct file_operations chrdev_fops = {
        .owner   = THIS_MODULE,
        .open    = open_chrdev,
        .release = release_chrdev,
        .read    = read_chrdev,
        .write   = write_chrdev,
};

static int __init chrdev_init(void)
{
        int result = 0;
        // 申请内核空间的内存使用kmalloc和kzalloc，但是通常使用kzalloc
        // 原因在于kzalloc申请内存之后，自动将对应的内存区域进行清空置零
        // 而kmalloc并不会。另外，kzalloc在底层默认就是调用kmalloc函数进行的
        // 操作
        // dev = kmalloc(sizeof(struct chrdev), GFP_KERNEL);
        dev = kzalloc(sizeof(struct chrdev), GFP_KERNEL);
        if (!dev) {
                result = -ENOMEM;
                goto alloc_kernel_fail;
        }
        if (major > 0) {
                dev->dev_id = MKDEV(major, 0);
                result = register_chrdev_region(dev->dev_id, 1, DEV_NAME);
        } else {
                result = alloc_chrdev_region(&(dev->dev_id), 0, 1, DEV_NAME);
        }
        if (result) {
                printk(KERN_ERR "Faild to register the char device\n");
                result = -EFAULT;
                goto dev_id_fail;
        }

        dev->major = MAJOR(dev->dev_id);
        dev->minor = MINOR(dev->dev_id);

        // 申请一个cdev指针
        dev->cdev = cdev_alloc();
        if (!dev->cdev) {
                printk(KERN_ERR "Faild to alloc cdev struct \n");
                result = -EFAULT;
                goto alloc_cdev_fail;
        }

        dev->cdev->owner = THIS_MODULE;

        // 初始化cdev结构体指针
        cdev_init(dev->cdev, &chrdev_fops);

        if ((result = cdev_add(dev->cdev, dev->dev_id, 1))) {
                printk(KERN_ERR "Faild to add chrdev into Linux system\n");
                result = -EFAULT;
                goto dev_add_fail;
        }

        dev->class = class_create(THIS_MODULE, DEV_NAME);
        if (IS_ERR(dev->class)) {
                result = PTR_ERR(dev->class);
                goto dev_class_fail;
        }

        dev->device = device_create(dev->class, NULL,
                dev->dev_id, NULL, DEV_NAME);
        if (IS_ERR(dev->device)) {
                result = PTR_ERR(dev->device);
                goto dev_device_fail;
        }

        memset(dev->buffer, 0, BUFFER_LEN);

        printk(KERN_INFO "This is a chrdev module"
                " for char dev init function,"
                " and major is %d, minor is %d\n",
                dev->major, dev->minor);
        return result;

dev_device_fail:
        class_destroy(dev->class);
dev_class_fail:
        cdev_del(dev->cdev);
dev_add_fail:
alloc_cdev_fail:
        unregister_chrdev_region(dev->dev_id, 1);
dev_id_fail:
        kfree(dev);
alloc_kernel_fail:
        return result;
}

static void __exit chrdev_exit(void)
{
        printk(KERN_INFO "This is a chrdev module"
                " for char dev exit function\n");
        device_destroy(dev->class, dev->dev_id);
        class_destroy(dev->class);
        cdev_del(dev->cdev);
        unregister_chrdev_region(dev->dev_id, 1);
        // 释放申请的设备结构体指针内存
        kfree(dev);
}

module_init(chrdev_init);
module_exit(chrdev_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("zhangjl");
\end{code-block}

\section{内核的并发与同步}
内核当中也会涉及到并发与同步。最简单的并发控制，便是使用原子操作，限制设备的
并发访问。对上述代码进行改动，就变成了一个只允许同一时间只能有一个访问请求的
驱动，代码的改动如下：
\begin{code-block}{c}
...
static unsigned int major;
// 定义设备同一时间只有一个可用
static atomic_t awcloud_available = ATOMIC_INIT(1);
module_param(major, uint, 0444);
...

static int open_awcloud_mem(struct inode *inodep, struct file *filp)
{
        // 设备已经被打开
        if (!atomic_dec_and_test(&awcloud_available)) {
                atomic_inc(&awcloud_available);
                // 设备正忙
                return -EBUSY;
        }
        filp->private_data = dev;
        return 0;
}

static int release_awcloud_mem(struct inode *inodep, struct file *filp)
{
        // 释放设备
        atomic_inc(&awcloud_available);
        return 0;
}
...
\end{code-block}

但是，同时只允许一个进程访问的设备驱动毕竟是少数，
因此内核当中的并发，通常采用自旋锁以及信号量进行。
自旋锁的主要特点如下：
\begin{itemize}
  \item 忙等待，无调度开销
  \item 禁止进程抢占
  \item 锁定期间不能休眠
\end{itemize}
即访问互斥的临界资源，如果无法拿到对应资源的锁，则自己进行自旋，直到拿到锁为止。
自旋锁的空间也是原子空间，不能执行任何可能引起睡眠的操作。自旋锁不能被任何一个线程
打断，但是可以被中断打断。所以，自旋锁存在一个变体，即spin\_lock\_irqsave，可以保证被
中断打断。单核的情况下，自旋锁退化为禁止内核调度或者抢占。
自旋锁的使用大致如下：
\begin{code-block}{c}
spinlock_t lock;
spin_lock_init(&lock);
spin_lock(&lock);   // 获取自旋锁，保护临界区
...                 // 临界区
spin_unlock(&lock); // 解锁
\end{code-block}
通常，自旋锁用在一段可以在很短的时间内做完的操作当中；如果对应的操作可能存在
休眠，以及需要很长的时间进行操作，则只能使用信号量以及互斥量。

而信号量（互斥量）的特点则如下：
\begin{itemize}
  \item 拿不到需要的资源就进行进程切换，存在调度的开销
  \item 锁定期间可以休眠，但是不用于中断的上下文
\end{itemize}
信号量的使用大致如下：
\begin{code-block}{c}
DECLARE_MUTEX(sem);// 定义信号量
down(&sem); // 获取信号量，保护临界区
... // 临界区
up(&sem); // 释放信号量
\end{code-block}

互斥量的使用大致如下：
\begin{code-block}{c}
// mutex_init(); 动态申请互斥量
static DEFINE_MUTEX(my_mutex); // 静态定义互斥量，通常是全局范围
mutex_lock(&my_mutex);  // 获取互斥量，保护临界区
... // 临界区
mutex_unlock(&my_mutex);// 释放互斥量
\end{code-block}

而内核的同步，即要求某件事情必须先完成，其他事情才可以继续，则通常采用completion和等待队列进行。
Completion的主要作用就是用于同步。其基本的使用如下：
\begin{code-block}{c}
struct completion done;

static int xxx_txrx()
{
        init_completion(&done);
        ...
        wait_for_completion(&done); // 对应进程进入休眠状态，等待事情完成
        ...
}

static irqreturn_t xxx_irq(int irq, void *dev)
{
        ...
        complete(&done);            // 任务完成，唤醒wait_for_completion的进程
        return IRQ_HANDLED;
}
\end{code-block}

等待队列，代表了一些休眠进程的集合。在实际的使用当中，信号量/互斥量以及completion
都需要使用等待队列进行完成。其基本的用法如下：
\begin{code-block}{c}
wait_queue_head_t xxx_wait;

void xxx(...)
{
        // wait和current为内核当中已经存在的2个宏定义
        // 定义等待队列
        DECLARE_WAITQUEUE(wait, current);
        // 添加到等待队列中，唤醒等待队列，就可以唤醒当前的进程
        add_wait_queue(&xxx_wait, &wait);

        do {
                avail = device_writeble(...);
                if (0>avail) {
                        // 改变进程状态，进程进入可打断的休眠态
                        __set_current_state(TASK_INTERRUPTIBLE);
                }
                if (0>avail) {
                        // 非阻塞
                        if(file->f_flags & O_NONBLOCK) {
                            ...
                        }
                        // 调度其他进程执行
                        schedule();
                        // 信号唤醒
                        if (signal_pending(current)) {
                            ...
                        }
                }
        } while(avail<0);
        device_write(...);

        // 从等待队列当中移除
        remove_wait_queue(&xxx_wait, &wait);
        // 设置进程状态为运行
        __set_current_state(TASK_RUNNING);
}
\end{code-block}

\section{内核的延时与定时器以及中断}
内核的延时主要有2种：忙等待和休眠等待。
所谓的忙等待，就是空转，常用的函数包括ndelay，udelay，mdelay等，这些函数会
直接消耗cpu，并且不会将cpu调度给其他的进程，最好不要随意使用只有等待时间很短，
或者对应的任务不能休眠的情况下，才能使用忙等待。其他情况下，通常都是使用休眠
等待，即会将cpu调度给其他进程使用，包括msleep，msleep\_interupptible，ssleep，
sleep\_on\_timeout，interruptible\_sleep\_on\_timeout等。

而为了精确的定义时间，以及定时任务，内核当中包含了一个定时器，其大致的定义如下：
\begin{code-block}{c}
struct timer_list {
        // 定时器列表
        struct list_head entry;
        // 定时器到期时间
        unsigned long expires;
        // 定时器的处理函数
        void (*function)(unsigned long);
        // 定时器处理函数的参数
        unsigned long data;
        struct timer_base_s *base;
};
\end{code-block}
当定时器到期之后，function函数将被执行。一个简单的定时器使用范例如下：
\begin{code-block}{c}
void xxx_func(...)
{
        struct xxx_dev *dev = (struct xxx_dev *)filp->private_data;
        // 初始化定时器
        init_timer(&dev->xxx_timer);
        dev->xxx_timer.function = &xxx_do_timer;

        // 设备结构体指针作为定时器处理函数的参数
        dev->xxx_timer.data = (unsigned long)dev;
        dev->xxx_timer.expires = jiffies + delay;
        //  添加/注册定时器
        add_timer(&dev->xxx_timer);
}

static void xxx_do_timer(unsigned long arg)
{
        // 将指针地址转换为设备指针
        struct xxx_device *dev = (struct xxx_dev *)(arg);
        ...
        // 调度定时器再次执行
        dev->xxx_timer.expires = jiffies + delay;
        add_timer(&dev->xxx_timer);
}
\end{code-block}
一个完整的内核定时器的实例大致如下：
\begin{code-block}{c}
#include <linux/version.h>
#include <linux/cdev.h>
#include <linux/fs.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/uaccess.h>

#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 0, 0)
#include <linux/device.h>
#endif

#define DEV_NAME "awcloud"
#define MEM_CLEAR 0x1

struct awcloud_seconds {
        struct device        *device;
        struct class         *class;
        struct cdev          cdev;
        atomic_t             counter;
        struct timer_list    timer;
};

static struct awcloud_seconds *dev;
static unsigned int major;
static unsigned int num_devices;
module_param(major, uint, 0444);
module_param(num_devices, uint, 0444);

static void awcloud_seconds_handler(unsigned long arg)
{
        mod_timer(&dev->timer, jiffies + HZ);
        atomic_inc(&dev->counter);
        pr_info("Current jiffies is %ld\n", jiffies);
}

static int open_awcloud_seconds(struct inode *inodep, struct file *filp)
{
        struct awcloud_seconds *dev = container_of(
                inodep->i_cdev, struct awcloud_seconds, cdev);

        filp->private_data = dev;
        init_timer(&dev->timer);
        dev->timer.function = &awcloud_seconds_handler;
        dev->timer.expires = jiffies + HZ;
        add_timer(&dev->timer);
        atomic_set(&dev->counter, 0);
        return 0;
}

static int release_awcloud_seconds(struct inode *inodep, struct file *filp)
{

        struct awcloud_seconds *dev =
                (struct awcloud_seconds *)filp->private_data;

        del_timer(&dev->timer);
        return 0;
}

static ssize_t read_awcloud_seconds(struct file *filp,
        char __user *user_buffer, size_t count, loff_t *ppos)
{
        int ret = 0;
        struct awcloud_seconds *dev =
                (struct awcloud_seconds *)filp->private_data;

        ret = atomic_read(&dev->counter);
        if (put_user(ret, (int *)user_buffer)) {
                pr_err("Failed to copy to user\n");
                return -EFAULT;
        }
        return sizeof(unsigned int);
}

const static struct file_operations awcloud_seconds_fops = {
        .owner          = THIS_MODULE,
        .open           = open_awcloud_seconds,
        .release        = release_awcloud_seconds,
        .read           = read_awcloud_seconds,
};

static int awcloud_seconds_setup_chrdev(struct awcloud_seconds *dev, int index)
{
        int result = 0;
        char device_name[10];
        dev_t dev_id = MKDEV(major, index);

        dev->cdev.owner = THIS_MODULE;
        cdev_init(&dev->cdev, &awcloud_seconds_fops);
        if (cdev_add(&dev->cdev, dev_id, 1)) {
                pr_err("Failed to add char dev into system\n");
                result = -1;
                goto cdev_add_err;
        }

        sprintf(device_name, DEV_NAME"%d", index);
        dev->device = device_create(
                dev->class, NULL, dev_id, NULL, device_name);
        if (IS_ERR(dev->device)) {
                result = -1;
                goto device_create_err;
        }

        return result;

device_create_err:
        cdev_del(&dev->cdev);
cdev_add_err:
        return result;
}

static void release_awcloud_seconds_chrdev(
        struct awcloud_seconds *dev, int index)
{
        dev_t dev_id = MKDEV(major, index);

        device_destroy(dev->class, dev_id);
        cdev_del(&dev->cdev);
}

static int __init awcloud_seconds_init(void)
{
        int result = 0;
        int index = 0;
        int tmp[3] = {0};
        dev_t dev_id;
        struct class *class = NULL;

        if (0 >= num_devices) {
                num_devices = 1;
        }

        dev = kzalloc(
            sizeof(struct awcloud_seconds) * num_devices, GFP_KERNEL);
        if (!dev) {
                result = -ENOMEM;
                goto finally;
        }

        if (major > 0) {
                dev_id = MKDEV(major, 0);
                result = register_chrdev_region(
                        dev_id, num_devices, DEV_NAME);
        } else {
                result = alloc_chrdev_region(
                        &dev_id, 0, num_devices, DEV_NAME);
        }

        if (result) {
                pr_err("Failed to alloc the char dev number\n");
                result = -EFAULT;
                goto alloc_dev_id_err;
        }

        major = MAJOR(dev_id);
        class = class_create(THIS_MODULE, DEV_NAME);
        if (IS_ERR(class)) {
                result = -1;
                goto class_create_err;
        }

        for (index = 0; index < num_devices; index++) {
                (dev+index)->class = class;
                tmp[index] = awcloud_seconds_setup_chrdev(dev+index, index);
                result |= tmp[index];
        }

        if (result) {
                for (index = 0; index < num_devices; index++) {
                        if (!tmp[index]) {
                                release_awcloud_seconds_chrdev(
                                        dev+index, index);
                        }
                }
                goto setup_chrdev_err;
        }

        return result;

setup_chrdev_err:
        class_destroy(class);
class_create_err:
        unregister_chrdev_region(MKDEV(major, 0), num_devices);
alloc_dev_id_err:
        kfree(dev);
finally:
        return result;
}

static void __exit awcloud_seconds_exit(void)
{
        int index = 0;

        for (index = 0; index < num_devices; index++) {
                release_awcloud_seconds_chrdev(dev+index, index);
        }

        class_destroy(dev->class);
        unregister_chrdev_region(MKDEV(major, 0), num_devices);
        kfree(dev);
}

module_init(awcloud_seconds_init);
module_exit(awcloud_seconds_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("zhangjl@awcloud.com");
\end{code-block}
该内核驱动对应的用户态测试程序如下：
\begin{code-block}{c}
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

int main(int argc, char *argv[])
{
        int fd;
        int counter = 0;
        int old_counter = 0;

        fd = open("/dev/awcloud0", O_RDONLY);
        if (0 > fd) {
                printf("Cannot open the device\n");
                return -1;
        }
        while (1) {
                read(fd, &counter, sizeof(unsigned int));
                if (counter != old_counter) {
                        printf("seconds after open devices:%d\n",
                                counter);
                        old_counter = counter;
                }
        }

        close(fd);
        return 0;
}
\end{code-block}
加载该内核模块，然后运行对应的测试程序，可以看到，内核日志的输出如下图\colorunderlineref{fig:seconds}所示：
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.5]{seconds.png}
  \caption{秒设备}
  \label{fig:seconds}
\end{figure}


在内核当中，中断包含了2部分：中断的上半部以及中断的下半部（底半部）。上半部
是硬件处理机制，而底半部，则是软件的处理，因此通常称之为软中断。

软中断可以采用Tasklet进行操作，其基本的操作如下：
\begin{code-block}{c}
// 定义tasklet与底半部函数，并进行关联
void xxx_do_tasklet(unsigned long);
DECLARE_TASKLET(xxx_tasklet, xxx_do_tasklet, 0);

// 中断处理底半部
void xxx_do_tasklet(unsigned long)
{
        ...
}

// 中断处理顶半部
irqreturn_t xxx_interupt(int irq, void *dev_id, struct pt_regs *regs)
{
        ...
        tasklet_schedule(&xxx_tasklet);
        ...
}

static int __init xxx_init(void)
{
        ...
        // 申请中断号
        result = request_irq(xxx_irq, xxx_interupt, 0, "xxx", NULL);
        ...
}

static void __exit xxx_exit(void)
{
        ...
        // 释放中断
        free_irq(xxx_irq, xxx_interupt);
        ...
}
\end{code-block}
当处理不可能出现休眠状态的中断，或者优先级非常高的中断时，可以考虑采用Tasklet；
而如果是处理可能出现休眠状态的中断，则应该考虑使用工作队列（workqueue）；而针对
input类型的中断时（比如触摸屏），则应当考虑使用threaded\_irq。
工作队列的使用于tasklet非常相似：
\begin{code-block}{c}
// 定义tasklet与底半部函数，并进行关联
struct work_struct xxx_wq;
void xxx_do_work(struct work_struct *work);

// 中断处理底半部
void xxx_do_work(struct work_struct *work)
{
        ...
}

// 中断处理顶半部
irqreturn_t xxx_interupt(int irq, void *dev_id)
{
        ...
        schedule_work(&xxx_wq);
        ...
        return IRQ_HANDLED;
}

static int __init xxx_init(void)
{
        ...
        // 申请中断号
        result = request_irq(xxx_irq, xxx_interupt, 0, "xxx", NULL);
        // 初始化工作队列
        INIT_WORK(&xxx_xq, xxx_do_work);
        ...
}

static void __exit xxx_exit(void)
{
        ...
        // 释放中断
        free_irq(xxx_irq, xxx_interupt);
        ...
}
\end{code-block}
需要注意的是，工作队列执行的是内核线程，因此，是可以进行调度的，而且可以休眠。

\section{Linux的进程遍历}
一个进程是由进程控制块（PCB），代码段和数据段组成的；并且，OS通常是通过PCB来感知
一个进程的存在。其实PCB就是操作系统对每个进程的代码描述。linux内核中使用task\_struct
结构来描述一个PCB（具体可以在linux/kernel/sched.c查看源码）；多个进程则常常使用双链表
等来进行组织。比如可运行状态的进程组成可运行队列，等待状态的进程组成等待队列等。

list\_head为linux内核当中常用的数据结构，用于构造双链表，关于list\_head的具体用法，可以
参见c部分的宏定义高级使用部分。而task\_struct的定义类似于如下的代码：
\begin{code-block}{c}
struct task_struct {
        struct thread_info    thread_info;
        struct list_head      tasks;
};
\end{code-block}

由于该结构体当中存在list\_head的变量，因此，我们可以利用该变量来访问整个task\_strut,
进而获取我们需要的信息。完整代码如下：
\begin{code-block}{c}
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/sched.h>
#include <linux/sem.h>
#include <linux/list.h>

MODULE_LICENSE("GPL");
static int hello_init(void)
{
        printk(KERN_ALERT "hello,I am zhangjl\n");
        return 0;
}

static int traverse_init(void)
{
       struct task_struct *pos;
       struct list_head *current_head;
       int count=0;
       printk("Traversal module is working..\n");
       current_head=&(current->tasks);
       list_for_each_entry(pos,current_head,tasks)
       {
              count++;
              printk("[process %d]: %s\'s pid is %d\n",count,pos->comm,pos->pid);
       }
       printk(KERN_ALERT"The number of process is:%d\n",count);
       return 0;
}

static void hello_exit(void)
{
    printk(KERN_ALERT "goodbye,kernel\n");
    traverse_init();
}

module_init(hello_init);
module_exit(hello_exit);
MODULE_AUTHOR("zhangjl");
MODULE_DESCRIPTION("This is a simple example!\n");
MODULE_ALIAS("A simplest example");

\end{code-block}

其中，current是一个宏，即为系统内正在运行的进程。编译该文件，然后加载该模块，在
系统日志当中，即可发现对应的输出。

\input{kernel_io}
\input{systemprogram}
