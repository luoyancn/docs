\chapter{Golang}

\section{代理设置}
由于Golang是google的项目，因此，有的公用类库是依赖于google的域名解析的，导致在
一些情况下，无法更新或者下载相关的类库代码。解决方式就是设置代理。
Golang下载代码主要是通过go和其他一些版本控制工具进行下载的，通常的，版本控制工具
选择的都是git。因此，设置代理的时候，需要针对go和git设置。以windows为例。
\begin{code-block}{bash}
set http_proxy=http://10.1.1.10:8123
git config --global http.proxy http://10.1.1.10:8123
# 如果是使用sock5代理，则可以使用下面的方式
git config --global http.proxy socks5://localhost:8588
\end{code-block}

设置完成之后，即可进行go get更新和下载。Linux环境类似。

\section{安装Golang的开发工具}
只有设置好代理之后，才能正常的安装开发golang所需要使用的开发工具。
\begin{code-block}{bash}
go get -u -v honnef.co/go/tools/cmd/keyify
go get -u -v github.com/koron/iferr
go get -u -v github.com/visualfc/gocode
go get -u -v github.com/rogpeppe/godef
go get -u -v github.com/zmb3/gogetdoc
go get -u -v github.com/golang/lint/golint
go get -u -v github.com/lukehoban/go-outline
go get -u -v github.com/sqs/goreturns
go get -u -v github.com/tpng/gopkgs
go get -u -v github.com/newhook/go-symbols
go get -u -v github.com/cweill/gotests/
go get -u -v github.com/alecthomas/gometalinter
go get -u -v github.com/jstemmer/gotags
go get -u -v github.com/klauspost/asmfmt/cmd/asmfmt
go get -u -v github.com/fatih/motion
go get -u -v github.com/fatih/gomodifytags
go get -u -v github.com/josharian/impl
go get -u -v github.com/kisielk/errcheck
go get -u -v github.com/sparrc/gdm
go get -u -v github.com/kardianos/govendor
go get -u -v github.com/tylerb/gotype-live
go get -u -v github.com/spf13/cobra/cobra
go get -u -v github.com/Masterminds/glide
go get -u -v github.com/golang/protobuf/protoc-gen-go
go get -v -u github.com/derekparker/delve/cmd/dlv
go get -u -v github.com/davidrjenni/reftools/cmd/fillstruct
go get -u -v github.com/gohugoio/hugo
go get -u -v golang.org/x/tools/cmd/guru
go get -u -v golang.org/x/tools/cmd/gorename
go get -u -v golang.org/x/tools/cmd/goimports
gometalinter --install -u
\end{code-block}

Golang代码补齐依赖于gocode，而gocode不是一个常驻的服务，也不是一个类似于
python或者c/c++一样的编译型的解释器。Gocode更类似于一个实时的代码分析服务器，
需要进行补齐时，访问gocode服务器，获取返回进行代码补齐。因此，最好是把gocode做成
一个常驻性的服务一直在后台运行，这需要对gocode的代码做部分的修改。
\begin{code-block}{bash}
cd go/src/github.com/nsf/gocode
git checkout -b backend
git revert e11212347fbcdc8a33e9955b141f250f4eb14e94
git commit
go build .
cp gocode.exe go/bin/
\end{code-block}

在windows下，后台程序一般是以服务的形式运行，所以，针对windows平台，我们可以通过
添加服务的方式添加gocode的常驻进程。
\begin{code-block}{bash}
sc create gocode binPath="c:\go\bin\gocode.exe set propose-builtins true autobuild true close-timeout 43200"
\end{code-block}
然后在windows服务中，启动gocode即可。

\begin{attention}
在windows当中，针对golang需要设置2个系统变量，一个是GOROOT，一个是GOPATH。在1.6
之前，GOROOT和GOPATH可以是同一个路径，但是，在1.8之后，GOROOT和GOPATH必须是不同的路径。
因此，如果执行go get命令，则下载的代码不会放到GOROOT当中，也就是说不能被go识别。
因此，如果一旦go get了第三方的代码，需要在自己的代码当中使用，则必须修改自己的GOPATH。
以windows为例，假设GOROOT=C:\textbackslash GO，GOPATH=C:\textbackslash GOLiberty，则自己的代码的GOPATH则需要修改为如下：
\begin{mdframed}[topline=false, bottomline=false, leftline=false, rightline=false, backgroundcolor=lbcolor]
\begin{minted}[fontsize=\scriptsize,linenos=false,breaklines=true]{bash}
set GOPATH=%GOPATH%;%cd%
\end{minted}
\end{mdframed}
\end{attention}

\section{模块初始化}
每个golang的模块都有一个隐藏的方法init，用来进行模块的初始化。当然，我们还可以进行
初始化的定制。具体就像下面一样
\begin{code-block}{go}
func init() {
    fmt.Printf("OS: %s, Arch: %s", runtime.GOOS, runtime.GOARCH)
}
\end{code-block}

\section{range的使用}
range通常用来进行迭代列表或者字典，通常的使用规则如下表\nameref{tab:usage_of_range}
\begin{center}
  \rowcolors{2}{green!80!yellow!50}{green!70!yellow!40}
  \begin{tabularx}{\textwidth}{|X|X|X|}
  \hline
  表达式类型& 第一返回值& 第二返回值\\ \hline
  [n]Ele& 数组索引值& 数组元素 \\
  string& 字符串索引& 字符数组对应的值\\
  map[k]v& map的键 & map键对应的值\\
  chan E & chan的元素 & - \\ \hline
  \end{tabularx}
  \label{tab:usage_of_range}
\end{center}

具体的使用如下
\begin{code-block}{go}
ints := []int{1, 2, 3, 4, 5, 6}
for index, value := range ints {
    fmt.Printf("%d: %d\n", index, value)
}
for index := range ints {
    fmt.Printf("%d: %d\n", index, ints[index])
}
dict := map[string]int{"lucifer": 18, "titans": 24, "garuda": 36}
for key, value := range dict {
    fmt.Printf("key is %s and value is %d\n", key, value)
}
\end{code-block}

\section{goto的使用}
goto的用法和c/c++当中的一样，也可以用来实现for循环，具体如下。
\begin{code-block}{go}
func goto_loop() {
    index := 0
loop:
    if index < 10 {
        fmt.Printf("index: \t%d\n", index)
        index++
        goto loop
    }
}
\end{code-block}

\section{Golang的继承}
Golang和c一样，并没有类的概念，因此没有继承。但是，由于golang有结构体的存在，因此，
可以使用组合的方式来实现继承。
\begin{code-block}{go}
type User struct{
    name string
    age uint
    address string
}

func (this *User) GetName() string{
    return this.name
}

type Student struct{
    User
    class string
    score uint
    order uint
}
\end{code-block}

在上边的例子中，Student结构内嵌了一个User结构，其结果就是Student结构也存在name，age
address等等属性，并且，GetName方法同样对Student结构是适用的。

\section{Golang的命令行参数}
和Python一样，golang提供了命令行处理的类库。比较常用的就是flag。
例子如下：
\begin{code-block}{go}
var (
    flag_name = flag.String("name", "demo", "The name of user. String value")
    flag_age  = flag.Int("age", 18, "The age of user. Int value")
)

func show_usage() {
    fmt.Fprintf(os.Stderr, "Usage: %s [-name] [-age]\n\n", os.Args[0])
    fmt.Fprintf(os.Stderr, "Flags:\n")
    flag.PrintDefaults()
}

func main(){
    flag.Usage = show_usage
    flag.Parse()
    fmt.Println(*flag_name)
    fmt.Println(*flag_age)
}
\end{code-block}

\section{Golang的Json处理}
同其他语言一样，golang也提供了json的处理，但是和python有不同。Python通常是将json和
字典（dict）进行相互转换，但是，golang只能是将struct对象转换为json，以及将json转换为
golang的映射（map，也即是python的字典）或者对象。另外，由于golang的struct的大小写规则，
如果struct的属性设置为小写，则无法被转换，这时候，需要用到大量的struct tag属性。
具体如下的例子。
\begin{code-block}{go}
import(
    "encoding/json"
)
type User struct {
    Id     string `json:"id"`
    Name   string `json:"name"`
    Active bool   `json:"active"`
    // omitempty表示该项如果有值就输出，否则隐藏
    // about表示该键在转换为json时，Bio键被转换为about键
    Bio       string `json:"about,omitempty"`
    Admin     bool   `json:"-"`  // -表示不输出该值
    AdminRole bool   `json:"-,"` // -,表示该键输出为-
}

func ConstomJson() {
    user := &User{Id: uuid.NewV4().String(), Name: "zhangjl",
                  Active: true, Bio: "luoyan", Admin: true, AdminRole: false}
    user_json, _ := json.Marshal(user)
    fmt.Printf("%v\n", string(user_json))

    user = &User{Id: uuid.NewV4().String(), Name: "zhangjl",
                 Active: true, Admin: true, AdminRole: true}
    // 将对象格式化为json数据
    user_json, _ = json.Marshal(user)
    fmt.Printf("%v\n", string(user_json))
    fmt.Printf("%s\n", user_json)
    // json.Marshal转换的结果是byte数组，将其转换为string
    fmt.Printf("%s\n", bytes.NewBuffer(user_json).String())

    json_str := `{"id":"7722a662-ceeb-41d4-9de7-f7132da3f985",
                  "name":"zhangjl","active":true,"-":false}`

    var f interface{}
    // 将json格式的字符串转换
    err := json.Unmarshal([]byte(json_str), &f)
    if err != nil {
        return
    }
    fmt.Printf("%v\n", f)

    // 转换为map结构
    m := f.(map[string]interface{})
    fmt.Printf("%v\n", m)
    fmt.Printf("%t\n", m["active"])
    fmt.Printf("%t\n", m["-"])

    var user_ User
    // 转换为golang定义的对象
    err = json.Unmarshal([]byte(json_str), &user_)
    if err != nil {
        return
    }
    fmt.Printf("%v\n", user_)
}
\end{code-block}

\section{Golang交叉编译}
Go是一门编译型语言，所以在不同平台上，需要编译生成不同格式的二进制包。
编译时候只需要指定两个参数：GOOS和GOARCH即可。
\begin{code-block}{bash}
# 编译到 linux 64bit
GOOS=linux GOARCH=amd64 go build
# 或者可以使用 -o 选项指定生成二进制文件名字
GOOS=linux GOARCH=amd64 go build -o app.linux

# 编译到 linux 32bit
GOOS=linux GOARCH=386 go build

# 编译到 windows 64bit
GOOS=windows GOARCH=amd64 go build

# 编译到 windows 32bit
GOOS=windows GOARCH=386 go build
\end{code-block}

如果是在windows上进行交叉编译，则操作有部分差别。
\begin{code-block}{bash}
set GOOS=linux
set GOARCH=amd64
go build
\end{code-block}

\section{Golang的坑爹问题}
Go毕竟还只是发展阶段的语言，存在一些问题是有可能的。下面记录一些实际当中遇到的
golang的坑.
\begin{outline}[enumerate]

  \1 ioutil ReadAll导致程序hang住

  Ioutil的ReadAll方法，在某些情况下，会导致程序被卡住，多见于在http请求时候，读取
  返回的body。一般发生在windows环境上，linux环境较少出现。解决的方法比较另类：设置
  http的keepalive参数为false即可。
\begin{code-in-enumerate}{go}
transport := &http.Transport{DisableKeepAlives: true}
client := &http.Client{Transport: transport}
\end{code-in-enumerate}

\end{outline}

\section{TimeFormat}
Go的时间格式化是比较蛋疼的，一般使用标准的格式化字符串是会有其他的字符出现的，
比如时区之类的。如果想格式化为YYYY-mm-dd HH:MM:SS或者中文时间格式，则需要使用
另外的方式。额外提示，一般的语言，包括c/c++，java以及python等等，默认的初始时间
是从1970年开始计算的，但是golang的初始时间点是2006-01-02 15:04:05.000000000 -0700 MST
\begin{code-block}{go}
const ENS_TIME_LAYOR = "2006-01-02 15:04:05"
const CHS_TIME_LAYOR = "2006年01月02日 15:04:05"
fmt.Println(time.Now().Format(ENS_TIME_LAYOR))
fmt.Println(time.Now().Format(CHS_TIME_LAYOR))
// 输出结果如下：
// 2017-08-03 15:18:15
// 2017年08月03日 15:18:16
\end{code-block}

\section{自动构建版本信息}
\begin{code-block}{go}
package main
import (
    "fmt"
)
var version = "No Version Provided"
var buildstamp = "No build stamp Provided"
var githash = "No githash Provided"
func main() {
    fmt.Printf("OceanClient Version: %s\n", version)
    fmt.Printf("OceanClient buildstamp: %s\n", buildstamp)
    fmt.Printf("OceanClient githash: %s\n", githash)
}
\end{code-block}

通过以上的代码，构建出来的版本信息是空，但是，我们可以利用go自带的一些信息，来
构建版本信息。
\begin{code-block}{bash}
go install -ldflags "-X main.version=0.1 -X \
    main.buildstamp=`date '+%Y-%m-%dT%H:%M:%S'` -X main.githash=`git rev-parse HEAD`"
\end{code-block}
其中，main表示golang的模块或者package，version、buildstamp和githash都表示package
当中的全局变量。例如：-X oceanstack/common.Version=0.1，最终的结果如下：
\begin{code-block}{bash}
/opt/github.com/learningo/bin/oceanclient version
OceanClient Version: 0.1
OceanClient buildstamp: 2018-04-25T15:37:38
OceanClient githash: 7a552b1cf6aca0e775d7b5d2dd69449cab8e783a
\end{code-block}
