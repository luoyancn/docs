\chapter{Rust}

\section{安装和配置}
默认情况下，Rust及其工具集Cargo都会被安装到/root/.rust和/root/.cargo，或者
是C:$\backslash\backslash$Users$\backslash\backslash$zhangjl$\backslash\backslash$AppData下，
但Rust提供了2个环境变量，可用于安装路径的修改，其使用如下：
\begin{code-block}{bash}
export CARGO_HOME=/opt/cargo
export RUSTUP_HOME=/opt/rustup
export PATH=/opt/cargo/bin:$PATH
\end{code-block}
Windows，则是修改系统的环境变量，将CARGO\_HOME和RUSTUP\_HOME指向合适的
位置即可。然后再执行安装程序即可（windows执行可执行程序）：
\begin{code-block}{bash}
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
\end{code-block}

安装完毕之后，通常需要进行一些安装和配置，操作如下（Linux/Windows通用）：
\begin{code-block}{bash}
rustup toolchain add nightly
rustup component add rust-src
\end{code-block}

如果需要对Rust和相关的工具进行升级，则操作如下：
\begin{code-block}{bash}
rustup update
\end{code-block}

Rust的工具链也支持多种配置，常用配置通常放在config.toml当中，
其全局作用域的配置具体路径如下：
\begin{itemize}
  \item 全平台通用 \$CARGO\_HOME/config.toml
  \item 类Unix平台 /.config/config.toml
  \item Windows平台 \%USERPROFILE\%$\backslash$.cargo$\backslash$config.toml
\end{itemize}

常见的config.toml的内容如下：
\begin{code-block}{toml}
# 编译时的参数
[build]
# 指定全局的编译过程与结果的存放路径
target-dir = "/mnt/d/rust-build-target"
# 使用增量编译
incremental = true
# 使用sccache进行缓存编译
rustc-wrapper = "sccache"

[profile.release]
# release模式下的调优
lto = true
# 去除debug信息
strip = true

[target.x86_64-pc-windows-msvc]
# windows下设定静态编译参数
rustflags = ["-Ctarget-feature=+crt-static"]

# 设置http与https代理，cargo与rustup共享
[http]
proxy = "socks5://172.16.1.48:9999"
[https]
proxy = "socks5://172.16.1.48:9999"
\end{code-block}

如果需要将某一个Rust工程（文件夹）切换成指定版本/分支进行编译，则操作如下：
\begin{code-block}{bash}
# 与Cargo.toml同级的目录，在workspaces则是全工作区范围，在workspaces下的目录，则是
# 针对单独的项目，指定stable版本（https://github.com/rust-lang/rust/blob/master/RELEASES.md）
echo 'stable-2021-10-21' > rust-toolchain
echo 'nightly' > rust-toolchain
# 或者进行全局切换 rustup override set nightly
rustup default stable
\end{code-block}

\section{Rust的交叉编译}
Rust本身也支持进行交叉编译，可以在Linux下完成针对ARM/Windows的目标文件的编译。
默认情况下，Rust的工具链只会包含当前操作系统默认支持的工具链。查看工具链可
如下操作：
\begin{code-block}{bash}
rustup target list
\end{code-block}

其结果大致如下图\colorunderlineref{fig:rust_target}所示。
\begin{figure}[H]
  \centering
  %\includegraphics[scale=0.5]{rust_target.png}
  \includegraphics[width=\linewidth]{rust_target.png}
  \caption{Rust支持的目标文件架构}
  \label{fig:rust_target}
\end{figure}

需要编译对应架构的目标文件，则需要添加对应架构的工具链
\begin{code-block}{bash}
rustup target add armv7-unknown-linux-gnueabihf
rustup target add armv7-unknown-linux-musleabihf
rustup target add aarch64-unknown-linux-gnu
rustup target add aarch64-unknown-linux-musl
rustup target add x86_64-unknown-linux-musl
rustup target add x86_64-pc-windows-gnu
\end{code-block}

除了添加工具链之外，还需要安装对应的交叉编译工具
\begin{code-block}{bash}
dnf install mingw64-gcc mingw64-winpthreads-static musl-gcc musl-libc -y
# 针对musl静态编译，需要内核模块支持时，必须进行下列设置
ln -s /usr/include/linux/ /usr/x86_64-linux-musl/include/linux
ln -s /usr/include/asm /usr/x86_64-linux-musl/include/asm
ln -s /usr/include/asm-generic /usr/x86_64-linux-musl/include/asm-generic
\end{code-block}

而针对ARM V7以及ARM X64的交叉编译工具，则是使用gcc-linaro工具链即可。
针对Windows 64的交叉编译方法比较简单，针对当前平台进行静态编译同样也比较简单，其编译指令如下：
\begin{code-block}{bash}
# windows 默认就是静态编译
cargo build --release --target=x86_64-pc-windows-gnu
# 针对x86的静态编译
cargo build --release --target=x86_64-unknown-linux-musl
\end{code-block}

针对ARM V7和ARM X64的编译过程稍微复杂一些，其操作如下：
\begin{enumerate}
  \item 创建配置文件：进入rust工程的根目录
\begin{code-block}{bash}
# 如果是针对全局的rust项目，则应该将.cargo目录放在/.cargo（$CARGO_HOME/config.toml）下
mkdir /.cargo
#低于1.80版本为/.cargo/config
touch /.cargo/config.toml
\end{code-block}

  \item 修改配置文件，设置交叉编译工具
\begin{code-block}{bash}
cat >/.cargo/config.toml<<EOF
[target.armv7-unknown-linux-gnueabihf]
linker = "/opt/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gcc"
ar = "/opt/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-ar"

[target.armv7-unknown-linux-musleabihf]
linker = "/opt/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-ld"
ar = "/opt/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-ar"

[target.aarch64-unknown-linux-gnu]
linker = "/opt/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-gcc"
ar = "/opt/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-ar"

[target.aarch64-unknown-linux-musl]
linker = "/opt/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-ld"
ar = "/opt/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-ar"

EOF
\end{code-block}

  \item 进行交叉编译：
\begin{code-block}{bash}
# 针对ARM V7(32位)，实际上本身就是静态编译
cargo build --release --target=armv7-unknown-linux-gnueabihf
# 针对ARM V7(32位)- 显式静态编译
cargo build --release --target=armv7-unknown-linux-musleabihf
# 针对ARM X64，实际上本身就是静态编译
cargo build --release --target=aarch64-unknown-linux-gnu
# 针对ARM X64 - 显式静态编译
cargo build --release --target=aarch64-unknown-linux-musl
\end{code-block}
\end{enumerate}

\begin{note}
静态编译并不意味着生成的一定是static的，而是默认优先static。如果代码的依赖
关系中存在动态链接的，则生成的文件同样也只会是动态链接的（dynamically linked）。
由于x86\_64与x86\_64-musl的类库绝大部分是相同的，因此，如果出现只能动态链接的
情况时，默认是无法编译的，需要添加特定参数：
\begin{code-block}{bash}
PKG_CONFIG_ALLOW_CROSS=1 cargo build --release --target=x86_64-unknown-linux-musl
\end{code-block}

但是必须注意，gcc与musl-gcc的版本必须相同，否则编译仍然会失败。
真实原因在于，指定PKG\_CONFIG\_ALLOW\_CROSS=1时，没有指定交叉编译的target的pkg-config路径，
rust就使用直接了系统(host) 的pkg-config path了，如/usr/lib/pkgconfig或/usr/share/pkgconfig，
那么凡是这里能找到的库，它都不会再进行编译了。如果真的要在交叉编译时启用pkg-config，则应该
指定环境变量PKG\_CONFIG或PKG\_CONFIG\_PATH。环境变量PKG\_CONFIG\_PATH是用来设置.pc文件的
搜索路径的，pkg-config按照设置路径的先后顺序进行搜索，直到找到指定的.pc文件为止。

同样的，arm以及aarch的编译也会有上述问题。
\end{note}

\noindent\tikz[baseline=(crayon.base), scale=1] \node[scale=0.8, inner sep=0pt, anchor=center, align=center] (crayon) {\bccrayon}; {\SectionFont\Large\rmfamily 扩展阅读——Zig交叉编译}
\vspace{1em}

在上述的交叉编译方式中，部分代码无法实现真正的交叉编译与静态编译，其实质是
底层编译器还是使用了与当前平台相匹配的C编译器（比如Gcc/MS Studio/Clang等）,
并且编译生成二进制文件时，需要链接一个C运行时。如果将C运行时打包进生成的二
进制文件中，则可以真正意义上实现静态编译与交叉编译。由此，可以使用Zig\footnote{\url{https://ziglang.org/}}
当作后端的C编译器与运行时，从而解决上述问题。其操作方式如下：
\begin{code-block}{bash}
# 安装zig编译器，参见zig官网
# 安装zigbuild
cargo install cargo-zigbuild
# 使用zig替换llvm/gcc作为后端
# 类unix
cargo zigbuild --release --target x86_64-unknown-linux-musl
# windows，gcc的宏会被更严格的zig标记为错误，需要禁用它
CFLAGS_x86_64_pc_windows_gnu="-Wno-error=date-time" cargo zigbuild --release --target x86_64-pc-windows-gnu
\end{code-block}

\section{Rust的控制流}
Rust的控制流和其他语言相同，都包含了判断和循环。Rust的判断流通过if/else以及
else if实现，但是并不包含switch语句。当if-else的结构过多，则会导致代码比较
杂乱，因此Rust还提供了另外一种语法格式：match来解决这些问题。 Rust的if/else可以用在普通的判断场景，但判断条件必须是bool类型的数据，不允许
使用其他类型作为判断的依据，所以，下列的代码是错误的：
\begin{code-block}{rust}
let a = 10;
// error, a is not a boolean type
if a {
    ...
}
\end{code-block}

Rust也有自己的3元运算符，其使用基本如下：
\begin{code-block}{rust}
let a = 100;
let b = 200;
let number = if a > b {
    b
} else {
    a
};

\end{code-block}

Rust的循环操作比较丰富，除了常见的for，while之外，还提供了loop循环。默认情况
下，loop语句是无限循环。
\begin{code-block}{rust}
loop {
    println!("Forever loop");
}
\end{code-block}
通常情况下，loop是和break配合使用的。和其他语言不太一样，在其他语言当中，break
关键字只是用于中断当前运行的循环，但是Rust当中，break可以后接表达式，将退出
的信息返回给调用者，如下：
\begin{code-block}{rust}
let mut counter = 0;
loop {
    println!("loop");
    if counter > 10 {
        break;
    }
    counter += 1;
}
counter = 0;
let result = loop {
    counter += 1;
    if 10 == counter {
        break counter * 2;
    }
};
\end{code-block}
当上述循环退出之后，result的值就相当于counter的2倍。

而其他语言当中常用的while/for循环，Rust也同样支持，但是，不支持do-while结构。
相比较而言，Rust的while是最简单的，其示例如下：
\begin{code-block}{rust}
let mut number = 3;
while number != 0 {
    println!("{}!", number);
    number = number - 1;
}
\end{code-block}
实际使用当中，for循环使用比较多。Rust的for循环和python类似，都是for-in结构。
具体的示例如下：
\begin{code-block}{rust}
let array = [1, 2, 3, 4, 5];
// 引用权
for element in &array {
    println!("The value is {ele}", ele = element);
}
for element in array.iter() {
    println!("The value is {ele}", ele = element);
}
// 取值范围为[1..10)，rev表示反序输出
for ele in (1..10).rev() {
    println!("The element is {ele}", ele = ele);
}
// 取值范围为[1..10]
for ele in (1..=10).rev() {
    println!("The element is {ele}", ele = ele);
}
\end{code-block}

\section{所有权与slice}
Rust当中没有垃圾回收机制，因此，不存在“万恶的GC时间”。但是，Rust采用了所有权
这一特点来解决垃圾回收的问题。对于同一个对象（符合数据类型），同一时间只有一个变量可以持有其
所有权，其他的变量无法使用。
\begin{code-block}{rust}
let a = String::from("hello");
let b = a; // a对象被转移给b，相当于a所代指的内存内容被转移给了b变量，a被清空
// a对象在此之后无法使用，已经被回收
// 如果还需要让a可以被继续使用，则上述操作应当变更为如下
/*
let a = String::from("hello");
let b = a.clone();
*/
\end{code-block}
为了能够同时使用多个变量对同一个对象进行操作和运算，Rust使用引用和切片来解决
这个问题。
\begin{code-block}{rust}
let a = String::from("hello");
let b = &a;
// a对象还可以继续使用
\end{code-block}

对于数组类型的引用操作，通常使用切片操作来实现。Rust的切片和Python当中的相同，
只是缺少了反向切片和负数切片。常见的切片类型，或者说经常使用切片操作的，就是
字符串String。字符串的切片类型是\&str，字符串操作函数通常的都是使用字符串切片
实现的，如下：
\begin{code-block}{rust}
fn main() {
    let my_string = String::from("hello world");
    let my_string_literal = "hello world";
    let copy_1 = first_word(&my_string[..]);
    let copy_2 = first_word(&my_string_literal);
    let copy_3 = first_word(my_string_literal);
}
fn first_word(s: &str) -> &str {
    return &s[..];
}
\end{code-block}
需要注意，字符串的字面量，实际就是字符串切片数据类型。

\section{数据类型}
Rust当中的数组稍微有些特殊，在定义的时候，可以指定数据类型和长度，也可以进行
自动推导，还可以使用简便定义的方式。其基本使用如下：
\begin{code-block}{rust}
// the same as let array: [u32; 5] = [1,2,3,4,5];
let array = [1, 2, 3, 4, 5];
// the same as let a = [3,3,3,3,3]
let a = [3; 5];
\end{code-block}

数组作为函数参数时，长度必须作为数组的一部分进行传递：
\begin{code-block}{rust}
fn show_array(array: [u32; 5]) {
    ...
}
\end{code-block}

数组元素的迭代可以使用两种方式：1种是直接迭代，一种是使用iter函数进行：
\begin{code-block}{rust}
for item in array.iter() {
    println!("{}", item);
}
for item in &array {
    println!("{}", item);
}
\end{code-block}
但是，数组是无法迭代的，能够直接迭代的是切片（slice），而数组的引用就是一个
slice。同样的，切片也是可以进行迭代的，如下示例：
\begin{code-block}{rust}
fn show_array(array: &[u32; 5]) {
    for item in array.iter() {
        println!("{}", item);
    }
    for item in array {
        println!("{}", item);
    }
}
\end{code-block}

同C++相同，Rust也提供了Vector数据类型，其基本的用法和C++类似：
\begin{code-block}{rust}
// 初始化空的vector
let mut v: Vec<i32> = Vec::new();
// 自动推导生成vector
let v1 = vec![1, 2, 3];
\end{code-block}

Vector默认只能存放相同类型的数据，无法存放不同的数据类型。如果遇到了需要存放
不同的数据类型，则通常使用vector+enum的方式进行实现：
\begin{code-block}{rust}
let ips = vec![
    IPADDR::V4(255, 255, 255, 254),
    IPADDR::V6(String::from("fe80::708f:7183:c02b:1758")),
];
\end{code-block}

Vector数据需要注意的是遍历操作。默认情况下，使用for-in结构对vector进行遍历
操作，操作的是vector的值，并不是vector的引用，所以，一旦遍历结束，则该vector
就无效了。如果并不是需要只对vector进行遍历，后续还有其他操作，则在遍历的时候，
一定要采用引用，如下：
\begin{code-block}{rust}
for ele in &ips {
    println!("{}", ele);
}
\end{code-block}

但是，并不是所有的对vector的访问操作都会引起移动，比如下方代码：
\begin{code-block}{rust}
let mut v_str = vec!["hello", "world", "nice"];
let third = v_str[2];
let four = v_str[3];
// 2018及其之前的版本中，上述两行执行之后，v_str的2/3位数据发生了移动，
// 因此，下面的代码会出错。
// 2021版本则不会再有该问题
trace!(
    "The read_only_vec is {:?} and third is {}, four is {}",
    v_str, third, four);
// 将不变的slice追加到可变的vec当中
let read_only_vec = vec!["lucifer", "garuda", "titans"];
v_str.extend_from_slice(&read_only_vec);
\end{code-block}

字符串是常用的数据类型，针对字符串，也有一些需要注意。默认的情况下，所有的
字符串字面量都是切片，不是字符串变量，但是可以转换成字符串：
\begin{code-block}{rust}
let s = String::from("char");
let r = "char".to_string();
\end{code-block}

字符串的拼接与Python类似，但是需要注意有略微的不同：
\begin{code-block}{rust}
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // 注意 s1 被移动了，不能继续使用
\end{code-block}

如果需要多次执行字符串的拼接，则最好使用format操作：
\begin{code-block}{rust}
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");
let s = format!("{}-{}-{}", s1, s2, s3);
\end{code-block}

字符串在Rust当中的本质是是一个 Vec<u8> 的封装，可以按照unicode的方式（字符）
进行处理，也可以按照原始字节（u8数据）的方式进行处理。
\begin{code-block}{rust}
// 按照字符类型处理
for c in "helllo".chars() {
    ...
}
// 按照字节进行处理
for b in "hello".bytes() {
    ... // 如果进行输出，则输出的都是223，123等类似的数字数据
}
\end{code-block}

Map（映射）是Rust的另外一种容器数据类型，和Python的字典很像，但是，Rust的map
的键只能是同种类型的，值也只能是同种类型的，无法像Python的字典一样的灵活。常
用的map主要是HashMap和BTreeMap。构建map数据可以使用new，也可以使用collect方法：
\begin{code-block}{rust}
use std::collections::HashMap;
let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);
let teams  = vec![String::from("Blue"), String::from("Yellow")];
let initial_scores = vec![10, 50];
// 将其他的类型组合成map
// HashMap<_, _> 类型注解是必要的，因为可能 collect 很多不同的数据结构，
// 而除非显式指定否则 Rust 无从得知你需要的类型。但是对于键和值的类型参数来说，
// 可以使用下划线占位，而 Rust 能够根据 vector 中数据的类型推断出 HashMap 所包含的类型
let scores1: HashMap<_, _> = teams.iter().zip(initial_scores.iter()).collect();
\end{code-block}

Map数据类型对于普通的数值类型数据，不会获取其所有权，但是，对于复合数据类型包括
String，都会获得相关的所有权，如下：
\begin{code-block}{rust}
let field_name = String::from("Favorite color");
let field_value = String::from("Blue");
let mut map = HashMap::new();
map.insert(field_name, field_value);
// 在此之后，field_name和field_value无法再被访问和使用。
\end{code-block}

Map元素的获取，可以直接采用[]进行，也可以采用get的方式：
\begin{code-block}{rust}
let team_name = String::from("Blue");
let score_num = scores[&team_name]
let score = scores.get(&team_name);
\end{code-block}
但需要注意，上述代码当中，score的类型为Some(T)，需要按照枚举Option的方式进行处理。

Map的迭代同样需要使用for-in循环，并且需要注意所有权的使用：
\begin{code-block}{rust}
for (key, value) in &scores {
    println!("{}: {}", key, value);
}
\end{code-block}

和Python有区别的是，Rust允许这样的一种操作：当只有map当中键不存在时，才进行插入，
否则什么也不做：
\begin{code-block}{rust}
scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50);
\end{code-block}

\section{复杂数据类型}
\subsection{结构体}
Rust的结构体和Golang的结构体非常类似，直接使用struct关键字进行定义。
\begin{code-block}{rust}
struct User {
    username: String,
    age: u8,
    email: String,
    activate: bool,
}
\end{code-block}
结构体的初始化操作也类似Golang，如下：
\begin{code-block}{rust}
let user = User {
    username: String::from("zhangjl"),
    age: 32,
    email: String::from("zhangjl@awcloud.com"),
    activate: true,
};
\end{code-block}
如果已经有一个结构体实例，可以直接从已有的实例当中继承部分的属性：
\begin{code-block}{rust}
let user = User {
    username: String::from("zhangjl"),
    email: String::from("zhangjl@awcloud.com"),
    ..user
};
\end{code-block}

上述的结构体，由于每个字段都有名称，可以称之为命名结构体，而Rust当中，也支持
没有字段名称的结构体，称之为无名结构体，或者匿名结构体。这种类型的结构体，通
常是类似于元组的形式，如下：
\begin{code-block}{rust}
struct Color(u8, u8, u8);
fn show_color(color: &Color) {
    println!(
        "The RGB value is R:{}, G:{}, B:{}",
        color.0, color.1, color.2
    );
}
\end{code-block}
同样的，Rust也存在一种特殊的结构体：空结构，其形式基本如下：
\begin{code-block}{rust}
struct Empty();
\end{code-block}

Rust当中的struct实际和C++/Java当中的类（class）非常类似，都是对象类型，必然
有属于自己的函数（方法）。通常的，Rust的struct的函数需要使用impl关键字进行
定义和实现，其示例如下：
\begin{code-block}{rust}
impl User {
    fn show(&self) {
        println!(
            "The user info is: Name: {}, Age: {}, email: {}, and activate: {}",
            self.username, self.age, self.email, self.activate
        );
    }

    fn create() -> User {
        return User {
            username: String::from(""),
            age: 0,
            email: String::from(""),
            activate: false,
        };
    }
}
\end{code-block}
上述例子当中，show是结构体User的方法（method），可以直接使用User的实例进行调
用，而create则是一个独特的函数，表示隶属于User这个结构体，需要使用作用域符号
::进行调用，类似于C++/Java当中的构造函数，在Rust当中称之为关联函数。使用示例
如下所示：
\begin{code-block}{rust}
let new_user = User::create();
new_user.show();
\end{code-block}

\subsection{枚举与match}
Rust当中的枚举类型相当强大，和C/C++当中的枚举不一样，Rust的枚举元素可以是任意
类型，甚至可以类似于结构体，拥有自己的方法。普通的枚举定义方式如下：
\begin{code-block}{rust}
enum IpAddrKind {
    V4,
    V6,
}
\end{code-block}
通常情况下，枚举的使用也很简单，如下示例：
\begin{code-block}{rust}
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
\end{code-block}
这样的使用，与C/C++当中的枚举使用方式基本一致，只是用于作为标志量进行传递。

如果需要根据枚举的元素进行相关的数值转换或者获取，则需要使用match进行操作，
如下：
\begin{code-block}{rust}
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
\end{code-block}

在Rust当中，还有更为高级的用法，将枚举作为特殊的结构体，同样的，枚举类型也
可以拥有自己的方法，关联方法以及特殊的格式化输出方法等等。
\begin{code-block}{rust}
use std::fmt;
enum IPADDR {
    V4(u8, u8, u8, u8),
    V6(String),
}
impl IPADDR {
    fn show(&self) {
        match self {
            IPADDR::V4(a, b, c, d) => println!(
                "This is the ipv4 addr {}.{}.{}.{}", a, b, c, d),
            IPADDR::V6(v6) => println!("The V6 addr is ipv6 addr {}", v6),
        }
    }
    fn format(&self) -> String {
        match self {
            IPADDR::V4(a, b, c, d) => {
                let _v4 = format!("{}.{}.{}.{}", a, b, c, d);
                _v4
            }
            IPADDR::V6(v6) => v6.to_string(),
        }
    }
}
impl fmt::Display for IPADDR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            IPADDR::V4(a, b, c, d) => write!(f, "{}.{}.{}.{}", a, b, c, d),
            IPADDR::V6(v6) => write!(f, "{}", v6.to_string()),
        }
    }
}
\end{code-block}
在使用复杂的枚举类型时，match是一个非常
重要的操作。使用这种类型的枚举时，如同普通的struct一样的使用：
\begin{code-block}{rust}
let addr = IPADDR::V4(127, 0, 0, 1);
let addr_v6 = IPADDR::V6(String::from("fe80::708f:7183:c02b:1758"));
addr.show();
addr_v6.show();
println!("{}", addr);
\end{code-block}

Rust的枚举类型可以嵌套各种其他的类型，包括枚举类型本身。一个设计良好的枚举
类型通常可能包括了各种数据类型：
\begin{code-block}{rust}
enum Message {
    Quit, // 没有包含任何数据类型，相当于空结构体
    Move { x: i32, y: i32 }, // 匿名结构体
    Write(String), // 类元组结构体
    ChangeColor(i32, i32, i32), // 类元组结构体
}

impl Message {
    fn call(&self) {
        match self {
            Message::Quit => println!("Received the quit signal, exiting..."),
            Message::Move { x, y } => println!("Move a to {}, {}", x, y),
            Message::Write(_str) => println!("Write message {}", _str),
            Message::ChangeColor(a, b, c) =>
                println!("Change the color to {}, {}, {}", a, b, c),
        }
    }
}
\end{code-block}
上述枚举类型的使用示例如下：
\begin{code-block}{rust}
let mut msg = Message::Quit;
msg.call();
msg = Message::Move { x: 100, y: 200 };
msg.call();
msg = Message::Write(String::from("zhangjl"));
msg.call();
msg = Message::ChangeColor(255, 0, 0);
msg.call();
\end{code-block}

除了这些常规的和自定义的枚举类型之外，Rust还提供了一个非常常用的特殊枚举类型：
Option。Option的实际实现非常简单：
\begin{code-block}{rust}
enum Option<T> {
    Some(T),
    None,
}
\end{code-block}
Option通常和Some、None、match一起使用。需要说明的是，Rust当中并没有普通意义上
的NULL或者None，无法像C/C++一样，将NULL或者None赋值给指针，因为Rust当中没有
指针的概念。None在Rust当中，同样表示空，但是，是作为Option的一种有效的数据
形式使用。Option的使用如下：
\begin{code-block}{rust}
let x: Option<i8> = None
let y: Option<i8> = Some(5);
\end{code-block}
注意，Some数据类型无法直接和其他的数据类型进行直接的计算，必须进行拆包才可
正常使用，其使用示例如下：
\begin{code-block}{rust}
fn plus(x: Option<u8>) -> Option<u8> {
    match x {
       None => None,
       Some(i) => Some(i + 1),
    }
}
let six = plus(Some(5));
let six_num = six.unwrap();
let none_type = plus(None);
let none_value = none_type.unwrap_or_default();
\end{code-block}

Match可以匹配多个条件，但是，如果只需要匹配个别的情况，即需要忽略一些情况，则
需要使用通配符进行处理，通配符为\_，其基本使用如下：
\begin{code-block}{rust}
let some_u8_value = 0u8;
match some_u8_value {
    1 => println!("one"),
    3 => println!("three"),
    5 => println!("five"),
    7 => println!("seven"),
    _ => (),
}
\end{code-block}
如果本身的情况很少，只需要考虑2种情况，使用match则显得比较罗嗦，可以使用if-let
结构，该结构使用示例如下：
\begin{code-block}{rust}
if let Some(3) = some_u8_value {
    println!("three");
}
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {:?}!", state);
} else {
    count += 1;
}
\end{code-block}

同样的，match也可以和其他的数据类型一起使用：
\begin{code-block}{rust}
let v = vec![1, 2, 3];
// 从集合vector当中获取索引标记的数据
let ele = match v.get(1) {
    // Some(&ref)，即some当中的参数永远是引用数据类型
    Some(val) => *val,
    None => 0,
};
println!("{}", ele);
\end{code-block}

关于match的用法，还有很多，并且多数和模式匹配有关，接下来可以看一些常见的match和模式匹配的使用方式。
\begin{outline}[enumerate]
\1 多种匹配模式

在match表达式当中，可以用|匹配多个模式，表示或运算：
\begin{code-block}{rust}
let x = 1;
match x {
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
}
\end{code-block}

\1 使用..=匹配范围

..=语法允许匹配一个数值范围内的任意数据，常用于数值和字符：
\begin{code-block}{rust}
let x = 5;
match x {
    1..=5 => println!("one through five"),
    _ => println!("something else"),
}

let y = 'c';
match y {
    'a'..='j' => println!("early ASCII letter"),
    'k'..='z' => println!("late ASCII letter"),
    _ => println!("something else"),
}
\end{code-block}

\1 解构结构体

Let模式可以将结构体当中的字段/元素进行解构，单独或者批量赋予其他元素：
\begin{code-block}{rust}
struct Point {
    x: i32,
    y: i32,
}
fn main() {
    let p = Point { x: 0, y: 7 };
    // 将p的x字段的值赋予a，y字段的值赋予b，a和b是整数类型，不是引用
    let Point { x: a, y: b } = p;
    // let Point {x: ref a, y: ref b} = p; 和上面类似，但是a和b是整数类型的引用
    // let Point {x: a, y: _} = p; 表示只需要将x的值赋予a，但不需要对y进行解构
    assert_eq!(0, a);
    assert_eq!(7, b);
    // let Point {x, y} = p; 将p的x字段的值赋予变量x，y字段的值赋予变量y
}
\end{code-block}

\1 解构枚举类型

Match本身就是应枚举而生的，因此天然的可以使用它对枚举进行解构：
\begin{code-block}{rust}
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
fn main() {
    let msg = Message::ChangeColor(0, 160, 255);
    match msg {
        Message::Quit => {
            println!("The Quit variant has no data to destructure.")
        }
        Message::Move { x, y } => {
            println!("Move in the x direction {} and in the y direction {}", x, y);
        }
        Message::Write(text) => println!("Text message: {}", text),
        Message::ChangeColor(r, g, b) => {
            println!("Change the color to red {}, green {}, and blue {}", r, g, b)
        }
    }
}
\end{code-block}

同样的，如果枚举当中嵌套了枚举，仍然可以使用match进行解构：
\begin{code-block}{rust}
enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}
fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));
    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) => {
            println!("Change the color to red {}, green {}, and blue {}", r, g, b)
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) => {
            println!(
                "Change the color to hue {}, saturation {}, and value {}",
                h, s, v
            )
        }
        _ => (),
    }
}
\end{code-block}

\1 解构复合数据

用复杂的方式来混合、匹配和嵌套解构模式，解析出我们感兴趣的数据：
\begin{code-block}{rust}
let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });
\end{code-block}

\1 忽略不需要的元素

在Rust的当中，默认可以使用\_对不必要的变量进行忽略，通常用在match的最后分支，但是，
实际上也可以用去其他任意的模式，甚至是函数参数：
\begin{code-block}{rust}
// 需要传入2个参数，但是忽略第一个参数
fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {}", y);
}
fn main() {
    foo(3, 4);
}
\end{code-block}

除了使用\_进行忽略之外，还可以使用..语法糖进行忽略，但是针对结构体和元组存在区别：
结构体当中，忽略的是没有被列出的字段；而元组忽略的则是范围：
\begin{code-block}{rust}
struct Point {
    x: i32,
    y: i32,
    z: i32,
}
fn main() {
    let origin = Point { x: 0, y: 0, z: 0 };
    // 将point的y进行忽略
    match origin {
        Point { x,z, .. } => println!("x is {}, z is {}", x, z),
    }
    let numbers = (2, 4, 8, 16, 32);
    match numbers {
        // 忽略元组当中除第1、2和最后一项的所有元素
        (first, second, .., last) => {
            println!("Some numbers: {}, {}, {}, ", first, second, last);
        }
    }
}
\end{code-block}

同样的，忽略操作也可以用于闭包当中：
\begin{code-block}{rust}
let player_scores = [("Jack", 20), ("Jane", 23), ("Jill", 18), ("John", 19)];
// 对player_scores进行迭代，忽略其中第二个元素，_可以被替换为_score
let players: Vec<_> = player_scores.iter().map(|&(player, _)| player).collect();
// 输出的结果当中将只会有字符串数据
println!("{:?}", players);
\end{code-block}

\1 @绑定

运算符@允许我们在创建一个存放值的变量的同时测试其值是否匹配模式，比如测试字段是
否位于指定范围内，同时也希望能将其值绑定到另外的变量中以便此分支相关联的代码可以
使用它：
\begin{code-block}{rust}
enum Message {
    Hello { id: i32 },
}
let msg = Message::Hello { id: 5 };
match msg {
    // 将变量id保存到另一个变量ip_variable当中
    Message::Hello { id: id_variable @ 3..=7 } => {
        println!("Found an id in range: {}", id_variable)
    },
    Message::Hello { id: 10..=12 } => {
        println!("Found an id in another range")
    },
    Message::Hello { id } => {
        println!("Found some other id: {}", id)
    },
}
\end{code-block}
\end{outline}

\section{包/模块管理}
在大型项目当中，Rust同样提供了代码的管理机制。和Python、Golang等不同，Rust的
代码管理可以分为包（crate）和模块（mod）。这2种模式有不少的区别。Mod模式类似
于Python的管理方式，而crate则是另外一种管理方式。这2种方式可以相互嵌套使用。
在使用这2种方式之前，需要知道一个概念：Rust的路径寻找永远是从最顶层开始，即
与Cargo.toml同级的src下开始。Src路径，被称之为crate路径，即根路径。一切从crate
开始的路径，都称之为绝对路径；其他的方式，则称之为相对路径。

\subsection{Mod管理模式}
Mod管理模式和Python/Golang的路径管理类似，直接从当前工程的src路径一直往下进行
查找，直到最终找到。首先看一个Rust工程结构, 如下图\colorunderlineref{fig:rust_mod}所示。
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_mod.png}
  \caption{Mod管理模式}
  \label{fig:rust_mod}
\end{figure}
其中，有几个特点：
\begin{enumerate}
  \item 从文件层次结构上，logging.rs、main.rs、common.rs、common、compute和
utils为同一层级，但是只有 main属于crate，其他都是属于crate管辖的范围，即在
逻辑上，logging.rs、compute、utils、common和common.rs属于main的下级模块
  \item compute和utils无法直接使用，只能使用这2个目录下的模块（文件）
\end{enumerate}

如果logging模块不需要使用其他模块，则内部无需特别的处理，其代码如下：
\begin{code-block}{rust}
pub fn logging() {
    println!("This is the logging function");
}
\end{code-block}
由于main属于crate，logging归属crate管理，相当于是logging是main的子模块，因此
在main当中，只能使用相对路径访问logging，不能使用crate的绝对路径，其使用方式
如下：
\begin{code-block}{rust}
mod logging;
// 模块别名
use logging as log;
\end{code-block}
在使用模块的时候，一定注意，mod关键字必须放在use之前。而common和logging属于
相同的层次，如果在common当中需要使用logging模块，则必须使用全路径crate。如果
如同在main当中使用logging一样
\begin{code-block}{rust}
// common.rs
mod logging;

// 同样是错误的代码
// mod crate::logging;
\end{code-block}
则会出现下列错误：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_mod_error1.png}
  \caption{模块错误1}
  \label{fig:rust_mod_error1}
\end{figure}
而正确的使用方式（全路径）则如下：
\begin{code-block}{rust}
// common.rs
use crate::logging;
\end{code-block}

如果强行需要在common.rs文件当中，以相对路径的方式使用logging，则必须将logging.rs
模块放到common当中，即按照上述的错误提示，将logging作为common的一个子模块。
只有父模块可以通过相对路径的方式访问子模块，平级模块之间，或者没有亲缘关系
的模块之间，只能通过绝对路径的方式使用。

在上述的代码当中，有一个比较奇怪的现象：同时存在common和common.rs。这是Rust
管理的一种模式。默认情况下，Rust的模块有2种模式：文件形式和文件夹形式。
文件夹形式实际上就是将一个文件夹作为Rust的模块进行使用。通常情况下，文件夹
模式的模块形式如下：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_mod_directory.png}
  \caption{文件夹模块}
  \label{fig:rust_mod_directory}
\end{figure}
其中，nova.rs当中的内容和普通的Rust文件类似，基本如下：
\begin{code-block}{rust}
// nova.rs
pub fn nova() {
    println!("This is the nova function");
}
\end{code-block}
重点是mod.rs这个文件。该文件实际上是用于定义/暴露compute这个文件夹当中的模块。
如果compute文件夹缺少mod.rs，则compute无法被识别成一个合法的Rust模块，即无法
使用compute当中的任何代码。而mod.rs的内容比较特殊，和nova.rs的内容并不一致，
其内容大致如下：
\begin{code-block}{rust}
// mod.rs
pub mod nova;
pub mod driver;
\end{code-block}
通过上述的代码，将nova.rs作为一个可供外部使用模块。同样的，由于nova.rs和
drvier.rs属于同级目录，如果需要在nova.rs当中使用driver.rs所提供的功能，则
需要使用绝对路径的方式对其进行引用：
\begin{code-block}{rust}
// nova.rs
use crate::compute::driver;
\end{code-block}

同名文件和文件夹的模式，则是另外一种模块的管理方法。这种管理方式，其文件组织
形式如下：
\begin{figure}[H]
  \centering
  %\includegraphics[scale=0.6]{rust_mod_file.png}
  \includegraphics[width=\linewidth]{rust_mod_file.png}
  \caption{同名文件形式}
  \label{fig:rust_mod_file}
\end{figure}
在这种模式下，calc.rs的内容和普通的相同，而重点在于外部的common.rs。该文件的
功能实际上和上述所说的mod.rs类似，都是用于暴露模块的。该文件的内容大致如下：
\begin{code-block}{rust}
// common.rs
pub mod calc; // 将calc.rs当中的内容进行导出
use crate::logging;
fn common() { logging::logging(); }
\end{code-block}

将上述的概念和技术进行整合，整体的工程文件内容大致如下：
\begin{code-block}{rust}
// common.rs
pub mod calc;
use crate::logging;
fn common() { logging::logging(); }
// common/calc.rs
pub fn add() { println!("This is the add function"); }
// compute/driver.rs
pub fn call() { println!("This is the driver::call function"); }
// compute/nova.rs
use crate::compute::driver;
use crate::logging;
use crate::utils::tools;
pub fn nova() { println!("This is the nova function"); }
pub fn use_parent() {
    logging::logging();
}
pub fn use_other() {
    println!("Use the logging function in child mod");
    tools::execute();
}
pub fn deive() { driver::call(); }
// compute/mod.rs
pub mod driver;
pub mod nova;
// logging.rs
pub fn logging() { println!("This is the logging function"); }
// utils/tools.rs
use crate::logging as log;
pub fn execute() { log::logging(); }
pub mod tools;
// main.rs
mod common;
mod compute;
mod logging;
mod utils;
use common as com;
use compute::nova;
use logging as log;
use utils::tools;
fn main() {
    log::logging();
    nova::nova();
    nova::use_other();
    nova::use_parent();
    tools::execute();
    com::calc::add();
}
\end{code-block}

\subsection{Crate管理模式}
Crate管理模式通常用于在自己的Rust代码当中引用别人的代码或者类库，可以管理其他人的公开代码，
也可以管理自己编写的类库代码。

\subsubsection{使用第三方代码}
一般方式下，需要修改Rust工程的Cargo.toml文件，在dependencies段当中加入需要使用
的类库名称，如下：
\begin{code-block}{toml}
[dependencies]
regex = "0.1.41"
\end{code-block}
然后，在自己的代码当中添加如下的语句：
\begin{code-block}{rust}
use regex::Regex;
fn main() {
    let re = Regex::new(r"^\d{4}-\d{2}-\d{2}$").unwrap();
    println!("Did our date match? {}", re.is_match("2014-01-01"));
}
\end{code-block}
运行cargo build指令时，会直接从cargo.io进行下载。

如果需要使用的依赖库并不在cargo.io，而是放在了类似于github等地方，也可以修改
Cargo.toml文件，类似如下：
\begin{code-block}{toml}
[dependencies]
# 可以和包不同名，也可以同名
my_rust_lib_1={package="my_lib_1",git="ssh://git@github.com/lpxxn/my_rust_lib_1.git",tag="v0.0.2"}
my_rust_lib_2={package="my_lib_1",git="https://github.com/lpxxn/my_rust_lib_2.git",branch="master"}
\end{code-block}
运行cargo build指令时，同样会去github等代码管理仓库下载指定的依赖代码。Crate模式不仅可以管理外部第三方依赖代码，
同样可以用于管理本地的代码。

\subsubsection{Crate管理本地代码}
在使用这种方式之前，先了解一下crate的一些概念\footnote{来源：\url{https://www.cnblogs.com/li-peng/p/13587910.html}}。
\begin{itemize}
  \item 包是cargo的一个功能，当执行cargo new xxxx的时候就是创建了一个包。
  \item crate是二进制或者库项目。rust约定在Cargo.toml的同级目录下包含src目录
并且包含main.rs文件，就是与包同名的二进制crate，如果包目录中包含src/lib.rs，
就是与包同名的库crate
  \item 包内可以有多crate，多个crates就是一个模块的树形结构
  \item 如果一个包内同时包含src/main.rs和src/lib.rs，那么他就有两个crate，
如果想有多个二进制crate，rust约定需要将文件放在src/bin目录下，每个文件就是
一个单独的crate
  \item crate根用来描述如何构建crate的文件。比如src/main.rs或者src/lib.rs就
是crate根。crate根文件将由Cargo传递给rustc来实际构建库或者二进制项目
  \item 带有Cargo.toml文件的包用来描述如何构建crate，一个包可以最多有一个库
crate，任意多个二进制crate。
\end{itemize}

包含多个二进制crate的Rust项目大致如下：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_more_bin.png}
  \caption{多个二进制}
  \label{fig:rust_more_bin}
\end{figure}
对这个项目进行编译，将会得到2个二进制文件：first和second，而不再是之前的和
根路径同名，得到的结果类似下面。但是需要注意可能出现的问题\footnote{错误描述：\url{https://rustcc.cn/article?id=dcc947c4-21a9-4ba0-ba59-43f6b580aae6}} ：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_more_bin_res.png}
  \caption{多个二进制编译结果}
  \label{fig:rust_more_bin_res}
\end{figure}
\begin{warn}
在使用多个binary的模式时，要特别注意，如果bin目录当中的代码需要使用src目录（即顶层目录当中）
当中的代码，则有可能出现错误。解决的方法比较讨巧：所有的binary源代码文件不放在bin目录当中，
而是直接放在src下，然后通过toml文件的bin段进行指定，如下：
\begin{code-block}{toml}
[[bin]]
name = "server"
path = "src/server_bin.rs"
[[bin]]
name = "tools"
path = "src/tools_bin.rs"
\end{code-block}

整个的目录结构大致如下：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_multi_bin.png}
  \caption{多个二进制编译}
  \label{fig:rust_multi_bin}
\end{figure}
\end{warn}

创建一个包含lib的Rust项目，则稍微有些区别，首先创建一个二进制的crate：
\begin{code-block}{bash}
cargo new projects
\end{code-block}
然后，在这个二进制的crate当中，创建一个lib：
\begin{code-block}{bash}
cd projects
cargo new --lib first
\end{code-block}
同样的，可以在这个二进制的crate当中，创建多个lib，最后的文件结构大致如下：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_lib.png}
  \caption{Lib形式的crate}
  \label{fig:rust_lib}
\end{figure}

到目前为止，src当中的代码是无法使用first和second当中的代码的，而且，first和
second这2个路径当中的代码，也并不是合法并可用的Rust lib库。首先需要解决的，
就是使得first和second成为合法的Rust lib库。在first和second这2个文件夹当中，
不再拥有mod.rs，取而代之的则是lib.rs，需要在lib.rs的同级或者下级目录，添加
合法的rs文件，然后，在lib.rs使用pub对这些模块进行导出。以first这个lib为例，
其src目录下的文件，内容应当大致如下：
\begin{code-block}{rust}
// constants.rs
pub enum VERSION {
    V4,
    V6,
}
// lib.rs
pub mod constants;
\end{code-block}

经过以上的改写之后，first便成为了一个合法可用的Rust lib库。如果需要在顶层的
main.rs当中使用这个lib库，还需要修改顶层Cargo.toml的内容，将first作为二进制
crate的依赖：
\begin{code-block}{toml}
[dependencies]
# path表示lib库的路径，version则是lib库的Cargo.toml当中所包含的version
first = { path = "first", version = "0.1.0" }
second = { path = "second", version = "0.1.0" }
\end{code-block}

通过上述的修改，则可以在二进制crate当中，使用first和second这2个lib库了。
\begin{code-block}{rust}
use first::constants;
use second::status;
\end{code-block}

有的时候，为了更加清晰的描述当前的crate与其他crate的关系，可以直接使用extern
进行标记：
\begin{code-block}{rust}
extern crate first;
extern crate second;
use first::constants;
use second::status;
\end{code-block}

如果lib之间存在依赖关系，同样可以在lib的Cargo.toml当中添加相关的依赖关系。
比如，假设second依赖于first模块，则可以在second的Cargo.toml当中添加如下内容：
\begin{code-block}{toml}
[dependencies]
first = { path = "../first", version = "0.1.0" }
\end{code-block}

然后，直接在second的代码当中使用first的内容即可。同样的，在second当中使用first
的内容，可以参考下面的案例：
\begin{code-block}{rust}
extern crate first;
use first;
\end{code-block}

相比于mod模式，crate模式更加清晰一些。

\subsection{大规模的管理方式——workspace}
上述的2种模块管理方式，解决了路径查找的问题。但是，如果是针对大型项目，特别是
代码量类似于OpenStack这种规模的，mod和crate模式都有些难以管理。这时，就需要
使用workspace的方式进行管理。Workspaces的方式，实际上是对mod和crate的综合和
高层次总结，其使用方式大致如下：

\begin{outline}[enumerate]
\1 创建工作目录
\begin{code-block}{bash}
mkdir works
\end{code-block}

\1 创建需要的crate
\begin{code-block}{bash}
cargo new first --bin
cargo new second --bin
cargo new shared --lib
\end{code-block}

\1 创建工作管理的Cargo.toml文件
\begin{code-block}{bash}
cat >Cargo.toml<<EOF
[workspace]
members = [ "first", "second", "shared"]
EOF
\end{code-block}

\1 编译所有的crate
\begin{code-block}{bash}
cargo build
# 或者
# cargo build --workspace
\end{code-block}

\1 编译指定的bin crate
\begin{code-block}{bash}
cargo build --bin first
\end{code-block}

\1 编译指定的包
\begin{code-block}{bash}
cargo build --package first
\end{code-block}
\end{outline}

到目前为止，first和second为2个bin类型的crate，可以直接编译运行，而shared则是
一个lib库，并且，上述3个crate之间没有任何关联。如果first和second需要使用shared
当中的模块，则对应的，需要在first以及second目录下的Cargo.toml添加类似的如下
内容：
\begin{code-block}{toml}
[dependencies]
shared = { path = "../shared" , version = "0.1.0"}
\end{code-block}

然后修改second的main.rs如下即可：
\begin{code-block}{rust}
extern crate shared;
use shared::utils;
\end{code-block}
随后按照之前的方式进行编译和使用即可。

\subsection{小规模工程管理的其他方式}
有的时候项目规模并不大，可以不使用crate和mod方式，而是使用lib方式进行管理。现在
有这样一个小的工程，名称为minigrep：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_lib_mod.png}
  \caption{Lib模式的小项目}
  \label{fig:rust_lib_mod}
\end{figure}
其中，common和utils这2个文件夹仍然同原来的mod模式一样，但是，在顶层的src文件夹当中，
多了一个lib.rs文件。而lib.rs的内容可能如下：
\begin{code-block}{rust}
pub mod common;
pub mod logging;
pub mod utils;
pub struct Config { }
pub fn xxx { }
\end{code-block}
即，相当于使用lib.rs将除main.rs之外的所有文件夹和文件进行暴露，则在main.rs当中，
就可以不再使用crate的方式进行模块的查找和搜索，而是直接使用minigrep当作顶层路径：
\begin{code-block}{rust}
use minigrep::logging;
use minigrep::utils::tools;
use minigrep::Config;
\end{code-block}

但是需要注意，如果在common和utils当中，需要使用比如logging或者common或者utils，则
还是只能通过mod的方式，即使用crate作为顶层搜索路径。另外，与main.rs统计的lib.rs
不能变更为mod.rs，同样的，utils和common当中的mod.rs不能变更为lib.rs，否则会找不到
相关的模块。

\subsection{模块管理的其他注意事项}

\begin{outline}[enumerate]
\1 提升命名空间

有的时候，Rust的代码层级非常深，比如下面：
\begin{code-block}{rust}
pub mod english {
    pub mod greetings {
        pub fn hello() { ...  }
        pub fn hey_guies() { ...  }
    }
}
\end{code-block}
如果我们需要使用hello这个方法，则可能的方式多半如下：
\begin{code-block}{rust}
english::greetings::hello();
\end{code-block}
如果想将hello方法的访问缩短路径，则需要对代码进行改动：
\begin{code-block}{rust}
pub mod english {
    pub mod greetings {
        pub fn hello() {...}
        pub fn hey_guies() {...}
    }
    pub use self::greetings::hello; // 将hello提升到english::hello
}
pub use english::greetings::hello; // 将hello提升到lib::hello
\end{code-block}
经过上述修改之后，使用的时候，可以按照下面的方式进行使用：
\begin{code-block}{rust}
lib::chinese::hello(); // 对应pub use self::greetings::hello
lib::hello(); // 对应 pub use english::greetings::hello;
\end{code-block}

\1 examples的使用

有的时候，Rust代码只是作为类库使用，并不需要自身包含bin文件，此时，在src目录下
专门放一个bin目录作为测试是一种可行的方式，在代码文件当中编写test测试代码也是
一种合理的方式，不过，还有另外的一种方式：examples。在目录结构上，Cargo的examples
与src同级，一个简单的示例如下：
\begin{center}
  \includegraphics[width=\linewidth]{rust_cargo_examples.png}
  \captionof{figure}{Examples的目录结构}
  \label{fig:rust_cargo_examples}
\end{center}

Examples当中的代码可以直接将src所在的目录或者src所代表的package直接当做第三方
的crate使用：
\begin{center}
  \includegraphics[width=\linewidth]{rust_cargo_examples_src.png}
  \captionof{figure}{使用src做为examples的依赖}
  \label{fig:rust_cargo_examples_src}
\end{center}
并且，可以使用src的\codeinline{toml}{[dependencies]}段当中的所有依赖库而无需重新声明，
如果一些依赖库只是examples需要，则可以将这部分的依赖库放到\codeinline{toml}{[dev-dependencies]}
这个段当中，如下：
\begin{code-block}{toml}
[dev-dependencies]
env_logger = "0.5"
\end{code-block}
而编译examples的命令与之前有些类似，只是需要多加一些参数而已：\codeinlinebg{bash}{cargo build --examples --release}

\end{outline}

\section{格式化输出}
默认情况下，对于普通的数据类型（数值，字符，bool），Rust可以直接使用print语句
进行输出，但是，对于复合数据类型，比如自定义的结构体，数组等，直接使用print
则无法进行直接输出。为了直接输出这些数据，Rust提供了debug宏进行操作，允许直接
对复合数据类型进行格式化输出，如下所示：
\begin{code-block}{rust}
#[derive(Debug)]// 使用注解，启用debug特性，使之可以利用:?进行输出
struct Rectangle { width: u32, height: u32, }
fn main() { let rect1 = Rectangle { width: 30, height: 50 };
    println!("rect1 is {:?}", rect1);
}
\end{code-block}

不过Rust提供了另外的格式化输出机制——即Trait Display。数据类型可通过实现该Trait，即可直接使用print语句进行输出。其示例如下：
\begin{code-block}{rust}
use std::fmt;
struct User { username: String, age: u8, email: String, activate: bool }
impl fmt::Display for User {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!( f, "Name:{}, Age: {}, Email: {}, Activate: {}",
            self.username, self.age, self.email, self.activate)
    }
}
fn main() {
    let new_user = User::create(); println!("User: {}", new_user);
}
\end{code-block}

默认情况下，Rust提供了常用的格式化输出函数，主要有如下的几个:
\begin{enumerate}
  \item format!：将数据格式化成String对象
  \item print!：将数据格式化后输出到标准输出
  \item println!：类似print!，只是会追加换行操作
  \item eprint!：同print!，只是输出到标准的错误输出
  \item eprintln!：同eprint!，只是会追加换行操作
\end{enumerate}
具体使用如下：
\begin{code-block}{rust}
println!( "The counter result is {counter} , and age is {age}",
    age = 100, counter = counter);// 根据名称进行输出
println!("{0}, {1}", "zhangjl", 18);// 根据位置进行输出
// 设置数据的显示宽度为6，向右对齐，不足的部分显示为空，同理，<则表示向左对齐
println!("{number:>width$}", number = 100, width = 6);
// 设置数据的显示宽度为6，向右对齐，不足的部分显示为0
println!("{number:>0width$}", number = 100, width = 6);
\end{code-block}
\section{错误处理}
Rust的错误主要分为可恢复的和不可恢复的，其处理机制也分为panic
和Result模式。默认的情况下，panic模式会打印程序的堆栈信息，并且清理堆栈数据，
这样会造成生成的二进制程序比较大。但可以使用abort终止堆栈信息的展开：
\begin{code-block}{toml}
[profile.release]
panic = "abort"
\end{code-block}

如果需要展开所有的堆栈信息，则可如下进行操作：
\begin{code-block}{bash}
RUST_BACKTRACE=1 cargo run
RUST_BACKTRACE=full cargo run #全展开
\end{code-block}
则得到的效果可能如下：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_err_panic_trace.png}
  \caption{错误堆栈}
  \label{fig:rust_err_panic_trace}
\end{figure}

通常而言，panic处理的错误都是不可恢复的，而如果是需要继续运行的，或者对应的错误
是可以进行处理的，则通常采用Result进行处理。Result是另外一个常用的enum类型，其定
义如下：
\begin{code-block}{rust}
enum Result<T, E> {
    Ok(T),
    Err(E),
}
\end{code-block}
其中，T和E都是泛型数据，而T表示正常运行时返回的数据，E表示返回的错误类型数据。

比如常见的打开文件操作，就可以使用Result进行错误处理：
\begin{code-block}{rust}
use std::fs::File;
fn main() {
    let f = File::open("hello.txt");
    let f = match f {
        Ok(file) => file,
        Err(error) => {
            panic!("Problem opening the file: {:?}", error)
        },
    };
}
\end{code-block}

错误是存在分类的，可以通过错误的类型，进行下一步的处理，比如，如果文件不存在，就
新建：
\begin{code-block}{rust}
use std::fs::File;
use std::io::ErrorKind;
fn main() {
    let fr = File::open("hello.txt");
    let f = match fr {
        Ok(file) => file,
        // 如果出现错误，就判断错误类型
        Err(error) => match error.kind() {
            // 如果错误类型是没有找到，就新建文件
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(err) => panic!("{:?}", err),
            },
            // 其他错误。other可以替换成其他的任意字符。如果不想处理，则
            // _ => (),
            other => panic!("{:?}", other),
        },
    };
}
\end{code-block}

如果Match的分支过多，有可能导致代码逻辑比较复杂，难以理解。因此，Result也提供了
一种简化的方式，同样的，功能会相对较弱一些：
\begin{code-block}{rust}
use std::fs::File;
fn main() {
    // 如果文件不存在，则直接panic，并输出堆栈信息
    let fr = File::open("hello.txt").unwrap();
    // 如果文件不存在，则直接panic，但是，输出的是自定义(expect包含的)的错误信息
    let f = File::open("hello.txt").expect("Failed to open hello.txt");
}
\end{code-block}

如果不是在main函数当中出现错误，有的时候，实际上需要接收相关的错误，再进行处理，
则可以使用Result进行。再次强调，Result是一个泛型的枚举类型。
\begin{code-block}{rust}
use std::fs::File;
use std::io::{Error, ErrorKind, Read};
fn main() {
    match read_file() {
       Ok(s) => println!("The content of file is {}", s),
       Err(error) => panic!("{:?}", error),
    };
    // 或者使用变量进行接收
    let res = match read_file() {
        Ok(s) => s,
        Err(err) => {
            println!("ERROR:{:?}", err);
            "".to_string()
        }
    };
}
// 如果该函数执行成功，调用者会受到一个Ok(String)，
// 否则，会接收到错误值
fn read_file() -> Result<String, Error> {
    let mut f = match File::open("Cargo.toml") {
        Ok(file) => file,
        Err(error) => return Err(error),
    };
    let mut s = String::new();
    let res = match f.read_to_string(&mut s) {
        Ok(_) => Ok(s),
        Err(err) => Err(err),
    };
    return res;
}
\end{code-block}

同样的，错误传递也可以进行简化，此时需要使用运算符?进行：
\begin{code-block}{rust}
fn read_file() -> Result<String, Error> {
    let mut f = File::open("hello.txt")?;
    let mut s = String::new();
    f.read_to_string(&mut s)?;
    Ok(s)
}
\end{code-block}
Result 值之后的?被定义为处理Result值的match表达式有着完全相同的工作方式。
如果Result的值是Ok，这个表达式将会返回Ok中的值而程序将继续执行。
如果值是Err，Err中的值将作为整个函数的返回值，就好像使用了return关键字一样，
这样错误值就被传播给了调用者。

?操作符大大简化了错误的处理流程，甚至于可以使用?进行链式调用，进一步简化代码：
\begin{code-block}{rust}
fn read_file() -> Result<String, Error> {
    let mut s = String::new();
    File::open("hello.txt")?.read_to_string(&mut s)?;
    Ok(s)
}
\end{code-block}

特别需要注意，?操作符只能用于返回类型为Result的函数当中，而main函数的返回类型是
()，不是Result，因此，直接在main函数当中使用?操作符则是错误的：
\begin{code-block}{rust}
fn main() {
    // 提示错误
    let f = File::open("hello.txt")?;
}
\end{code-block}
\input{rust_part_2}
