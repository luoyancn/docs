\chapter{Linux系统编程}

\section{IO函数}
Linux系统当中，通常需要处理IO，而IO的处理，在Linux的函数当中，主要有4个函数：
\begin{itemize}
  \item open //fcntl.h
  \item write //unistd.h
  \item read //unistd.h
  \item close //unistd.h
\end{itemize}

实现简单的touch命令的功能
\begin{code-block}{c}
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

int main(int argc, char * argv[])
{
        // 第3个参数可以直接写为0644
        int fd = open(argv[1], O_CREAT|O_WRONLY,
                S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
        if (0>fd)
        {
                printf("Cannot create file %s\n", argv[1]);
                return -1;
        }
        printf("Create file %s success\n", argv[1]);
        close(fd);
        return 0;
}
\end{code-block}

但是，由于Linux操作系统本身存在umask（默认为022），因此，如果上述的第3个参数写作0777，
生成的文件的权限与umask进行亦或计算之后，实际上，文件的权限还是755，并不是我们所期待的
777。如果需要保持设置的权限与生成的文件权限完全一致，需要执行如下命令：
\begin{code-block}{bash}
umask 000
# 后续再执行代码，生成文件
\end{code-block}

Open函数只能生成普通文件，如果是管道、字符设备之类的，则无法使用open函数进行创建。
另外，如果只是需要打开文件，并不是创建文件，则open函数的第3个参数不需要。
除此之外，还需要注意一下，文件的打开模式
\begin{itemize}
  \item O\_TRUNC：覆盖文件
  \item O\_EXCL : 与O\_CREAT合用，如果对应文件已经存在，则提示错误
\end{itemize}

Open函数一旦调用，Linux内核会在内核空间打开3个文件描述符，分别是0，1，2。

而对应的，也可以利用write函数向打开的文件句柄当中写入内容
\begin{code-block}{c}
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

int main(int argc, char * argv[])
{
        // 第3个参数可以直接写为0644
        int fd = open(argv[1], O_CREAT|O_RDWR,
                S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
        if (0>fd)
        {
                printf("Cannot create file %s\n", argv[1]);
                return -1;
        }
        printf("Create file %s success\n", argv[1]);

        char msg[] = "hello world";
        write(fd, msg, sizeof(msg)/sizeof(char)); //会写入一个文件结束符，特殊符号
                                                  // 如果不需要，则将长度-1即可
        close(fd);
        return 0;
}
\end{code-block}

相应的，也可以利用read函数读取打开文件的内容：
\begin{code-block}{c}
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>

int main(int argc, char * argv[])
{
        int fd = open(argv[1], O_RDONLY);
        if (0>fd)
        {
                printf("Cannot open file %s\n", argv[1]);
                return -1;
        }
        printf("Open file %s success\n", argv[1]);

        size_t read_ret = 0;
#if 0
        // 连续多次读取，并非一次性读完
        size_t total = 0;
        char readbuf[128];
        while ((read_ret=read(fd, readbuf, 127))>0) // 每次只能读取max-1，否则末尾存在特殊字符，可能出现溢出
        {
                total += read_ret;
                printf("Read %d chars \n", read_ret);
                printf("The content of file is %s \n", readbuf);
                memset(readbuf, 0, 128);
        }
        printf("The total sizeof file is %d\n", total);
#else
        // 一次性读取
        char readbuf[1024];
        read_ret=read(fd, readbuf, 1024);
        printf("Read %d chars \n", read_ret);
        printf("The content of file is %s \n", readbuf);
#endif
        close(fd);
        return 0;
}
\end{code-block}

高级一点的，我们就可以使用read和write函数来实现一个简单的文件拷贝功能。
\begin{code-block}{c}
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>

int main(int argc, char * argv[])
{
        int readrd = 0, writefd = 0;
        if (0 >= (readrd = open(argv[1], O_RDONLY)))
        {
                printf("Cannot open the source file %s\n", argv[1]);
                return -1;
        }
        if (0 >= (writefd = open(
                argv[2], O_CREAT|O_TRUNC|O_WRONLY, 0644)))
        {
                printf("Cannot create the target file %s\n", argv[2]);
                return -1;
        }

        unsigned char buffer[128];
        memset(buffer, 0, 128);

        size_t readret = 0, writeret = 0;
        while(0 < (readret = read(readrd, buffer, 127)))
        {
                if (0 > (writeret = write(writefd, buffer, readret)))
                {
                        printf("Cannot write content to write file\n");
                        return -1;
                }
                memset(buffer, 0, 128);
        }

        close(readrd);
        close(writefd);
        return 0;
}
\end{code-block}

由于读取使用的是unsigned char，因此，上述文件也可以直接拷贝二进制文件。
\section{文件属性}
每一个文件都存在属性，所谓的属性，包含了文件的打开状态，访问模式等等。而判断这些属性，则需要使用fcntl函数。
该函数的使用比较广泛，可以从各个层面来判断文件的状态和模式，参见下列代码：
\begin{code-block}{c}
#include <unistd.h>
#include <fcntl.h>
...
        int fd = 0;
        int flags = 0;
        int access_mode = 0;
        // 获取文件的打开状态
        if (-1 == (flags = fcntl(fd, F_GETFL))) {
                printf("Cannot get the file flags\n");
                goto fcntl_err;
        }

        // 判断文件的状态，是否已同步的方式打开
        if (flags & O_SYNC) {
                printf("File opened in sync mode\n");
        }

        // 获取并判断文件的访问模式
        if ( O_RDONLY == (access_mode = (flags & O_ACCMODE))) {
                printf("File is opened with read_only mode\n");
        }

        // 修改文件的状态
        flags |= O_APPEND;
        if ( -1 == (flags = fcntl(fd, F_SETFL, flags))) {
                printf("Cannot set the file flags\n");
                goto fcntl_err;
        }
...
\end{code-block}

\section{标准IO函数}
Linux的IO操作包括文件IO和标准IO。所谓的文件IO，即直接调用内核提供的系统调用函数，一般需要使用头文件unistd.h当中的函数；而
标准IO，则是通过调用C的库函数，间接的调用系统调用函数，通常的，使用的头文件stdio.h当中的函数。从功能上看，标准IO与文件IO是
相同的，但是，细节上，他们存在区别。
\begin{code-block}{c}
#include <stdio.h>
#include <unistd.h>

int main(int argc, char * argv[])
{
        char  buffer[] = "hello world";
        printf("stdio %s", buffer);
        write(1, buffer, 11);
        while(1);
        return 0;
}
\end{code-block}

上述代码编译之后，运行，只有hello world能够输出，而printf的stdio hello world则无法输出。问题在于缓存。
Linux程序当中存在几种缓存：
\begin{itemize}
  \item 用户空间缓存：即想从内核读写的数据，即上述代码当中buffer
  \item 内核空间缓存：没打开一个文件，内核会在内核空间开辟一块缓存，这个称之为内核空间的缓存
  \item 库缓存：标准IO的库函数的缓存
\end{itemize}

文件IO中的写，即是将用户空间的缓存写入到内核空间缓存当中；反之，文件IO的读，则是将内核空间的缓存读写到用户空间的缓存当中。
而调用标准IO之后，数据会从用户空间写入到库缓存，当写入的数据包含\textbackslash n时，或者库缓存空间写满时，才会向内核缓存空间提交数据。
因此，如果上述代码修改为
\begin{code-block}{c}
printf("stdio %s\n", buffer); //或者直接将库缓存写满
while(1);
\end{code-block}
则会直接输出。另外，库缓存的大小默认为1024个字节。

常用fgets，gets，printf，sprintf，fprintf，fputs，puts，scanf这些函数在遇到\textbackslash n或者写满缓存时，即
调用系统调用函数，称之为行缓存函数；而fread，fwrite只有在写满缓存之后再调用系统调用函数，这些则称之为全缓存函数；
而只要调用，则会将内容和数据写入到内核当中的函数，称之为无缓存函数，注意，stderr是无缓存的，而stdout则是行缓存的。
fclose函数在关闭文件之前，会刷新缓存当中的数据到文件当中。

需要注意的是fputc是缓存函数，但是，他不是行缓存函数，立即生效的话，需要使用fflush函数进行强制刷新。

除此之外，在标准IO当中，读取文件有可能会出现错误，而fgets函数读取正常时，返回读取到的内容，这个内容与fgets函数的第一个参数的结果一致，
如果读取错误，则会返回一个空指针（char）。但是无法准确判断这个错误是什么类型。判断错误的准确类型，可以使用feof和ferror函数进行判断。
前者表示读取到了文件末尾，而后一个则表示真的文件读取错误，如下代码所示：
\begin{code-block}{c}
FILE *fp = fopen("test.c")
char buffer[128];
char * read_ret = NULL;
read_ret = fgets(buffer, 128, fp);
if (NULL == read_ret)
{
        if(feof(fp))
        {
                printf("Read the end of file\n");
        }
        if(ferror(fp))
        {
                printf("Read error from the stream\n");
        }
}
\end{code-block}

与文件IO相对应的，标准IO使用fopen函数进行文件的创建和读写。但是需要特别注意的是，实际上，fopen函数创建的函数的权限始终是
666，但是由于umask的存在，因此，fopen函数创建的文件的最终权限为644。

全缓存函数fread和fwrite在使用的时候会调用syscall，写入到内核缓存当中，最后写入到硬件当中（文件）。同样的，我们也可以用fread和fwrite实现
Linux的cat命令，简单的如下：
\begin{code-block}{c}
if(NULL == (fp = fopen(argv[1], "rb")))
{
        printf("Cannot open the file %s\n", argv[1]);
        return -1;
}

unsigned char buffer[128];
memset(buffer, 0, 128);
while(0 < fread(buffer, sizeof(char), 128, fp))
{
        fwrite(buffer, sizeof(char), 128, stdout);
        memset(buffer, 0, 128);
        if(feof(fp))
        {
                printf("Read the the of file\n");
                break;
        }
}

fclose(fp); // 调用fflush，直接写入到内核缓存当中
return 0;
\end{code-block}

从执行效率上说，fgetc/fputc<fgets/fputs<fread/fwrite，主要原因在于fread基本都是在内核空间操作，效率有保证。因此，在有高效率要求的情况下，尽可能的使用fread和fwrite
作为IO的操作函数。

\section{目录IO}
除了文件IO和标准IO之外，Linux还提供了针对路径（目录）的IO操作函数，具体如图\nameref{fig:dirio}所示
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{dirio.png}
  \caption{Linux的目录IO函数}
  \label{fig:dirio}
\end{figure}

只是需要注意的是，mkdir函数在sys/stat.h当中，其他的函数大部分在dirent.h当中。目录的创建，可以使用如下的代码：
\begin{code-block}{c}
int ret = mkdir("zhangjl", 0777);
if(0 > ret)
{
        printf("Failed to create dir\n");
        return -1;
}
return 0;
\end{code-block}

而打开目录，则可以如下操作：
\begin{code-block}{c}
#include <dirent.h>

int main(int argc, char * argv[])
{
        DIR *dp = opendir("/root");
        if(NULL ==  dp)
        {
                printf("Failed to open dir\n");
                return -1;
        }

        closedir(dp);
        return 0;
}
\end{code-block}

读取目录内容，则可以使用readdir函数。由于readdir函数在多个头文件当中都有定义，此处应当使用dirent.h当中的函数。
具体的使用如下代码：
\begin{code-block}{c}
#include <stdio.h>
#include <dirent.h>

int main(int argc, char * argv[])
{
        DIR *dp = opendir("/root/cprograms/dirio");
        if(NULL ==  dp)
        {
                printf("Failed to open dir\n");
                return -1;
        }

        struct dirent * dir = NULL;
        while (NULL != (dir = readdir(dp)))
        {
                printf("The inode is %lu, and name is %s\n",
                        dir->d_ino, dir->d_name);
        }

        closedir(dp);
        return 0;
}
\end{code-block}
上述代码需要注意的有几点：
\begin{enumerate}
  \item readdir返回的是一个指针，而这个指针，实际上是一个链表的头指针，因此，通常情况下需要反复调用该函数，读取链表上的所有元素
  \item readdir只能返回一级文件目录当中的内容，子目录以及子目录下的子目录，则无法一次性读取
  \item rewinddir则会将readdir所得到的指针，重新定位到这个链表的头节点，也可以使用seekdir进行指定地址的跳转。
\end{enumerate}

\section{Linux进程通信}
Linux常见的进程间通信模式主要如下：
\begin{itemize}
    \item 管道pipe

            管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
    \item 命名管道FIFO

            有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
    \item 消息队列MessageQueue

            消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
    \item 共享存储SharedMemory

            共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
    \item 信号量Semaphore

            信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
    \item 套接字Socket

            套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
    \item 信号 ( sinal )

            信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
\end{itemize}

\subsection{管道方式}
管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。
\begin{itemize}
    \item 半双工

            数据只能在一个方向上流动，具有固定的读端和写端。
    \item 亲缘关系

            只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。
    \item 特殊文件

            对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。
\end{itemize}

当一个管道建立时，它会创建两个文件描述符：fd[0]为读而打开，fd[1]为写而打开。如下图:\nameref{fig:pipe}
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{pipe.png}
  \caption{管道}
  \label{fig:pipe}
\end{figure}
需要注意的是，fd[0]永远用于读取，不管是子进程还是父进程，都只能从fd[0]读取；fd[1]永远用于写入，子进程和父进程都只能从
fd[1]写入。如果fd的使用搞反，则会导致消息无法正常传递。

单个进程中的管道几乎没有任何用处。所以，通常调用 pipe 的进程接着调用 fork，这样就创建了父进程与子进程之间的 IPC 通道。如下图所示:\nameref{fig:fork_pipe}
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{fork_pipe.png}
  \caption{fork管道}
  \label{fig:fork_pipe}
\end{figure}

使用管道的具体方式如下：
\begin{code-block}{c}
#include <stdio.h>
#include <unistd.h>

int main(int argc, char * argv[])
{
        int fd[2];
        pid_t pid;
        char buf[20];

        if(0 > pipe(fd))
        {
                printf("Create Pipe Error!\n");
                return -1;
        }
        if(0 > (pid = fork()))
        {
                printf("Fork error\n");
                return -1;
        }
        if(0 == pid)
        {
#if 1
                // 父进程接收
                close(fd[1]);
                read(fd[0], buf, 20);
                printf("%s in pid %d\n", buf, pid);
                close(fd[0]);
#else
                // 父进程输入
                printf("pid: %d\n", pid);
                close(fd[0]);
                write(fd[1], "Hello World\n", 12);
                close(fd[1]);
#endif
        }
        else{
#if 1
                // 子进程输入
                printf("pid: %d\n", pid);
                close(fd[0]);
                write(fd[1], "Hello World\n", 12);
                close(fd[1]);
#else
                // 子进程接收
                close(fd[1]);
                read(fd[0], buf, 20);
                printf("%s in pid %d\n", buf, pid);
                close(fd[0]);
#endif
        }
        return 0;
}
\end{code-block}

\subsection{命名管道FIFO}
FIFO，也称为命名管道，它是一种文件类型。FIFO可以在无关的进程之间交换数据，与无名管道不同。FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。
通常使用mkfifo创建一个命名管道。一旦创建了一个 FIFO，就可以用一般的文件I/O函数操作它。FIFO的通信方式类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性。
在数据读出时，FIFO管道中同时清除数据，并且“先进先出”。
下面的例子演示了使用 FIFO 进行 IPC 的过程。
Server端负责创建fifo，并保持监听。
\begin{code-block}{c}
// server.c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/stat.h>
#include <unistd.h>
#include <signal.h>

#define FIFO_PATH "/tmp/fifo"
static int fd = -1;
static void ctrl_c(int sig);

static inline void clean()
{
        if(0 < fd)
        {
                close(fd);  // 关闭FIFO文件
        }
        remove(FIFO_PATH);
}

int main(int argc, char * argv[])
{
        int len;
        char buf[1024];

        if (SIG_ERR == signal(SIGINT, ctrl_c))
        {
                printf("\ncan't catch SIGINT\n");
                goto finally;
        }

        if(mkfifo(FIFO_PATH, 0666) < 0 && errno!=EEXIST) // 创建FIFO管道
                perror("Create FIFO Failed");

        if((fd = open(FIFO_PATH, O_RDONLY)) < 0)  // 以读打开FIFO
        {
                perror("Open FIFO Failed");
                exit(1);
        }

        while(1)
        {
                len = read(fd, buf, 1024);
                if (0 < len)
                {
                        printf("Read message: %s", buf);
                }
                else if (0 > len)
                {
                        perror("Unexpected error\n");
                        break;
                }
        }

finally:
        clean();
        return 0;
}

void ctrl_c(int sig)
{
        if (SIGINT == sig)
        {
                printf("Recevied ctrl+c interrupt, try to clean the env\n");
                clean();
                exit(0);
        }
}
\end{code-block}

Client端负责连接fifo，并通过fifo进行通信。
\begin{code-block}{c}
// client.c
#include <stdio.h>
#include <stdlib.h>   // exit
#include <fcntl.h>    // O_WRONLY
#include <sys/stat.h>
#include <time.h>     // time
#include <unistd.h>

#define FIFO_PATH "/tmp/fifo"

int main(int argc, char * argv[])
{
        int fd;
        int n, i;
        char buf[1024];
        time_t tp;
        printf("I am %d process.\n", getpid()); // 说明进程ID

        if((fd = open(FIFO_PATH, O_WRONLY)) < 0) // 以写打开一个FIFO
        {
                perror("Open FIFO Failed");
                exit(1);
        }
        for(;;)
        {
                time(&tp);  // 取系统当前时间
                n=sprintf(buf,"Process %d's time is %s",getpid(),ctime(&tp));
                printf("Send message: %s", buf); // 打印
                if(write(fd, buf, n+1) < 0)  // 写入到FIFO中
                {
                        perror("Write FIFO Failed");
                        close(fd);
                        exit(1);
                }
                sleep(1);  // 休眠1秒
        }
        close(fd);  // 关闭FIFO文件
        return 0;
}
\end{code-block}

稍微特殊的情况是，在server端的代码中，加入了对ctrl+c的中断识别操作，确保server端可以执行对应的扫尾工作。本身对ctrl+c的中断
操作属于信号量和中断的范畴。上述例子可以展成客户进程—服务器进程通信的实例，可以打开多个客户端
向一个服务器发送请求信息，server端实时监控着FIFO的读端，
在之后的内容会有更加详细的讲解。当有数据时，读出并进行处理，但是有一个关键的问题是，
每一个客户端必须预先知道服务器提供的FIFO接口，下图显示了这种安排\nameref{fig:fifo}
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{fifo.png}
  \caption{FIFO管道}
  \label{fig:fifo}
\end{figure}

\subsection{消息队列}
消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。

消息队列拥有自己的一些特点：
\begin{itemize}
    \item 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。
    \item 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。
    \item 消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。
\end{itemize}

消息队列的主要原型在如下的头文件当中：
\begin{code-block}{c}
#include <sys/msg.h>
// 创建或打开消息队列：成功返回队列ID，失败返回-1
int msgget(key_t key, int flag);
// 添加消息：成功返回0，失败返回-1
int msgsnd(int msqid, const void *ptr, size_t size, int flag);
// 读取消息：成功返回消息数据的长度，失败返回-1
int msgrcv(int msqid, void *ptr, size_t size, long type,int flag);
// 控制消息队列：成功返回0，失败返回-1
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
\end{code-block}

在以下两种情况下，msgget将创建一个新的消息队列：
\begin{itemize}
    \item 如果没有与键值key相对应的消息队列，并且flag中包含了IPC\_CREAT标志位。
    \item key参数为IPC\_PRIVATE
\end{itemize}

函数msgrcv在读取消息队列时，type参数有下面几种情况：
\begin{itemize}
    \item type == 0，返回队列中的第一个消息
    \item type > 0，返回队列中消息类型为 type 的第一个消息
    \item type < 0，返回队列中消息类型值小于或等于 type 绝对值的消息，如果有多个，则取类型值最小的消息
\end{itemize}

可以看出，type值非0时用于以非先进先出次序读消息。也可以把type看做优先级的权值。
下面的例子使用消息队列进行IPC，服务端程序一直在等待特定类型的消息，当收到该类型的
消息以后，发送另一种特定类型的消息作为反馈，客户端读取该反馈并打印出来。
\begin{code-block}{c}
// server.c
#include <stdio.h>
#include <stdlib.h>
#include <sys/msg.h>
#include <unistd.h>

// 用于创建一个唯一的key
#define MSG_FILE "/etc/passwd"

// 消息结构
struct msg_form {
        long mtype;
        char mtext[256];
};

int main()
{
        int msqid;
        key_t key;
        struct msg_form msg;
        // 获取key值
        // 只有server端和client端获得的key相同，server端和client端才能进行通信
        if((key = ftok(MSG_FILE,'z')) < 0)
        {
                perror("ftok error");
                exit(1);
        }

        // 打印key值
        printf("Message Queue - Server key is: %d.\n", key);

        // 创建消息队列
        if ((msqid = msgget(key, IPC_CREAT|0777)) == -1)
        {
                perror("msgget error");
                exit(1);
        }

        // 打印消息队列ID及进程ID
        printf("My msqid is: %d.\n", msqid);
        printf("My pid is: %d.\n", getpid());

        // 循环读取消息
        for(;;)
        {
                msgrcv(msqid, &msg, 256, 888, 0);// 返回类型为888的第一个消息
                printf("Server: receive msg.mtext is: %s.\n", msg.mtext);
                printf("Server: receive msg.mtype is: %d.\n", msg.mtype);

                msg.mtype = 999; // 客户端接收的消息类型
                sprintf(msg.mtext, "hello, I'm server %d", getpid());
                msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
        }
        return 0;
}
\end{code-block}

而客户端的代码有区别
\begin{code-block}{c}
// client.c
#include <stdio.h>
#include <stdlib.h>
#include <sys/msg.h>
#include <unistd.h>

// 用于创建一个唯一的key
#define MSG_FILE "/etc/passwd"

// 消息结构
struct msg_form {
        long mtype;
        char mtext[256];
};

int main()
{
        int msqid;
        key_t key;
        struct msg_form msg;

        // 获取key值
        if ((key = ftok(MSG_FILE, 'z')) < 0)
        {
                perror("ftok error");
                exit(1);
        }

        // 打印key值
        printf("Message Queue - Client key is: %d.\n", key);

        // 打开消息队列
        if ((msqid = msgget(key, IPC_CREAT|0777)) == -1)
        {
                perror("msgget error");
                exit(1);
        }

        // 打印消息队列ID及进程ID
        printf("My msqid is: %d.\n", msqid);
        printf("My pid is: %d.\n", getpid());

        // 添加消息，类型为888
        msg.mtype = 888;
        sprintf(msg.mtext, "hello, I'm client %d", getpid());
        msgsnd(msqid, &msg, sizeof(msg.mtext), 0);

        // 读取类型为999的消息
        msgrcv(msqid, &msg, 256, 999, 0);
        printf("Client: receive msg.mtext is: %s.\n", msg.mtext);
        printf("Client: receive msg.mtype is: %d.\n", msg.mtype);
        return 0;
}
\end{code-block}

比较有意思的是，内核的消息队列和真正的消息队列服务器行为一致。当消息发出，没有接收者
时，依然会存在消息积压，只不过这些消息是积压在内核空间的。当接收者出现之后，这些
积压在内核空间的消息，还是会被正确投递。

\subsection{信号量}
信号量（semaphore）与已经介绍过的IPC结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。
\begin{itemize}
    \item 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。
    \item 信号量基于操作系统的PV操作，程序对信号量的操作都是原子操作
    \item 每次对信号量的PV操作不仅限于对信号量值加1或减1，而且可以加减任意正整数。
    \item 支持信号量组。
\end{itemize}

最简单的信号量是只能取0和1的变量，这也是信号量最常见的一种形式，叫做二值信号量（Binary Semaphore）。而可以取多个正整数的信号量被称为通用信号量。
Linux下的信号量函数都是在通用的信号量数组上进行操作，而不是在一个单一的二值信号量上进行操作。实际应用时，我们每次都需要创建一个信号量集，
即使此集合只包含一个信号量。一般我们通过下面函数去创建或者打开一个信号量集。
\begin{code-block}{c}
int semget(key_t key,int nsems,int semflg);
\end{code-block}

当semflg=IPC\_CREATE时，如果当前系统中不存在此信号量集合（key值不存在），
那么semget函数完成一个信号量的创建；否则，semget函数打开这个已存在的信号量集。
当semflg=IPC\_CREATE|IPC\_EXCL时，只会完成创建，如果key值对应的信号量集合以存在，
那么直接返回错误，错误代码为EEXIST。这并不难理解，和open文件的情况类似。此函数
成功执行返回信号量集的标示符，否则为-1。

而常用的信号量函数如下：
\begin{code-block}{c}
#include <sys/sem.h>
// 创建或获取一个信号量组：若成功返回信号量集ID，失败返回-1
int semget(key_t key, int num_sems, int sem_flags);
// 对信号量组进行操作，改变信号量的值：成功返回0，失败返回-1
int semop(int semid, struct sembuf semoparray[], size_t numops);
// 控制信号量的相关信息
int semctl(int semid, int sem_num, int cmd, ...);
\end{code-block}

当semget创建新的信号量集合时，必须指定集合中信号量的个数（即num\_sems），通常为1；
如果是引用一个现有的集合，则将sems\_num指定为 0 。sembuf结构的定义如下：
\begin{code-block}{c}
struct sembuf
{
    short sem_num; // 信号量组中对应的序号，0～sem_nums-1
    short sem_op;  // 信号量值在一次操作中的改变量
    short sem_flg; // IPC_NOWAIT, SEM_UNDO
}
\end{code-block}

通过semid和sem\_num两个字段就可以确定信号量集中的指定信号量。sem\_op取不同的值就会
产生不同的操作。特别的，如果其值为0，则此时sem\_op操作的作用是测试信号量的值是否为0。
sem\_op是一次操作中的信号量的改变量，若sem\_op > 0，表示进程释放相应的资源数，将
sem\_op的值加到信号量的值上。如果有进程正在休眠等待此信号量，则唤醒他们。

若sem\_op < 0，请求sem\_op的绝对值的资源，如果相应的资源数可以满足请求，则将该信号量的值减去sem\_op的绝对值，
函数成功返回。当相应的资源数不能满足请求时，这个操作与sem\_flg有关。sem\_flg 指定IPC\_NOWAIT，则semop函数出错
返回EAGAIN。sem\_flg 没有指定IPC\_NOWAIT，则将该信号量的semncnt值加1，然后进程挂起直到下述情况发生：当相应的
资源数可以满足请求，此信号量的semncnt值减1，该信号量的值减去sem\_op的绝对值。成功返回；此信号量被删除，函数
smeop出错返回EIDRM；进程捕捉到信号，并从信号处理函数返回，此情况下将此信号量的semncnt值减1，函数semop出错
返回EINTR。

若sem\_op==0，进程阻塞直到信号量的相应值为0：当信号量已经为0，函数立即返回。如果信号量的值不为0，则依据
sem\_flg决定函数动作：sem\_flg指定IPC\_NOWAIT，则出错返回EAGAIN。sem\_flg没有指定IPC\_NOWAIT，则将该信号量的
semncnt值加1，然后进程挂起直到下述情况发生：信号量值为0，将信号量的semzcnt的值减1，函数semop成功返回；此
信号量被删除，函数smeop出错返回EIDRM；进程捕捉到信号，并从信号处理函数返回，在此情况将此信号量的semncnt值
减1，函数semop出错返回EINTR。

在semctl函数中的命令有多种，这里就说两个常用的：SETVAL：用于初始化信号量为一个已知的值。所需要的值作为联合
semun的val成员来传递。在信号量第一次使用之前需要设置信号量。IPC\_RMID：删除一个信号量集合。如果不删除信号量，
它将继续在系统中存在，即使程序已经退出，它可能在你下次运行此程序时引发问题，而且信号量是一种有限的资源。

一个简单的例子。如果不使用信号量，父进程会先于子进程输出。但是，使用信号量之后，子进程会先于父进程执行。
\begin{code-block}{c}
#include <stdio.h>
#include <stdlib.h>
#include <sys/sem.h>
#include <unistd.h>

union semun
{
        int              val; /*for SETVAL*/
        struct semid_ds *buf;
        unsigned short  *array;
};

// 初始化信号量
int init_sem(int sem_id, int value)
{
        union semun tmp;
        tmp.val = value;
        if(semctl(sem_id, 0, SETVAL, tmp) == -1)
        {
                perror("Init Semaphore Error");
                return -1;
        }
        return 0;
}

// P操作:
//    若信号量值为1，获取资源并将信号量值-1
//    若信号量值为0，进程挂起等待
int sem_p(int sem_id)
{
        struct sembuf sbuf;
        sbuf.sem_num = 0; /*序号*/
        sbuf.sem_op = -1; /*P操作*/
        sbuf.sem_flg = SEM_UNDO;

        if(semop(sem_id, &sbuf, 1) == -1)
        {
                perror("P operation Error");
                return -1;
        }
        return 0;
}

// V操作：
//    释放资源并将信号量值+1
//    如果有进程正在挂起等待，则唤醒它们
int sem_v(int sem_id)
{
        struct sembuf sbuf;
        sbuf.sem_num = 0; /*序号*/
        sbuf.sem_op = 1;  /*V操作*/
        sbuf.sem_flg = SEM_UNDO;

        if(semop(sem_id, &sbuf, 1) == -1)
        {
                perror("V operation Error");
                return -1;
        }
        return 0;
}

// 删除信号量集
int del_sem(int sem_id)
{
        union semun tmp;
        if(semctl(sem_id, 0, IPC_RMID, tmp) == -1)
        {
                perror("Delete Semaphore Error");
                return -1;
        }
        return 0;
}


int main()
{
        int sem_id;  // 信号量集ID
        key_t key;
        pid_t pid;

        // 获取key值
        if((key = ftok(".", 'z')) < 0)
        {
                perror("ftok error");
                exit(1);
        }

        // 创建信号量集，其中只有一个信号量
        if((sem_id = semget(key, 1, IPC_CREAT|0666)) == -1)
        {
                perror("semget error");
                exit(1);
        }

        // 初始化：初值设为0资源被占用
        init_sem(sem_id, 0);

        if((pid = fork()) == -1)
                perror("Fork Error");
        else if(pid == 0) /*子进程*/
        {
                //sleep(2);
                printf("Process child: pid=%d\n", getpid());
                sem_v(sem_id);  /*释放资源*/
        }
        else  /*父进程*/
        {
                sem_p(sem_id);   /*等待资源*/
                printf("Process father: pid=%d\n", getpid());
                sem_v(sem_id);   /*释放资源*/
                del_sem(sem_id); /*删除信号量集*/
        }
        return 0;
}
\end{code-block}
首先需要明确的是，在用户空间实现进程间通信是不可能的，需要在Linux内核空间当中进行；但是线程间的通信，在用户空间就可以实现。
最明显的，线程间的通信，通过全局变量即可实现，其原因主要就是多线程之间是共享内存的，如下简单代码：
\begin{code-block}{c}
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
int main_run = 0;
void *func(void *var)
{
        int i = 0;
        //while(!main_run); //如果需要父进程执行结束之后，再执行子线程，则开启本行注释即可
        for (; i <10; i++)
        {
                usleep(100);
                printf("This is fun i=%d\n", i);
        }
}

int main(int argc, char * argv[])
{
        int i = 0;
        char buf[] = "hello world\n";
        pthread_t tid;
        int ret = 0;
        ret = pthread_create(&tid, NULL, func, (void*)buf);
        if (0 > ret)
        {
                printf("Create thread failure\n");
                return -1;
        }
        for(i = 0; i < 10; i++)
        {
                usleep(100);
                printf("this is main fun i = %d\n", i);
        }
        main_run = 1;
        while(1);
        return 0;
}
\end{code-block}

注意，多线程编译时，需要加入-pthread参数，即
\begin{code-block}{bash}
gcc -pthread -o test test.c
\end{code-block}

但是，与线程不同，进程间的每一种通信方式都是基于文件IO的思想进行设计和实现的。

\subsection{管道通信}
管道是一种特殊的文件，由队列来实现，遵循先进先出的顺序。与open函数类似，open函数打开的文件描述符为0，1，2，而管道函数（pipe）
打开的文件描述符则固定为3，4，分别对应fd[0]和fd[1]。在内核当中，管道实际上是使用数组进行实现的。
\begin{code-block}{c}
#include <stdio.h>
#include <unistd.h>

int main(int argc, char * argv[])
{
        int fd[2];
        int ret = 0;
        if (0 > (ret=pipe(fd)))
        {
                printf("Cannot create pipe \n");
                return -1;
        }
        printf("%d, %d\n", fd[0], fd[1]);
        return 0;
}
\end{code-block}

由于管道本身是特殊文件，因此，也可以对管道进行读写，但是特别需要注意的是，fd[0]只允许进行读取，而fd[1]则只允许进行写入，如下：
\begin{code-block}{c}
#include <stdio.h>
#include <unistd.h>
#include <string.h>

int main(int argc, char * argv[])
{
        int fd[2];
        int ret = 0;
        if (0 > (ret=pipe(fd)))
        {
                printf("Cannot create pipe \n");
                return -1;
        }
        char buf[] = "hello linux";
        char readbuf[128];
        memset(readbuf, 0, 128);
        size_t writed = write(fd[1], buf, sizeof(buf)/sizeof(char));
        size_t readed = read(fd[0], readbuf, writed);
        printf("Read from pipe: %s\n", readbuf);
        close(fd[0]);
        close(fd[1]);
        return 0;
}
\end{code-block}

\begin{enumerate}
  \item 管道创建在内存当中，进程结束，空间释放，管道就不存在了
  \item 管道当中的数据，一旦读取完毕，就直接从管道当中删除了
  \item 如果管道当中没有内容，则读取操作会一直阻塞；反之，如果没有读取操作，一旦缓冲写满（65536），则写入操作会阻塞
  \item 管道最大为65536字节
  \item 无名管道只能实现父子进程之间的通信
\end{enumerate}

实现父子进程的通信如下：
\begin{code-block}{c}
#include <stdio.h>
#include <unistd.h>
#include <string.h>

int main(int argc, char * argv[])
{
        int fd[2];
        int ret = pipe(fd);
        int inter = 0;
        pid_t pid;
        pid = fork();
        if (0 > ret)
        {
                printf("Cannot create pipe \n");
                return -1;
        }
        if (0 == pid)
        {
                int i = 0;
                read(fd[0], &inter, 1);
                while(!inter);
                for (;i < 5; i++)
                {
                        printf("[%d]In child\n", i);
                }
        }
        if ( 0 < pid)
        {
                int i = 0;
                for(;i < 5; i++)
                {
                        printf("[%d]In parent\n", i);
                }
                inter = 1;
                write(fd[1], &inter, 1);
        }

        close(fd[0]);
        close(fd[1]);
        return 0;
}
\end{code-block}

与无名管道相对应的，则是命名管道，命名管道可以实现无亲缘关系的进程间通信。所谓命名管道，其实也是一个管道，但是，他是存在于文件系统
当中的，并不是仅仅只是在内存当中。命名管道的文件，每个文件节点都含有inode编号，并且其文件为p类型（即管道类型）。管道文件只含有inode
编号，不占用磁盘存储空间，与套接字，字符设备以及块设备一样。管道文件的创建，需要使用mkfifo函数（需要包含<sys/stat.h>头文件），不过，
该函数只是创建了管道文件的inode信息，并没有在内核当中创建管道，只有通过open函数打开这个创建成功的管道文件时，才会在内核空间创建对应
的管道。创建命名管道文件的示例如下：
\begin{code-block}{c}
#include <stdio.h>
#include <sys/stat.h>

int main(int argc, char * argv[])
{
        int ret = 0;
        if (0> (ret = mkfifo("/var/run/zhangjl", 0644)))
        {
                printf("Cannot create fifo file zhangjl\n");
                return -1;
        }
        printf("Create fifo file sucess\n");
        return 0;
}
\end{code-block}

而命名管道的使用，通常就是用于不同进程之间的相互通信。比如下面的例子：
\begin{code-block}{c}
#include <stdio.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int main(int argc, char * argv[])
{
        int ret = 0;
        if (0> (ret = mkfifo("/var/run/zhangjl", 0644)))
        {
                printf("Cannot create fifo file zhangjl\n");
                return -1;
        }
        printf("Create fifo file sucess\n");

        int fd = 0;
        if (0 > (fd = open("/var/run/zhangjl", O_WRONLY)))
        {
                printf("Cannot open the named pipe\n");
                return -1;
        }

        for(ret = 0;ret < 5; ret++)
        {
                printf("This is first process [%d]\n", ret);
                usleep(100);
        }

        int completed_signal = 0;
        completed_signal = 100;
        write(fd, &completed_signal, 1);
        while(1);
        close(fd);
        return 0;
}
\end{code-block}

而另外的进程可以直接从该管道当中读取数据，如下：
\begin{code-block}{c}
#include <stdio.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int main(int argc, char * argv[])
{
        int fd = 0;
        if (0 > (fd = open("/var/run/zhangjl", O_RDONLY)))
        {
                printf("Cannot open the named pipe\n");
                return -1;
        }
        int completed_signal = 0;
        read(fd, &completed_signal, 1);
        while(!completed_signal);

        int ret = 0;
        for(ret = 0;ret < 5; ret++)
        {
                printf("This is client process [%d]\n", ret);
                usleep(100);
        }

        close(fd);
        return 0;
}
\end{code-block}

\subsection{信号通信}
除了使用管道之外，还可以使用信号的方式进行通信。与管道不太一样的是，信号对象存在于内核当中，无需创建，本身已经存在了，并且，无法在用户空间进行信号的发送和接收。
在Linux当中，可以通过kill -l查看总共有多少信号（总共64种），如图\nameref{fig:signal}所示:
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{signal.png}
  \caption{Linux的信号种类}
  \label{fig:signal}
\end{figure}

使用信号，可以简单的实现kill的功能。在实现kill命令功能的时候，需要使用kill函数，具体示例如下：
\begin{code-block}{c}
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

int main(int argc, char *argv[])
{
        if(argc != 3)
        {
                printf("Usage kill signal pid\n");
                return -1;
        }
        int sig = 0, pid = 0;
        sig = atoi(argv[1]);
        pid = atoi(argv[2]);
        printf("sig is %d and pid in %d\n", sig, pid);
        kill(pid, sig);
        return 0;
}
\end{code-block}

除了使用kill进行信号的发送之外，还可以使用其他的函数进行信号的发送，比如常用的的raise，alarm等;信号的接收，通常采用pause，sleep
以及while(1)等方式；而信号的处理则通常交给signal进行。

Raise函数只会发送信号给自己，基本上等价于kill(getpid(), sig)，即希望通过内核给自己发信号，常用于杀掉自身的进程，如下
\begin{code-block}{c}
#include <stdio.h>
#include <signal.h>

int main(int argc, char *argv[])
{
        printf("Raise before\n");
        raise(9);
        printf("Raise after\n");
        return 0;
}
\end{code-block}

上述代码，在编译之后运行，只有before能够输出，raise调用之后，自身进程被直接杀死，因此后续的after无法输出。

而alarm函数只会发送一个定时器信号，当程序接收到定时器信号之后，会终止对应的进程，如下：
\begin{code-block}{c}
#include <stdio.h>
#include <unistd.h>

int main(int argc, char * argv[])
{
        printf("Alarm Before\n");
        alarm(9);
        while(1); //等待9秒之后，该进程自动被终止
        printf("Alarm After\n");
        return 0;
}
\end{code-block}

因此，上述代码当中，after也是无法进行输出的。

而信号的接收，处理方式则有些不同。Pause函数会直接暂停当前的进程，如下：
\begin{code-block}{c}
#include <stdio.h>
#include <unistd.h>

int main(int argc, char * argv[])
{
        printf("Pause Before\n");
        pause();
        printf("Pause After\n");
        return 0;
}
\end{code-block}

Pasue函数一旦调用，则对应的进程会直接变为暂停状态，ps -ajx可以看到状态变为S。退出暂停状态的进程，可以直接使用Ctrl+C进行，而Ctrl+C本身
发送的就是一个终止信号。

上述的信号处理，通用的方式都是终止/暂停对应的进程，很明显并不是所有的场景都需要。因此，如何进行信号处理的自定义呢？我们需要采用signal
函数。Signal函数的定义如下：
\begin{code-block}{c}
void (*signal(int sig, void (*func)(int)))(int);
\end{code-block}

其中，func为一个函数指针，指向自定义的型号处理函数。除了自定义的信号处理函数之外，func这个函数指针还可以的取值为SIG\_IGN（忽略该信号）
和SIG\_DFL（采用系统默认方式处理信号）。简单的signal函数的使用如下：
\begin{code-block}{c}
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

static int quit = 0;
void handler(int signalnum)
{
        printf("Recevied signal %d\n", signalnum);
        quit = 1;
}

int main(int argc, char * argv[])
{
        signal(SIGALRM, handler);
        alarm(9);
        while(!quit);
        printf("Using self defined function to handle signal\n");
        return 0;
}
\end{code-block}

Signal函数在用于子进程的退出处理当中，是比较常用的，比如：
\begin{code-block}{c}
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <stdlib.h>
#include <sys/wait.h>

void handler(int signum)
{
        int i = 0;
        while( i < 5)
        {
                printf("Receved signum %d\n", signum);
                i++;
        }
}

void clean(int signum)
{
        printf("Recevied signum %d, clean up the child process\n", signum);
        wait(NULL); // 需要使用wait函数，回收对应的进程，否则，子进程会成为僵尸进程
}

int main(int argc, char * argv[])
{
        pid_t pid;
        pid = fork();
        signal(SIGUSR1, handler);
        signal(SIGCHLD, clean);
        if (0 < pid)
        {
                int i =0;
                while(1)
                {
                        printf("This is the parent process [%d]\n", i++);
                        sleep(1);
                }
        }
        if(0 == pid)
        {
                sleep(5);
                //kill(getpid(), SIGUSR1);
                raise(SIGUSR1); // 可以直接替代上面的kill函数
                exit(0); // kill(getpid(), SIGCHLD); // 在子进程当中调用exit函数
                                                     // 相当于调用了kill函数，只不过
                                                     // 发送的信号是SIGCHLD，即杀死子进程
        }
        return 0;
}
\end{code-block}

需要注意，无名管道，命名管道以及信号，都是发生在内核空间当中，并没有发生在用户空间。
除了使用上述的方式实现进程间通信之外，在Linux当中，还可以使用IPC实现。而IPC对象包含了3种方式：
\begin{itemize}
  \item 共享内存
  \item 消息队列
  \item 信号量/灯
\end{itemize}

这些IPC对象同样是在内核空间，并没有发生在用户空间，IPC类似于Linux的文件IO操作的相关思想，可以针对文件IO与IPC做一个简单的类比，
如图\nameref{fig:IPC}所示
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{IPC.png}
  \caption{文件IO与IPC的对比}
  \label{fig:IPC}
\end{figure}

\subsection{共享内存}
共享内存通常需要使用shmget函数进行创建，而这个函数包含3个参数：
\begin{itemize}
  \item key：IPC\_PRIVATE或者是ftok函数的返回值
  \item size：共享内存的大小，bit
  \item shmflg：共享内存的权限，同open函数
\end{itemize}
共享内存的具体使用示例如下：
\begin{code-block}{c}
#include <stdio.h>
#include <sys/shm.h>

int main(int argc, char * argv[])
{
        int shmid = 0;
        if (0 > (shmid = shmget(IPC_PRIVATE, 128, 0777)))
        {
                printf("Create shared memory failed\n");
                return -1;
        }
        return 0;
}
\end{code-block}

共享内存创建完毕之后，可以直接使用Linux提供的命令进行查看和删除。
\begin{code-block}{c}
# 查看IPC对象，包括共享内存, 或者直接ipcs
ipcs -m -q -s
# 删除IPC对象
ipcrm -m <id>
\end{code-block}
在上述代码当中，创建共享内存使用的是IPC\_PRIVATE这个宏，因此，创建出来的共享内存的
key永远为0。可以改为使用ftok函数，给不同的共享内存分配不同的标识符（key），如下：
\begin{code-block}{c}
#include <stdio.h>
#include <sys/shm.h>
#include <sys/ipc.h>

int main(int argc, char * argv[])
{
        int shmid = 0;
        int key = ftok("sharedmem.c", 's');
        if (0 > key)
        {
                printf("Failed to create shamred memory key\n");
                return -1;
        }
        if (0 > (shmid = shmget(key, 128, IPC_CREAT | 0777)))
        {
                printf("Create shared memory failed\n");
                return -1;
        }
        printf("Shared memory object id is %d\n", shmid);
        return 0;
}
\end{code-block}

IPC\_PRIVATE与ftok创建的共享内存，其关系类似与无名管道和命名管道，也就是说，IPC\_PRIVATE只能用于有亲缘关系的进程间通信，
而ftok的共享内存，则是任意进程间都可以进行通信。共享内存创建完成之后，整个是放在内核空间的，因此，用户空间无法访问，但是，
可以通过映射的方式，将共享内存将这些共享内存映射到用户空间，用户空间可以直接操作这些内存。共享内存的映射，需要使用函数shmat实现。
Shmat函数包含3个参数：id表示共享内存的id号，shmaddr表示映射的地址，NULL表示自动分配，shmflg表示映射内存的权限，0可读可写。
与管道不同，共享内存是可以反复读取的，并且，一直存在与内核当中，直到被删除或者系统关闭。

而共享内存的删除，包含了2部分的操作：1是断开与用户空间的内存映射，这个操作可以使用shmdt函数实现；2是回收内核空间当中的共享内存，
需要使用函数shmctl函数进行操作。Shmctl函数的参数如下：
\begin{itemize}
  \item hmid：表示共享内存的id
  \item cmd：表示针对共享内存的操作，可选的有3个，IPC\_STAT，获取对象属性，IPC\_SET，设置对象属性，以及IPC\_RMID删除共享内存对象
  \item buf：当cmd为IPC\_SET或IPC\_STAT时，需要使用该参数表示对象属性
\end{itemize}

共享内存的整体使用，如下示例：
\begin{code-block}{c}
#include <stdio.h>
#include <sys/shm.h>
#include <sys/ipc.h>

int main(int argc, char * argv[])
{
        int shmid = 0;
        int key = ftok("sharedmem.c", 's');
        if (0 > key)
        {
                printf("Failed to create shamred memory key\n");
                return -1;
        }
        if (0 > (shmid = shmget(key, 128, IPC_CREAT | 0777)))
        {
                printf("Create shared memory failed\n");
                return -1;
        }
        printf("Shared memory object id is %d\n", shmid);
        char * buffer = NULL;
        if (NULL == (buffer = (char *)shmat(shmid, NULL, 0)))
        {
                printf("Cannot mapping shared memory to user namespace\n");
                return -1;
        }

        fgets(buffer, 128, stdin);
        printf("Shared memory data :%s\n", buffer);

        shmdt(buffer); // 删除用户空间的共享内存映射
        buffer = NULL;

        shmctl(shmid, IPC_RMID, NULL); // 删除内核空间的共享内存

        return 0;
}
\end{code-block}

共享内存也常常用于进程间通信，比如父子进程之间的通信，如下所示：
\begin{code-block}{c}
#include <stdio.h>
#include <sys/shm.h>
#include <sys/ipc.h>
#include <unistd.h>
#include <signal.h>

void parent_handler(int signum)
{
}

void child_handler(int signum)
{
}

int main(int argc, char * argv[])
{
        int shmid = 0;
        pid_t pid = 0;
        if (0 > (shmid = shmget(IPC_PRIVATE, 128, 0777)))
        {
                printf("Create shared memory failed\n");
                return -1;
        }
        printf("Shared memory object id is %d\n", shmid);

        pid = fork();
        char * buffer = NULL;
        if (0 < pid)
        {
                signal(SIGUSR2, parent_handler);
                printf("In parent process\n");
                if (NULL == (buffer = (char *)shmat(shmid, NULL, 0)))
                {
                        printf("Cannot mapping shared memory to user namespace in parent process\n");
                        return -1;
                }
                while(1)
                {
                        fgets(buffer, 128, stdin);
                        kill(pid, SIGUSR1); // 发送信号给子进程，唤醒子进程
                        pause(); // 暂停
                }
        }

        if (0 == pid)
        {
                signal(SIGUSR1, child_handler);
                if (NULL == (buffer = (char *)shmat(shmid, NULL, SHM_RDONLY)))
                {
                        printf("Cannot mapping shared memory to user namespace in child process\n");
                        return -1;
                }
                while(1)
                {
                        pause();
                        printf("The shared memory data is %s\n", buffer);
                        kill(getppid(), SIGUSR2); //发送信号给主进程，唤醒主进程
                }
        }

        shmdt(buffer);
        buffer = NULL;

        shmctl(shmid, IPC_RMID, NULL);

        return 0;
}
\end{code-block}

共享内存也可以使用实现没有亲缘关系的进程间的通信，示例如下：
\begin{code-block}{c}
// 服务端的代码
#include <stdio.h>
#include <sys/shm.h>
#include <sys/ipc.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>

typedef struct _buffer{
        int pid;
        char buf[128];
}buffer_t;

void hanlder(int signum){}

int main(int argc, char * argv[])
{
        signal(SIGUSR2, hanlder);
        pid_t pid = 0;
        int shmid = 0;
        buffer_t *buffer = NULL;

        int key = ftok("server.c", 's');
        if (0 > key)
        {
                printf("Failed to create shamred memory key\n");
                return -1;
        }
        if (0 > (shmid = shmget(key, sizeof(buffer_t), IPC_CREAT | 0777)))
        {
                printf("Create shared memory failed\n");
                return -1;
        }
        if (NULL == (buffer = (buffer_t *)shmat(shmid, NULL, 0)))
        {
                printf("Mapping shared memory failed \n");
                return -1;
        }

        buffer->pid = getpid(); // 通过共享内存，向客户端发送自己的pid
        pause(); // 等待客户端的输入，等待信号SIGUSR2唤醒
        pid = buffer->pid; // 获得客户端的pid

        while(1)
        {
                printf("Server process start write share memory\n");
                fgets(buffer->buf, 128, stdin);
                kill(pid, SIGUSR1); // 使用信号SIGUSR1唤醒客户端
                pause();
        }

        shmdt(buffer);
        buffer = NULL;
        shmctl(shmid, IPC_RMID, NULL);

        return 0;
}

// 客户端代码
#include <stdio.h>
#include <sys/shm.h>
#include <sys/ipc.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>

typedef struct _buffer{
        int pid;
        char buf[128];
}buffer_t;

void handler(int signum){}

int main(int argc, char * argv[])
{
        signal(SIGUSR1, handler);
        int shmid = 0;
        buffer_t *buffer = NULL;

        pid_t pid = 0;
        int key = ftok("server.c", 's');
        if (0 > key)
        {
                printf("Failed to create shamred memory key\n");
                return -1;
        }
        if (0 > (shmid = shmget(key, sizeof(buffer_t), IPC_CREAT | 0777)))
        {
                printf("Create shared memory failed\n");
                return -1;
        }
        if (NULL == (buffer = (buffer_t *)shmat(shmid, NULL, 0)))
        {
                printf("Mapping shared memory failed \n");
                return -1;
        }

        pid = buffer->pid; // 通过共享内存获取服务端的pid
        buffer->pid = getpid(); // 输入客户端本身的pid
        kill(pid, SIGUSR2); // 使用信号SIGUSR2唤醒服务端

        while(1)
        {
                pause();
                printf("Client process recevied data from shared memory: %s\n",
                        buffer->buf);
                kill(pid, SIGUSR2);
        }

        shmdt(buffer);
        buffer = NULL;
        shmctl(shmid, IPC_RMID, NULL);

        return 0;
}
\end{code-block}

\subsection{消息队列}
消息队列和管道不一样，它是一种双端循环链表数据结构实现的对象；不过消息队列与共享内存同属于IPC对象，因此，大部分的宏定义对于消息队列都是通用的。
消息队列的创建和删除示例如下（注意，消息队列无法在WSL1下运行）：
\begin{code-block}{c}
#include <stdio.h>
#include <sys/msg.h>

int main(int argc, char * argv[])
{
        int msgid = 0;
        if (0 > (msgid = msgget(IPC_PRIVATE, 0777)))
        {
                printf("Faild to create msg queue\n");
                return -1;
        }
        printf("Msg queue id is %d\n", msgid);
        msgctl(msgid, IPC_RMID, NULL);
        return 0;
}
\end{code-block}

消息队列创建成功之后，就可以向其中进行消息的发送和收取。其中消息的发送需要使用函数msgsnd，该函数包含了4个参数：
\begin{itemize}
  \item msgid：消息队列的id
  \item msgp：指向消息的指针
  \item size：发送的消息正文的字节数
  \item flag：IPC\_NOWAIT，消息没有发送完成，函数也立即返回；0表示必须等待消息发送完毕之后，才返回
\end{itemize}
特别需要注意的是，消息通常使用结构体进行表述，其中至少需要包含2个要素：1是消息的类型；2是消息的正文。常见的消息结构体如下：
\begin{code-block}{c}
struct msgbuf{
        long mtype; // 消息类型
        char mtext[N]; // 消息正文，size的大小就表示该元素的长度
};
\end{code-block}
注意，消息结构体最好只包含上述的元素，如果需要使用额外的字段，或者包含其他的结构体，则必须将其他字段放在
上述结构体原本必须存在的字段的后面，否则可能导致消息无法被读取。合理的自定义消息结构体如下：
\begin{code-block}{c}
struct msgbuf{
        long msgtype;
        char msgtext[N];
        int msgid;
        struct {
            char * child_name;
            uint8_t child_age;
        };
};
\end{code-block}

消息发送到消息队列之后，就可以从消息队列当中进行读取了。读取消息队列当中的内容，需要使用msgrcv函数，该函数包含了5个参数：
\begin{itemize}
  \item msgid：消息队列的id
  \item msgp：指向消息的指针，同消息发送的参数
  \item size：接收的消息正文字节数
  \item msgtype：0表示接受消息队列当中的第一个消息；>0表示接收消息队列当中第一个类型为msgtype的消息；<0表示接收消息队列中类型值不大于msgtype绝对值，但是类型值最小的消息
  \item flag：0表示没有消息则一直阻塞；IPC\_NOWAIT表示如果没有消息，则立即返回ENOMSG
\end{itemize}

特别注意的是，如果使用的是自定义的消息结构体，并且需要读取消息结构体当中的其他字段内容，则发送和接收时，size的大小需要进行变更，
不再是msgtext的大小，而是消息结构体的整体大小。

消息队列简单的示例如下：
\begin{code-block}{c}
#include <stdio.h>
#include <sys/msg.h>
#include <string.h>

typedef struct _msgbuffer{
        long msgtype;
        char mtext[128]; // 第一个和第二个字段必须为long和char，否则，调用msgrcv会无法收到任何消息
        int msgid;
        struct {
            char * child_name;
            unsigned char child_age;
        };
}msgbuffer_t;

int main(int argc, char * argv[])
{
        int msgid = 0;
        if (0 > (msgid = msgget(IPC_PRIVATE, 0777)))
        {
                printf("Faild to create msg queue\n");
                return -1;
        }

        printf("Msg queue id is %d\n", msgid);

        msgbuffer_t buffer, recv;
        buffer.msgtype = 100;
        memset(buffer.mtext, 0, 128);
        strcpy(buffer.mtext, "hello");
        buffer.child_name = "lucifer";
        buffer.child_age = 18;
        buffer.msgid = 18;
        msgsnd(msgid, &buffer, sizeof(buffer), 0);

        memset(recv.mtext, 0, 128);
        int readret = msgrcv(msgid, &recv,
                sizeof(recv), 100, 0);
        printf("Recv msg :%s\n", recv.mtext);
        printf("Read size %d\n", readret);
        printf("Msg.msgid :%d, msg.child_name: %s, msg.child_age: %d\n",
            recv.msgid, recv.child_name, recv.child_age);

        msgctl(msgid, IPC_RMID, NULL);
        return 0;
}
\end{code-block}

消息队列可以实现无亲缘关系的进程间的通信，包括半双工和双工通信。简单的半双工通信方式如下：
\begin{code-block}{c}
// server端的代码
#include <stdio.h>
#include <sys/msg.h>
#include <string.h>
#include <unistd.h>

typedef struct _msgbuffer{
        long msgtype;
        char mtext[128];
        int msgid;
        struct {
            char * child_name;
            unsigned char child_age;
        };
}msgbuffer_t;

int main(int argc, char * argv[])
{
        int msgid = 0;
        int ipckey= 0;
        if (0 > (ipckey = ftok("/var/run", 'r')))
        {
                printf("Failed to create ipc key\n");
                return -1;
        }
        if (0 > (msgid = msgget(ipckey, IPC_CREAT|0777)))
        {
                printf("Faild to create msg queue\n");
                return -1;
        }

        printf("Msg queue id is %d\n", msgid);

        msgbuffer_t buffer;
        buffer.msgtype = 1;
        while(1)
        {
                memset(buffer.mtext, 0, 128);
                strcpy(buffer.mtext, "This is a message");
                buffer.child_name = "lucifer";
                buffer.child_age = 18;
                buffer.msgid = 0;
                msgsnd(msgid, &buffer, sizeof(buffer), 0);
                sleep(2);
        }

        msgctl(msgid, IPC_RMID, NULL);
        return 0;
}

// client端的代码
#include <stdio.h>
#include <sys/msg.h>
#include <string.h>
#include <unistd.h>

typedef struct _msgbuffer{
        long msgtype;
        char mtext[128];
        int msgid;
        struct {
            char * child_name;
            unsigned char child_age;
        };
}msgbuffer_t;

int main(int argc, char * argv[])
{
        int msgid = 0;
        int ipckey= 0;
        if (0 > (ipckey = ftok("/var/run", 'r')))
        {
                printf("Failed to create ipc key\n");
                return -1;
        }
        if (0 > (msgid = msgget(ipckey, IPC_CREAT|0777)))
        {
                printf("Faild to create msg queue\n");
                return -1;
        }

        printf("Msg queue id is %d\n", msgid);

        msgbuffer_t buffer;
        int readret = 0;
        while(1)
        {
                readret = msgrcv(msgid, &buffer,
                        sizeof(msgbuffer_t), 1, 0);
                printf("Recv msg :%s\n", buffer.mtext);
                printf("Read size %d\n", readret);
                printf("msg.child_name: %s, msg.child_age: %d, msg.msgid: %d\n",
                        buffer.child_name, buffer.child_age, buffer.msgid);
        }

        msgctl(msgid, IPC_RMID, NULL);
        return 0;
}
\end{code-block}

而消息队列的全双工通信模式的代码基本如下：
\begin{code-block}{c}
// sever端的代码
#include <stdio.h>
#include <sys/msg.h>
#include <string.h>
#include <unistd.h>

typedef struct _msgbuffer{
        long msgtype;
        char mtext[128];
        int msgid;
        struct {
            char * child_name;
            unsigned char child_age;
        };
}msgbuffer_t;

int main(int argc, char * argv[])
{
        int msgid = 0;
        int ipckey= 0;
        if (0 > (ipckey = ftok("/var/run", 'r')))
        {
                printf("Failed to create ipc key\n");
                return -1;
        }
        if (0 > (msgid = msgget(ipckey, IPC_CREAT|0777)))
        {
                printf("Faild to create msg queue\n");
                return -1;
        }

        printf("Msg queue id is %d\n", msgid);

        pid_t pid = 0;
        if (0 < (pid = fork()))
        {
                msgbuffer_t buffer;
                buffer.msgtype = 1;
                while(1)
                {
                        memset(buffer.mtext, 0, 128);
                        strcpy(buffer.mtext,
                                "Hello client, this is server");
                        buffer.child_name = "lucifer";
                        buffer.child_age = 18;
                        buffer.msgid = 0;
                        msgsnd(msgid, &buffer, sizeof(buffer), 0);
                        sleep(5);
                }
        }
        if (0==pid)
        {
                msgbuffer_t buffer;
                int readret = 0;
                while(1)
                {
                        memset(buffer.mtext, 0, 128);
                        readret = msgrcv(msgid,
                                &buffer, sizeof(msgbuffer_t), 2, 0);
                        printf("Recv msg :%s\n", buffer.mtext);
                        printf("Read size %d\n", readret);
                        printf("Recv data child_age: %d\n",
                                buffer.child_age);
                }
        }


        msgctl(msgid, IPC_RMID, NULL);
        return 0;
}


// 客户端代码
#include <stdio.h>
#include <sys/msg.h>
#include <string.h>
#include <unistd.h>

typedef struct _msgbuffer{
        long msgtype;
        char mtext[128];
        int msgid;
        struct {
            char * child_name;
            unsigned char child_age;
        };
}msgbuffer_t;

int main(int argc, char * argv[])
{
        int msgid = 0;
        int ipckey= 0;
        if (0 > (ipckey = ftok("/var/run", 'r')))
        {
                printf("Failed to create ipc key\n");
                return -1;
        }
        if (0 > (msgid = msgget(ipckey, IPC_CREAT|0777)))
        {
                printf("Faild to create msg queue\n");
                return -1;
        }

        printf("Msg queue id is %d\n", msgid);

        pid_t pid = 0;
        if(0 < (pid=fork()))
        {
                msgbuffer_t buffer;
                int readret = 0;
                while(1)
                {
                        readret = msgrcv(msgid, &buffer,
                                sizeof(msgbuffer_t), 1, 0);
                        printf("Recv msg :%s\n", buffer.mtext);
                        printf("Read size %d\n", readret);
                }

        }
        if (0 == pid)
        {
                msgbuffer_t buffer;
                buffer.msgtype = 2;
                while(1)
                {
                        memset(buffer.mtext, 0, 128);
                        strcpy(buffer.mtext,
                                "Hello server, this is client");
                        buffer.child_name = "lucifer";
                        buffer.child_age = 18;
                        buffer.msgid = 0;
                        msgsnd(msgid, &buffer, sizeof(buffer), 0);
                        sleep(5);
                }
        }

        msgctl(msgid, IPC_RMID, NULL);
        return 0;
}
\end{code-block}

\subsection{信号量/灯}
信号灯是信号量的集合，可以含有多个信号量。信号灯的创建需要使用函数semget，该函数总共有3个参数，其含义如下：
\begin{itemize}
  \item key\_t：与型号等级关联的key值，可以使用IPC\_PRIVATE和ftok，与其他的ipc对象相同
  \item nsems：信号灯集所包含的信号灯数量
  \item semflg：信号灯集的访问权限
\end{itemize}
而信号灯的删除，则需要使用semctl函数，该函数与其他的ipc对象的操作类似：
\begin{itemize}
  \item semid：信号灯集的id
  \item semnum：要改变的信号灯的编号
  \item cmd：GETVAL，获取信号灯的值；SETVAL，设置信号灯的值；IPC\_RMID，删除信号灯集合
  \item semun arg：修改或获取信号灯的属性时需要，本身为可选参数
\end{itemize}
信号灯的简单创建和删除，如下：
\begin{code-block}{c}
#include <stdio.h>
#include <sys/sem.h>

int main(int argc, char * argv[])
{
        int semid = 0;
        if (0 > (semid = semget(IPC_PRIVATE, 3, 0777)))
        {
                printf("Faild to create sem \n");
                return -1;
        }
        printf("sem id is %d\n", semid);
        semctl(semid, 0, IPC_RMID); // 等效于semctl(semid, 0, IPC_RMID,NULL);
        return 0;
}
\end{code-block}

信号灯集可以在进程间，也可以在线程间进行通信。如下的，在线程中通信使用信号灯：
\begin{code-block}{c}
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/sem.h>
#include <sys/ipc.h>
#include <stdlib.h>

int semid = 0;

typedef union _semun {
        int val;
        struct semid_ds *buf;
        unsigned short  *array;
        struct seminfo  *__buf;
}semun_u;

struct sembuf sbuf;

void * func(void * var)
{
        int i = 0;
        sbuf.sem_op = -1;
        semop(semid, &sbuf, 1);
        while(i< 10)
        {
                usleep(100);
                printf("This is func i=%d\n", i++);
        }
}

int main(int argc, char * argv[])
{
        int i = 0;
        char buf[] = "hello world";
        pthread_t tid = 0;
        int ret = 0;
        if (0 > (semid = semget(IPC_PRIVATE, 3, 0777)))
        {
                printf("Failed to create sem\n");
                return -1;
        }
        printf("%d\n", sizeof(buf));
        semun_u se;
        se.val = 0;
        semctl(semid, 0, SETVAL, se);
        sbuf.sem_flg = 0;
        sbuf.sem_num = 0;

        if(0 > (ret = pthread_create(&tid, NULL, func, buf)))
        {
                printf("Failed to create thread \n");
                return -1;
        }

        while(i < 10)
        {
                usleep(100);
                printf("This is man fun i=%d\n",i++);
        }
        sbuf.sem_op = 1;
        semop(semid, &sbuf, 1);
        sleep(5);
        return 0;
}

// 信号量的版本
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <semaphore.h>

sem_t sem;

void * func(void * var)
{
        int i = 0;
        sem_wait(&sem);
        while(i< 10)
        {
                usleep(100);
                printf("This is func i=%d\n", i++);
        }
}

int main(int argc, char * argv[])
{
        int i = 0;
        char buf[] = "hello world";
        pthread_t tid = 0;
        int ret = 0;
        sem_init(&sem, 0, 0);
        if(0 > (ret = pthread_create(&tid, NULL, func, buf)))
        {
                printf("Failed to create thread \n");
                return -1;
        }

        while(i < 10)
        {
                usleep(100);
                printf("This is man fun i=%d\n",i++);
        }
        sem_post(&sem);
        sleep(5);
        return 0;
}
\end{code-block}

由于使用了pthread，因此，编译的时候，需要加上参数：
\begin{code-block}{bash}
gcc -pthread -o sem sem.c
\end{code-block}

信号量也可以用于进程间的通信，具体的可见如下示例：
\begin{code-block}{c}
// 服务器端
#include <stdio.h>
#include <sys/sem.h>

typedef union _semun {
        int val;
        struct semid_ds *buf;
        unsigned short  *array;
        struct seminfo  *__buf;
}semun_u;

int main(int argc, char * argv[])
{
        key_t key = 0;
        if (0 > (key = ftok("/var/run", 'v')))
        {
                printf("Failed to creat key\n");
                return -1;
        }
        int semid = 0;
        if (0 > (semid = semget(key, 3, IPC_CREAT|0777)))
        {
                printf("Failed to create sem\n");
                return -1;
        }
        //semun_u se;
        //se.val = 0;
        //semctl(semid, 0, SETVAL, se);

        struct sembuf sbuf;
        sbuf.sem_flg = 0;
        sbuf.sem_num = 0;

        int i = 0;
        while(i < 10)
        {
                usleep(100);
                printf("This is man fun i=%d\n",i++);
        }
        sbuf.sem_op = 1;
        semop(semid, &sbuf, 1);
        return 0;
}

// 客户端
#include <stdio.h>
#include <sys/sem.h>

typedef union _semun {
        int val;
        struct semid_ds *buf;
        unsigned short  *array;
        struct seminfo  *__buf;
}semun_u;

struct sembuf sbuf;

int main(int argc, char * argv[])
{
        key_t key = 0;
        if (0 > (key = ftok("/var/run", 'v')))
        {
                printf("Failed to creat key\n");
                return -1;
        }
        int semid = 0;
        if (0 > (semid = semget(key, 3, IPC_CREAT|0777)))
        {
                printf("Failed to create sem\n");
                return -1;
        }
        semun_u se;
        se.val = 0;
        semctl(semid, 0, SETVAL, se);
        sbuf.sem_flg = 0;
        sbuf.sem_num = 0;
        sbuf.sem_op = -1;
        semop(semid, &sbuf, 1);

        int i = 0;
        while(i < 10)
        {
                usleep(100);
                printf("This is man fun i=%d\n",i++);
        }
        return 0;
}
\end{code-block}

\section{多线程}
进程是一个正在执行的程序，是资源分配的最小单位。进程需要按照一定的循序逐次执行。线程称之为轻量级的进程，是程序执行的最小单位，系统
独立调度和分配cpu的基本单位，是进程中的一个实体。一个进程可以有多个线程，所有线程共享进程的所有资源。进程是资源的拥有者，但是，创建，
删除以及切换需要消耗较大的时间和空间开销，并且子进程需要复制父进程的所有资源；而对称多处理机（SMP）可以满足多个运行单位。
获取线程id的方式如下：
\begin{code-block}{c}
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

int main(int argc, char * argv[])
{
        pid_t pid = 0;
        pthread_t tid = 0;
        pid = getpid();
        tid = pthread_self();
        printf("The pid is %u and tid is %x\n", pid, tid);
        return 0;
}
\end{code-block}

需要注意的是，pthread\_id在Linux当中是整形的别名，但是Unix当中是结构体，2者不一样。线程的创建需要使用函数pthread\_create，该函数有4个参数：
\begin{itemize}
  \item thread：如果创建成功，返回的新线程的id
  \item attr：线程属性，包括调度策略，继承性和分离性
  \item start\_routine：回调函数，即新线程需要执行的功能
  \item arg：回调函数的参数
\end{itemize}
如果线程传递成功，则返回0， 反之返回错误码。简单的示例如下：
\begin{code-block}{c}
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

void print_id(char * s)
{
        pid_t pid;
        pthread_t tid;
        pid = getpid();
        tid = pthread_self();
        printf("%s Pid is %u, and tid is %x\n", s, pid, tid);
}

void * fun(void * arg)
{
        print_id(arg);
        return NULL;
}

int main(int argc, char * argv[])
{
        pthread_t npid;
        int err = 0;
        if (err=pthread_create(&npid, NULL, fun, "newthread"))
        {
                printf("Faild to creat thread\n");
                return -1;
        }
        print_id("main thread");
        int ret = 0;
        pthread_exit(&ret);
        return 0;
}
\end{code-block}

程序运行时，首先运行的是main函数，即主线程或称之为初始线程。在初始线程当中，可以做任何普通线程可以做的事情。但是，主线程在main函数返回或者退出的时候，
会导致进程结束，因此，通常的，需要在主线程当中调用pthread\_exit函数，等待所有线程结束之后才终止。绝大多数情况下，主线程在默认堆栈上
运行，但是普通线程的堆栈，是受限制的，一旦溢出，就会出现错误。

主线程是随着进程的创建而创建的，新的线程可能在pthread\_create返回之前就已经运行，甚至运行完毕了。多线程也可以进行结构体的传递，如下：
\begin{code-block}{c}
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

typedef struct _student {
        unsigned char age;
        char name[32];
}student_t;

// 定义函数指针别名，如果不如此定义，则线程的函数，则必须写作
// void * func (void *)的形式，需要在线程函数内部做类型的强制类型转换
typedef void *(*start_routine)(void *);

void * printstu(student_t * stu_t)
{
        printf("The student info is name :%s, and age: %d\n",
                stu_t->name, stu_t->age);
        return NULL;
}

int main(int argc, char * argv[])
{
        pthread_t npid;
        int err = 0;
        student_t stu = {18, "zhangjl"};
        if (err=pthread_create(
                &npid, NULL, (start_routine)printstu, &stu))
        {
                printf("Faild to creat thread\n");
                return -1;
        }
        int ret = 0;
        pthread_exit(&ret);
        return 0;
}
\end{code-block}

与进程一样，线程也有自己的状态：
\begin{itemize}
  \item 就绪：线程能够运行，但在等待可用的处理器
  \item 运行：线程正在运行
  \item 阻塞：线程在等待其他条件就绪
  \item 终止：线程声明周期结束
\end{itemize}
线程的状态转换如图\nameref{fig:status_of_thread}所示
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{status_of_thread.png}
  \caption{线程的状态转换}
  \label{fig:status_of_thread}
\end{figure}

线程的分离属性：分离一个正在运行的线程并不影响他，仅仅是通知当前系统，如果该线程结束，其所属的资源可以回收；一个没有被分离的线程在终止时
会保留它的虚拟内存，包括对应的堆栈和其他系统资源，这种线程通称为僵尸线程。需要注意的是，线程创建时，默认是非分离的。

如果线程具有分离属性，则线程终止是会被立刻回收，回收操作将释放所有在线程终止是为释放的系统资源和进程资源，包括保存线程返回值的内存空间。
终止被分离的线程会释放所有的系统资源，并且必须释放由该线程所占有的程序资源。

线程的退出最好不要使用exit函数，该函数会导致整个进程的终止。正常的线程终止操作通常如下：
\begin{itemize}
  \item 从启动线程中返回，返回值是线程的退出码
  \item 可以被同一进程的其他线程取消
  \item 调用pthread\_exit函数退出
\end{itemize}

阻塞线程通常使用pthread\_join函数，调用该函数，对应的线程会一直阻塞，直到指定的线程调用pthread\_exit，或者从启动的线程返回，或者被取消。
一点调用pthread\_join函数，会使指定的线程处于分离状态。如果调用函数pthread\_detach，也会分离线程。
