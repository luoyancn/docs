\subsection{过程宏案例-派生过程宏Builder深入}
通常情况下，Rust的结构体并不是要求所有的字段都必须有值，或者必须初始化，存在可选的
字段，因此，可以继续对Builder过程宏进行改造。比如将上例当中的
\codeinlinebg{rust}{Command}结构体
定义修改为如下：
\begin{code-block}{rust}
pub struct Command {
    executable: String,
    args: Vec<String>,
    env: Vec<String>,
    current_dir: Option<String>,
}
\end{code-block}
即\codeinlinebg{rust}{current_dir}
为可选字段，而Builder生成的结构体\codeinlinebg{rust}{CommandBuilder}
则如下：
\begin{code-block}{rust}
pub struct CommandBuilder {
    executable: Option<String>,
    args: Option<Vec<String>>,
    env: Option<Vec<String>>,
    current_dir: Option<String>,
}
\end{code-block}

而这样的结构体，如果将其展开为语法树，原始结构体的\codeinlinebg{rust}{current_dir}
字段形式大致如下：
\begin{code-block}{json}
Path(
    TypePath {
        qself: None,
        path: Path {
            leading_colon: None,
            segments: [
                PathSegment {
                    ident: Ident {
                        ident: "Option",
                        span: #0 bytes(1337..1343),
                    },
                    arguments: AngleBracketed(
                        AngleBracketedGenericArguments {
                            colon2_token: None,
                            lt_token: Lt,
                            args: [
                                Type(
                                    Path(
                                        TypePath {
                                            qself: None,
                                            path: Path {
                                                leading_colon: None,
                                                segments: [
                                                    PathSegment {
                                                        ident: Ident {
                                                            ident: "String",
                                                            span: #0 bytes(1344..1350),
                                                        },
                                                        arguments: None,
                                                    },
                                                ],
                                            },
                                        },
                                    ),
                                ),
                            ],
                            gt_token: Gt,
                        },
                    ),
                },
            ],
        },
    },
)
\end{code-block}
相比之下，普通的字段类型，其语法树结构可能如下：
\begin{code-block}{rust}
Path(
    TypePath {
        qself: None,
        path: Path {
            leading_colon: None,
            segments: [
                PathSegment {
                    ident: Ident {
                        ident: "String",
                        span: #0 bytes(1267..1273),
                    },
                    arguments: None,
                },
            ],
        },
    },
)
\end{code-block}
可以看到，2者的区别比较大。如果还是沿用上一个示例的方式进行Builder的构建，会出现
这样一个问题：Builder宏所生成的结构体会被处理成如下的形式：
\begin{code-block}{rust}
pub struct CommandBuilder {
    executable: std::option::Option<String>,
    args: std::option::Option<Vec<String>>,
    env: std::option::Option<Vec<String>>,
    current_dir: std::option::Option<Option<String>>,   // 被多层Option封装
}
\end{code-block}
上面的形式显然无法满足我们的需求。因此，为达到上述目的，需要对字段的类型进行进
一步的处理。对于过程宏而言（syn包），字段的类型是一个结构体，其定义大致如下\footnote{类型的定义：\url{https://docs.rs/syn/1.0.72/syn/enum.Type.html}}：
\begin{code-block}{rust}
pub enum Type {
    Array(TypeArray),
    BareFn(TypeBareFn),
    Group(TypeGroup),
    ImplTrait(TypeImplTrait),
    Infer(TypeInfer),
    Macro(TypeMacro),
    Never(TypeNever),
    Paren(TypeParen),
    Path(TypePath),
    Ptr(TypePtr),
    Reference(TypeReference),
    Slice(TypeSlice),
    TraitObject(TypeTraitObject),
    Tuple(TypeTuple),
    Verbatim(TokenStream),
    // some variants omitted
}
\end{code-block}

需要做的，就是对字段类型的语法树进行解构，一步一步的按照需求，准确的定位Option所标识的
字段，并将其的内层类型取出来。因此，需要对上一章节\colorunderlineref{builder}的代码进行重构。

首先需要实现的，就是对可选字段（Option）的语法树定位和处理，并且返回对应的TokenStream：
\begin{code-block}{rust}
fn get_option_fields(st: &syn::Type) -> Option<&syn::Type> {
    // 对type语法树进行解构
    if let syn::Type::Path(syn::TypePath {
        path: syn::Path { segments, .. },
        ..
    }) = st
    {
        if let Some(segment) = segments.last() {
            // 找到Option字段
            if segment.ident.to_string() == "Option" {
                {
                    if let syn::PathArguments::AngleBracketed(
                        syn::AngleBracketedGenericArguments { ref args, .. },
                    ) = segment.arguments
                    {
                        // 获得真实的数据类型
                        if let Some(syn::GenericArgument::Type(inner_type)) = args.first() {
                            return Some(inner_type);
                        }
                    }
                }
            }
        }
    }
    None
}
\end{code-block}
然后，根据需求，将原有的代码进行改写，比如，Builder的结构体字段定义函数，需要修改
\begin{code-block}{rust}
fn generate_builder_struct_fields_def(
    st: &syn::DeriveInput,
) -> syn::Result<proc_macro2::TokenStream> {
    ...
    let types: Vec<_> = fields
        .iter()
        .map(|f| {
            if let Some(ty) = get_option_fields(&f.ty) {
                ty
            } else {
                &f.ty
            }
        })
        .collect();
    ...
}
\end{code-block}
Builder的setter方法需要修改：
\begin{code-block}{rust}
fn generate_setter(st: &syn::DeriveInput) -> syn::Result<proc_macro2::TokenStream> {
    ...
    for (ident, type_) in idents.iter().zip(types.iter()) {
        let token_stream_slice = if let Some(inner_type) = get_option_fields(type_) {
            quote! {
                pub fn #ident(&mut self, #ident: #inner_type) -> & mut Self {
                    self.#ident = std::option::Option::Some(#ident);
                    self
                }
            }
        } else {
            quote! {
                pub fn #ident(&mut self, #ident: #type_) -> & mut Self {
                    self.#ident = std::option::Option::Some(#ident);
                    self
                }
            }
        };
        final_token_stream.extend(token_stream_slice);
    }
    ...
}
\end{code-block}
同样的，Builder的字段检查和初始化方法也需要修改：
\begin{code-block}{rust}
fn check_fileds(st: &syn::DeriveInput) -> syn::Result<proc_macro2::TokenStream> {
    let fields = get_filed_from_derive_input(st)?;
    let idents: Vec<_> = fields.iter().map(|f| &f.ident).collect();
    let types: Vec<_> = fields.iter().map(|f| &f.ty).collect();
    let mut final_check_stream = proc_macro2::TokenStream::new();
    for (ident, type_) in idents.iter().zip(types.iter()) {
        if get_option_fields(type_).is_some() {
            continue;
        }
        let check_stream_slice = quote! {
            if self.#ident.is_none() {
                let err_msg = format!("{} field is missing", stringify!(#ident));
                return std::result::Result::Err(err_msg.into());
            }
        };
        final_check_stream.extend(check_stream_slice);
    }
    Ok(final_check_stream)
}

fn build_target_fields(st: &syn::DeriveInput) -> syn::Result<proc_macro2::TokenStream> {
    let fields = get_filed_from_derive_input(st)?;
    let idents: Vec<_> = fields.iter().map(|f| &f.ident).collect();
    let types: Vec<_> = fields.iter().map(|f| &f.ty).collect();
    let mut final_init_stream = proc_macro2::TokenStream::new();
    for (ident, types_) in idents.iter().zip(types.iter()) {
        let init_stream_slice = if get_option_fields(types_).is_none() {
            quote! {
                #ident: self.#ident.clone().unwrap(),
            }
        } else {
            quote! {
                #ident: self.#ident.clone(),
            }
        };
        final_init_stream.extend(init_stream_slice);
    }
    Ok(final_init_stream)
}
\end{code-block}

改造之后的完整代码如下：
\begin{code-block}{rust}
use proc_macro::TokenStream;
use proc_macro2;
use quote::quote;
use syn::{self, parse_macro_input, spanned::Spanned};
#[proc_macro_derive(Builder)]
pub fn derive(input: TokenStream) -> TokenStream {
    let st = parse_macro_input!(input as syn::DeriveInput);
    match do_expand(&st) {
        Ok(token_stream) => token_stream.into(),
        Err(error) => error.to_compile_error().into(),
    }
}
fn do_expand(st: &syn::DeriveInput) -> syn::Result<proc_macro2::TokenStream> {
    let struct_name_literal = st.ident.to_string();
    let builder_name_literal = format!("{}Builder", struct_name_literal);
    let builder_name_ident = syn::Ident::new(&builder_name_literal, st.span());
    let struct_name_ident = &st.ident;
    let builder_struct_fields_def = generate_builder_struct_fields_def(st)?;
    let builder_struct_fields_init = generate_builder_struct_fields_init(st)?;
    let setter_functions = generate_setter(st)?;
    let checked_res = check_fileds(st)?;
    let build_res = build_target_fields(st)?;
    let ret = quote!(
        pub struct #builder_name_ident {
            #builder_struct_fields_def
        }
        impl #struct_name_ident {
            pub fn builder() -> #builder_name_ident {
                #builder_name_ident {
                    #(#builder_struct_fields_init),*
                }
            }
        }
        impl #builder_name_ident {
            #setter_functions
            pub fn build(&mut self) -> std::result::Result<#struct_name_ident, std::boxed::Box<dyn std::error::Error>>{
                #checked_res
                Ok(#struct_name_ident {
                    #build_res
                })
            }
        }
    );
    Ok(ret)
}
fn check_fileds(st: &syn::DeriveInput) -> syn::Result<proc_macro2::TokenStream> {
    let fields = get_filed_from_derive_input(st)?;
    let idents: Vec<_> = fields.iter().map(|f| &f.ident).collect();
    let types: Vec<_> = fields.iter().map(|f| &f.ty).collect();
    let mut final_check_stream = proc_macro2::TokenStream::new();
    for (ident, type_) in idents.iter().zip(types.iter()) {
        if get_option_fields(type_).is_some() {
            continue;
        }
        let check_stream_slice = quote! {
            if self.#ident.is_none() {
                let err_msg = format!("{} field is missing", stringify!(#ident));
                return std::result::Result::Err(err_msg.into());
            }
        };
        final_check_stream.extend(check_stream_slice);
    }
    Ok(final_check_stream)
}
fn build_target_fields(st: &syn::DeriveInput) -> syn::Result<proc_macro2::TokenStream> {
    let fields = get_filed_from_derive_input(st)?;
    let idents: Vec<_> = fields.iter().map(|f| &f.ident).collect();
    let types: Vec<_> = fields.iter().map(|f| &f.ty).collect();
    let mut final_init_stream = proc_macro2::TokenStream::new();
    for (ident, types_) in idents.iter().zip(types.iter()) {
        let init_stream_slice = if get_option_fields(types_).is_none() {
            quote! {
                #ident: self.#ident.clone().unwrap(),
            }
        } else {
            quote! {
                #ident: self.#ident.clone(),
            }
        };
        final_init_stream.extend(init_stream_slice);
    }
    Ok(final_init_stream)
}
fn generate_setter(st: &syn::DeriveInput) -> syn::Result<proc_macro2::TokenStream> {
    let fields = get_filed_from_derive_input(st)?;
    let idents: Vec<_> = fields.iter().map(|f| &f.ident).collect();
    let types: Vec<_> = fields.iter().map(|f| &f.ty).collect();
    let mut final_token_stream = proc_macro2::TokenStream::new();
    for (ident, type_) in idents.iter().zip(types.iter()) {
        let token_stream_slice = if let Some(inner_type) = get_option_fields(type_) {
            quote! {
                pub fn #ident(&mut self, #ident: #inner_type) -> & mut Self {
                    self.#ident = std::option::Option::Some(#ident);
                    self
                }
            }
        } else {
            quote! {
                pub fn #ident(&mut self, #ident: #type_) -> & mut Self {
                    self.#ident = std::option::Option::Some(#ident);
                    self
                }
            }
        };
        final_token_stream.extend(token_stream_slice);
    }
    Ok(final_token_stream)
}
type StructFields = syn::punctuated::Punctuated<syn::Field, syn::Token![,]>;
fn get_filed_from_derive_input(st: &syn::DeriveInput) -> syn::Result<&StructFields> {
    if let syn::Data::Struct(syn::DataStruct {
        fields: syn::Fields::Named(syn::FieldsNamed { ref named, .. }),
        ..
    }) = st.data
    {
        return Ok(named);
    }
    Err(syn::Error::new_spanned(
        st,
        "Must define on Struct, Not on Enum",
    ))
}
fn generate_builder_struct_fields_def(
    st: &syn::DeriveInput,
) -> syn::Result<proc_macro2::TokenStream> {
    let fields = get_filed_from_derive_input(st)?;
    let idents: Vec<_> = fields.iter().map(|f| &f.ident).collect();
    let types: Vec<_> = fields
        .iter()
        .map(|f| {
            if let Some(ty) = get_option_fields(&f.ty) {
                ty
            } else {
                &f.ty
            }
        })
        .collect();
    let ret = quote! {
        #(#idents: std::option::Option<#types>), *
    };
    Ok(ret)
}
fn get_option_fields(st: &syn::Type) -> Option<&syn::Type> {
    if let syn::Type::Path(syn::TypePath {
        path: syn::Path { segments, .. },
        ..
    }) = st
    {
        if let Some(segment) = segments.last() {
            if segment.ident.to_string() == "Option" {
                {
                    if let syn::PathArguments::AngleBracketed(
                        syn::AngleBracketedGenericArguments { ref args, .. },
                    ) = segment.arguments
                    {
                        if let Some(syn::GenericArgument::Type(inner_type)) = args.first() {
                            return Some(inner_type);
                        }
                    }
                }
            }
        }
    }
    None
}
fn generate_builder_struct_fields_init(
    st: &syn::DeriveInput,
) -> syn::Result<Vec<proc_macro2::TokenStream>> {
    let fields = get_filed_from_derive_input(st)?;
    let init_data: Vec<_> = fields
        .iter()
        .map(|f| {
            let ident = &f.ident;
            quote! {
                #ident: std::option::Option::None
            }
        })
        .collect();
    Ok(init_data)
}
\end{code-block}

完成上述操作之后，在主函数当中，就可以以多种方式进行builder的初始化：
\begin{code-block}{rust}
fn main(){
    let builder = Command::builder()
        .executable("lucifer".to_owned())
        .args(vec![])
        .env(vec![])
        .current_dir("target".to_owned())
        .build()
        .unwrap();
    info!("{:#?}", builder);
    let builder = Command::builder()
        .executable("lucifer".to_owned())
        .args(vec![])
        .env(vec!["titans".to_owned(), "garuda".to_owned()])
        .build()
        .unwrap();
    info!("{:#?}", builder);
}
#[derive(Debug, Builder)]
pub struct Command {
    executable: String,
    args: Vec<String>,
    env: Vec<String>,
    current_dir: Option<String>,
}
\end{code-block}

\subsection{过程宏案例-派生过程宏Builder的派生属性}
\label{builder_attribute}
如果继续进行深入，考虑下面的一种形式：
\begin{code-block}{rust}
#[derive(Builder)]
pub struct Command {
    executable: String,
    #[builder(each = "arg")]
    args: Vec<String>,
    #[builder(each = "env")]
    env: Vec<String>,
    current_dir: Option<String>,
}
fn main() {
    ...
    let builder = Command::builder()
        .executable("lucifer".to_owned())
        .arg("first")
        .arg("second")
        .env(vec!["titans".to_owned(), "garuda".to_owned()])
        .build()
        .unwrap();
}
\end{code-block}
即，使用\codeinlinebg{rust}{#[builder(each = "arg")]}
这样的代码对结构体的字段进行标记，标记之后，原本对结构体进行初始化，使用的是一个vec结构（args），
后续可以使用单个元素（arg）进行追加的方式进行初始化。通常来说，实现这种宏，都应该要求builder当中的标签
和真实的属性名之间最好有区别。如果要求标签和属性名相同，则需要进行额外的其他特殊处理，即需要避免生成一个一次性通过列表进行赋值的方法。
以上述代码为例，如果使用builder宏装饰env字段，并且标签也是env，那么，针对env字段，最好的方式就是不要实现一个
使用列表直接复制的函数，即\codeinlinebg{rust}{builder.env("something")}与
\codeinlinebg{rust}{builder.env(vec!["nothing", "ok"])}这2种形式
无法并存，只能存在第一个。另外的重点是，这个builder宏，只能在被使用了
\codeinlinebg{rust}{#[derive(Builder)]}
修饰之后的结构体当中使用，而不能单独使用，因此，类似builder的宏被称之为惰性属性
宏，其完整的定义形式，一般是\codeinline{rust}{#[proc_macro_derive(Builder, attributes(builder))]}
这种。

由于上述需求的存在，在处理arg和env参数时，就无法再套用之前例子当中的Option类型来
包裹这两个参数了，换言之，对于增加了标签\codeinline{rust}{#[builder(each="arg")]}的
字段，就不能将其在Builder当中处理成Option类型，而是必须保留成Vec类型，即该结构所对应
的Builder结构体，其展开的内容应当如下所示：
\begin{code-block}{rust}
pub struct CommandEachBuilder {
    executable: std::option::Option<String>,
    args: Vec<String>,
    env: Vec<String>,
    current_dir: std::option::Option<String>,
}
\end{code-block}
这点在后续的处理当中非常重要。

惰性属性宏与常见的属性过程宏基本上是一样的，因此，在处理惰性属性宏之前，先看看
常见的属性是什么样式的。简单的查看结构体的属性语法树结构，可以如下进行操作：
\begin{code-block}{rust}
#[proc_macro_derive(Test)]
pub fn do_test(input: TokenStream) -> TokenStream {
    let st = parse_macro_input!(input as syn::DeriveInput);
    let attr = st.attrs.first().unwrap();
    eprintln!("{:#?}", attr);
    proc_macro2::TokenStream::new().into()
}
...
#[derive(Test)]
#[blog::com(Bar)]
pub struct CommandEach {
    executable: String,
    args: Vec<String>,
    ...
}
fn main() {
    ...
}
\end{code-block}
通过eprint函数，可以得到关于属性Attribute的详细信息：
\begin{code-block}{json}
Attribute {
    pound_token: Pound,
    style: Outer,
    bracket_token: Bracket,
    path: Path {
        leading_colon: None,
        segments: [
            PathSegment {
                ident: Ident {
                    ident: "blog",
                    span: #0 bytes(1402..1406),
                },
                arguments: None,
            },
            Colon2,
            PathSegment {
                ident: Ident {
                    ident: "com",
                    span: #0 bytes(1408..1411),
                },
                arguments: None,
            },
        ],
    },
    tokens: TokenStream [
        Group {
            delimiter: Parenthesis,
            stream: TokenStream [
                Ident {
                    ident: "Bar",
                    span: #0 bytes(1412..1415),
                },
            ],
            span: #0 bytes(1411..1416),
        },
    ],
}
\end{code-block}
在上述的输出当中，需要关注的有几个点：
\begin{enumerate}
  \item 属性的style值为Outer，如果对结构体的装饰变成了\codeinlinebg{rust}{#![derive]}这种，则style会变成Inner
  \item Rust会把属性拆分成2部分，path和tokens，其中path表示路径，tokens则是一个原始的TokenStream，并没有变成语法树节点，仅仅只是做了分词处理，没有任何语义，需要自行解析，因此，可以在其中加入自己规定的语法结构
  \item path指导编译器决定如何处理后面的部分
  \item tokens如果本身是一个符合Rust语法规范的结构，可以采用\codeinlinebg{rust}{parse_meta}方法将path和tokens解析成为\codeinlinebg{rust}{syn::Meta}数据类型，使之成为独立的语法树节点
\end{enumerate}

关于\codeinlinebg{rust}{syn::Meta}\footnote{类型定义：\url{https://docs.rs/syn/1.0.73/syn/enum.Meta.html}}
数据类型，其中包含3种：
\begin{enumerate}
  \item \codeinlinebg{rust}{syn::Meta::Path}表示一个路径，\codeinlinebg{rust}{#[A]}只有一个小节，但是A也是一个Path；\codeinlinebg{rust}{#[A::B::C]}也是一个Path，但是会被拆分成多个PathSegment。
  \item \codeinlinebg{rust}{syn::Meta::List}表示一个列表，这个列表必须由一个前置路径和一个括号标记组成，括号内部的内容通过逗号分割为多个条目（组成列表），每个条目又是一个\codeinlinebg{rust}{syn::Meta}
数据类型。比如\codeinlinebg{rust}{#[Foo(AA,BB,CC)]}当中，Foo就是前置路径，而AA等则是列表项，同时，也是\codeinlinebg{rust}{syn::Meta}数据类型；
而\codeinlinebg{rust}{#[Foo(AAA,BBB(CCC,DDD))]}表示列表可以嵌套，Foo是全局的前置路径，而BBB是内层\codeinlinebg{rust}{syn::Meta::List}的前置路径。
  \item \codeinlinebg{rust}{syn::Meta::NameValue}则是常见的键值对，key部分是一个\codeinlinebg{rust}{syn::Path}类型，而value则通常是字符串。比如
\codeinlinebg{rust}{#[xxx="yyy"]}。默认情况下，kv对只能有一对，如果需要有多个kv对，则必须使用list类型，即\codeinline{rust}{#[Foo(x="y",w="z")]}这种形式。
\end{enumerate}
只要是attr符合上述标准，则可以使用\codeinlinebg{rust}{parse_meta}函数对其进行解析，比如下面的例子：
\begin{code-block}{rust}
#[proc_macro_derive(Test)]
pub fn do_test(input: TokenStream) -> TokenStream {
    let st = parse_macro_input!(input as syn::DeriveInput);
    let attr = st.attrs.first().unwrap();
    // 直接解析attr，将attr解析成Rust的语法树节点
    let meta = attr.parse_meta();
    eprintln!("{:#?}", meta);
    proc_macro2::TokenStream::new().into()
}
...
#[derive(Test)]
#[Foo(x = "lucifer")]
pub struct CommandEach {
    executable: String,
    args: Vec<String>,
...
}
\end{code-block}
上述代码通过\codeinlinebg{bash}{cargo check}之后，可以得到类似如下的结果：
\begin{code-block}{json}
Ok(
    List(
        MetaList {
            path: Path {
                leading_colon: None,
                segments: [
                    PathSegment {
                        ident: Ident {
                            ident: "Foo",
                            span: #0 bytes(1414..1417),
                        },
                        arguments: None,
                    },
                ],
            },
            paren_token: Paren,
            nested: [
                Meta(
                    NameValue(
                        MetaNameValue {
                            path: Path {
                                leading_colon: None,
                                segments: [
                                    PathSegment {
                                        ident: Ident {
                                            ident: "x",
                                            span: #0 bytes(1418..1419),
                                        },
                                        arguments: None,
                                    },
                                ],
                            },
                            eq_token: Eq,
                            lit: Str(
                                LitStr {
                                    token: "lucifer",
                                },
                            ),
                        },
                    ),
                ),
            ],
        },
    ),
)
\end{code-block}

在Rust的语法树当中，如果对一个结构体的字段进行展开，其基本
的语法树结构可能如下：
\begin{code-block}{json}
Field {
    attrs: [],
    vis: Inherited,
    ident: Some(
        Ident {
            ident: "executable",
            span: #0 bytes(1429..1439),
        },
    ),
    colon_token: Some(
        Colon,
    ),
    ty: Path(
        TypePath {
            qself: None,
            path: Path {
                leading_colon: None,
                segments: [
                    PathSegment {
                        ident: Ident {
                            ident: "String",
                            span: #0 bytes(1441..1447),
                        },
                        arguments: None,
                    },
                ],
            },
        },
    ),
}
\end{code-block}
即，每个结构体字段都带有attrs（属性）标记。上述语法树为不带属性标记的字段，而
如果是类似本节开头的部分，在env和args上设置了属性标记，该字段的语法树会变为如下的
模式：
\begin{code-block}{json}
Field {
    attrs: [
        Attribute {
            pound_token: Pound,
            style: Outer,
            bracket_token: Bracket,
            path: Path {
                leading_colon: None,
                segments: [
                    PathSegment {
                        ident: Ident {
                            ident: "builder",
                            span: #0 bytes(1455..1462),
                        },
                        arguments: None,
                    },
                ],
            },
            tokens: TokenStream [
                Group {
                    delimiter: Parenthesis,
                    stream: TokenStream [
                        Ident {
                            ident: "each",
                            span: #0 bytes(1463..1467),
                        },
                        Punct {
                            ch: '=',
                            spacing: Alone,
                            span: #0 bytes(1468..1469),
                        },
                        Literal {
                            kind: Str,
                            symbol: "arg",
                            suffix: None,
                            span: #0 bytes(1470..1475),
                        },
                    ],
                    span: #0 bytes(1462..1476),
                },
            ],
        },
    ],
    ...
},
\end{code-block}
需要注意的是，上述语法树内容，全部表示的是结构体字段的属性标记，并非结构体字段
本身的语法树结构，可以看到，其结构和原始的Attribute是相同的。属性标签是Rust当中
常用的标签，也非常灵活。

回到本案例的需求，针对包含有属性标签字段的结构体，首先需要解决的，就是找到这些
带有标签的结构体字段：
\begin{code-block}{rust}
fn get_attr_field_ident(field: &syn::Field) -> Option<syn::Ident> {
    for attr in &field.attrs {
        if let Ok(syn::Meta::List(syn::MetaList {
            ref path,
            ref nested,
            ..
        })) = attr.parse_meta()
        {
            if let Some(__path__) = path.segments.first() {
                if __path__.ident == "builder" {
                    if let Some(syn::NestedMeta::Meta(syn::Meta::NameValue(__dict__))) =
                        nested.first()
                    {
                        if __dict__.path.is_ident("each") {
                            if let syn::Lit::Str(ref arg_token) = __dict__.lit {
                                return Some(syn::Ident::new(
                                    arg_token.value().as_str(),
                                    attr.span(),
                                ));
                            }
                        }
                    }
                }
            }
        }
    }
    None
}
\end{code-block}
上述代码的作用，就是遍历字段的属性（Attr），对其进行解构，如果存在\codeinline{rust}{builder="each"}这种模式的标签，则返回
找到的标签字段（即本例当中的each字段标签），解构的内容参照之前的属性被解析成Meta的相关内容。

获得字段的标签属性之后，接下来就是对结构体的字段进行处理。由于对字段添加了标签，
原有的处理方式已经不太适用了，新的处理方式需要考虑至少3种不同的情况：
\begin{enumerate}
  \item 必需的原始类型被Option包裹
  \item 保留原始的Vec类型
  \item 使用Option包裹可选的原始类型
\end{enumerate}
在开始处理这些结构体字段之前，需要首先了解每一种结构体字段的语法树结构大致是什么
样子，才可以有的放矢，比如，不带标签的标量数据类型（即常见的String，int等没有使用
Vec或者Option包裹的数据类型）的语法树大致如下：
\begin{code-block}{json}
Field {
    attrs: [],
    vis: Inherited,
    ident: Some(
        Ident {
            ident: "executable",
            span: #0 bytes(1686..1696),
        },
    ),
    colon_token: Some(
        Colon,
    ),
    ty: Path(
        TypePath {
            qself: None,
            path: Path {
                leading_colon: None,
                segments: [
                    PathSegment {
                        ident: Ident {
                            ident: "String",
                            span: #0 bytes(1698..1704),
                        },
                        arguments: None,
                    },
                ],
            },
        },
    ),
}
\end{code-block}
同样的，不带标签的矢量数据类型（Vec或者Option）的语法树结构大致如下：
\begin{code-block}{json}
Field {
    attrs: [],
    vis: Inherited,
    ident: Some(
        Ident {
            ident: "others",
            span: #0 bytes(1813..1819),
        },
    ),
    colon_token: Some(
        Colon,
    ),
    ty: Path(
        TypePath {
            qself: None,
            path: Path {
                leading_colon: None,
                segments: [
                    PathSegment {
                        ident: Ident {
                            ident: "Vec",
                            span: #0 bytes(1821..1824),
                        },
                        arguments: AngleBracketed(
                            AngleBracketedGenericArguments {
                                colon2_token: None,
                                lt_token: Lt,
                                args: [
                                    Type(
                                        Path(
                                            TypePath {
                                                qself: None,
                                                path: Path {
                                                    leading_colon: None,
                                                    segments: [
                                                        PathSegment {
                                                            ident: Ident {
                                                                ident: "String",
                                                                span: #0 bytes(1825..1831),
                                                            },
                                                            arguments: None,
                                                        },
                                                    ],
                                                },
                                            },
                                        ),
                                    ),
                                ],
                                gt_token: Gt,
                            },
                        ),
                    },
                ],
            },
        },
    ),
}
\end{code-block}
带有标签的标量数据类型，其语法树结构则可能如下：
\begin{code-block}{json}
Field {
    attrs: [
        Attribute {
            pound_token: Pound,
            style: Outer,
            bracket_token: Bracket,
            path: Path {
                leading_colon: None,
                segments: [
                    PathSegment {
                        ident: Ident {
                            ident: "builder",
                            span: #0 bytes(1688..1695),
                        },
                        arguments: None,
                    },
                ],
            },
            tokens: TokenStream [
                Group {
                    delimiter: Parenthesis,
                    stream: TokenStream [
                        Ident {
                            ident: "each",
                            span: #0 bytes(1696..1700),
                        },
                        Punct {
                            ch: '=',
                            spacing: Alone,
                            span: #0 bytes(1701..1702),
                        },
                        Literal {
                            kind: Str,
                            symbol: "arg",
                            suffix: None,
                            span: #0 bytes(1703..1708),
                        },
                    ],
                    span: #0 bytes(1695..1709),
                },
            ],
        },
    ],
    vis: Inherited,
    ident: Some(
        Ident {
            ident: "executable",
            span: #0 bytes(1715..1725),
        },
    ),
    colon_token: Some(
        Colon,
    ),
    ty: Path(
        TypePath {
            qself: None,
            path: Path {
                leading_colon: None,
                segments: [
                    PathSegment {
                        ident: Ident {
                            ident: "String",
                            span: #0 bytes(1727..1733),
                        },
                        arguments: None,
                    },
                ],
            },
        },
    ),
}
\end{code-block}
带有标签的矢量数据类型的语法树结构则是如下类似：
\begin{code-block}{json}
Field {
    attrs: [
        Attribute {
            pound_token: Pound,
            style: Outer,
            bracket_token: Bracket,
            path: Path {
                leading_colon: None,
                segments: [
                    PathSegment {
                        ident: Ident {
                            ident: "builder",
                            span: #0 bytes(1741..1748),
                        },
                        arguments: None,
                    },
                ],
            },
            tokens: TokenStream [
                Group {
                    delimiter: Parenthesis,
                    stream: TokenStream [
                        Ident {
                            ident: "each",
                            span: #0 bytes(1749..1753),
                        },
                        Punct {
                            ch: '=',
                            spacing: Alone,
                            span: #0 bytes(1754..1755),
                        },
                        Literal {
                            kind: Str,
                            symbol: "arg",
                            suffix: None,
                            span: #0 bytes(1756..1761),
                        },
                    ],
                    span: #0 bytes(1748..1762),
                },
            ],
        },
    ],
    vis: Inherited,
    ident: Some(
        Ident {
            ident: "args",
            span: #0 bytes(1768..1772),
        },
    ),
    colon_token: Some(
        Colon,
    ),
    ty: Path(
        TypePath {
            qself: None,
            path: Path {
                leading_colon: None,
                segments: [
                    PathSegment {
                        ident: Ident {
                            ident: "Vec",
                            span: #0 bytes(1774..1777),
                        },
                        arguments: AngleBracketed(
                            AngleBracketedGenericArguments {
                                colon2_token: None,
                                lt_token: Lt,
                                args: [
                                    Type(
                                        Path(
                                            TypePath {
                                                qself: None,
                                                path: Path {
                                                    leading_colon: None,
                                                    segments: [
                                                        PathSegment {
                                                            ident: Ident {
                                                                ident: "String",
                                                                span: #0 bytes(1778..1784),
                                                            },
                                                            arguments: None,
                                                        },
                                                    ],
                                                },
                                            },
                                        ),
                                    ),
                                ],
                                gt_token: Gt,
                            },
                        ),
                    },
                ],
            },
        },
    ),
}
\end{code-block}

有了以上对于结构体字段语法树结构的了解，处理结构体字段的代码可以大致如下：
\begin{code-block}{rust}
fn get_generic_fields_type_each<'a>(
    st: &'a syn::Type,
    outer_ident_name: &str,
) -> Option<&'a syn::Type> {
    if let syn::Type::Path(syn::TypePath {
        path: syn::Path { segments, .. },
        ..
    }) = st
    {
        if let Some(segment) = segments.last() {
            // 解析原始结构体的字段类型（type），针对使用Option和Vec描述的类型
            // 返回其内部的真实数据类型
            if segment.ident.to_string() == outer_ident_name {
                if let syn::PathArguments::AngleBracketed(syn::AngleBracketedGenericArguments {
                    args,
                    ..
                }) = &segment.arguments
                {
                    if let Some(syn::GenericArgument::Type(inner_type)) = args.first() {
                        return Some(inner_type);
                    }
                }
            }
        }
    }
    None
}
fn generate_builder_struct_fields_def_each(
    fields: &StructFields,
) -> syn::Result<proc_macro2::TokenStream> {
    let idents: Vec<_> = fields.iter().map(|f| &f.ident).collect();
    let types: Vec<_> = fields
        .iter()
        .map(|f| {
            // 如果原始结构体字段的数据类型本身是使用Option封装的，则提取其内部数据类型
            if let Some(inner_type) = get_generic_fields_type_each(&f.ty, "Option") {
                quote!(std::option::Option<#inner_type>)
            } else if get_attr_field_ident(f).is_some() {
                // 如果原始字段上存在标签，在本例当中的做法，是将其默认识别成vec类型
                // 因此，不再使用Option进行包裹
                let origin_type = &f.ty;
                quote!(#origin_type)
            } else {
                // 其他的继续使用Option进行包裹，即使原始字段是Vec类型
                let origin_type = &f.ty;
                quote!(std::option::Option<#origin_type>)
            }
        })
        .collect();
    Ok(quote!( #(#idents: #types), *))
}
\end{code-block}

获取到结构体的字段之后，接下来就是对这些字段进行初始化操作：
\begin{code-block}{rust}
fn generate_builder_struct_fields_init_each(
    fields: &StructFields,
) -> syn::Result<Vec<proc_macro2::TokenStream>> {
    let init_data: Vec<_> = fields
        .iter()
        .map(|f| {
            let ident = &f.ident;
            // 如果原始结构体的字段上存在标签，该字段将被识别为Vec类型
            // 直接使用Vec进行初始化
            if get_attr_field_ident(f).is_some() {
                quote!(#ident: std::vec::Vec::new())
            } else {
                // 否则，使用Option进行填充
                quote!(#ident: std::option::Option::None)
            }
        })
        .collect();
    Ok(init_data)
}
\end{code-block}

接下来，就是生成Builder结构体的setter函数：
\begin{code-block}{rust}
fn generate_setter_each(fields: &StructFields) -> syn::Result<proc_macro2::TokenStream> {
    let idents: Vec<_> = fields.iter().map(|f| &f.ident).collect();
    let types: Vec<_> = fields.iter().map(|f| &f.ty).collect();
    let mut final_token_stream = proc_macro2::TokenStream::new();
    for (idx, (ident, type_)) in idents.iter().zip(types.iter()).enumerate() {
        let mut tokenstream_piece;
        // 如果原始字段是Option类型
        if let Some(inner_type) = get_generic_fields_type_each(type_, "Option") {
            tokenstream_piece = quote! {
                pub fn #ident(&mut self, #ident: #inner_type) -> & mut Self {
                    // 使用Option的内部数据类型对字段进行初始化
                    self.#ident = std::option::Option::Some(#ident);
                    self
                }
            };
        // 如果原始字段上存在标签
        } else if let Some(ref builder_for_each) = get_attr_field_ident(&fields[idx]) {
            // 检测当前字段是否是Vec
            let inner_type = get_generic_fields_type_each(type_, "Vec").ok_or(syn::Error::new(
                fields[idx].span(),
                "each field must be specified with Vec field",
            ))?;
            tokenstream_piece = quote! {
                pub fn #builder_for_each(&mut self, #builder_for_each: #inner_type) -> & mut Self {
                    self.#ident.push(#builder_for_each);
                    self
                }
            };
            // 如果标签名称和字段名称不同，还需要生成一个字段本身的setter方法
            if builder_for_each != ident.as_ref().unwrap() {
                tokenstream_piece.extend(quote! {
                    pub fn #ident(&mut self, #ident: #type_) -> & mut Self {
                        self.#ident = #ident.clone();
                        self
                    }
                });
            }
        } else {
            tokenstream_piece = quote! {
                pub fn #ident(&mut self, #ident: #type_) -> & mut Self {
                    self.#ident = std::option::Option::Some(#ident);
                    self
                }
            };
        };
        final_token_stream.extend(tokenstream_piece);
    }
    Ok(final_token_stream)
}
\end{code-block}

最后的重点，则是生成本需求的build方法，实现Rust的建造者模式：
\begin{code-block}{rust}
fn generate_builder_function(
    fields: &StructFields,
    origin_struct_ident: &syn::Ident,
) -> syn::Result<proc_macro2::TokenStream> {
    let idents: Vec<_> = fields.iter().map(|f| &f.ident).collect();
    let types: Vec<_> = fields.iter().map(|f| &f.ty).collect();
    let mut check_pieces = Vec::new();
    for (idx, (__ident__, __type__)) in idents.iter().zip(types.iter()).enumerate() {
        // 如果字段不是Option或者不存在标签，表示该字段为必需字段，必须进行初始化
        if get_generic_fields_type_each(__type__, "Option").is_none()
            && get_attr_field_ident(&fields[idx]).is_none()
        {
            check_pieces.push(quote! {
                if self.#__ident__.is_none() {
                    let err = format!("{} field missing", stringify!(#__ident__));
                    return std::result::Result::Err(err.into())
                }
            });
        }
    }
    let mut fill_result = Vec::new();
    for (idx, (__ident__, __type__)) in idents.iter().zip(types.iter()).enumerate() {
        // 如果字段存在标签，直接将字段进行拷贝
        if get_attr_field_ident(&fields[idx]).is_some() {
            fill_result.push(quote!(#__ident__: self.#__ident__.clone()));
        // 如果原始字段是Option类型，则将builder的类型进行解包，返回真实的数据类型
        } else if get_generic_fields_type_each(__type__, "Option").is_none() {
            fill_result.push(quote!(#__ident__: self.#__ident__.clone().unwrap()));
        } else {
            fill_result.push(quote!(#__ident__: self.#__ident__.clone()));
        }
    }
    let final_token = quote! {
        pub fn build(&mut self) -> std::result::Result<#origin_struct_ident, std::boxed::Box<dyn std::error::Error>>{
            #(#check_pieces)*
            Ok(#origin_struct_ident {
                #(#fill_result),*
            })
        }
    };
    Ok(final_token)
}
\end{code-block}

有了以上的基础，我们将其有机的结合起来：
\begin{code-block}{rust}
use proc_macro::TokenStream;
use proc_macro2;
use quote::quote;
use syn::{self, parse_macro_input, spanned::Spanned};
type StructFields = syn::punctuated::Punctuated<syn::Field, syn::Token![,]>;
#[proc_macro_derive(BuilderEach, attributes(builder))]
pub fn deriveach(input: TokenStream) -> TokenStream {
    let st = parse_macro_input!(input as syn::DeriveInput);
    match do_expand_each(&st) {
        Ok(token_stream) => token_stream.into(),
        Err(error) => error.to_compile_error().into(),
    }
}
fn do_expand_each(st: &syn::DeriveInput) -> syn::Result<proc_macro2::TokenStream> {
    let struct_name_literal = st.ident.to_string();
    let builder_name_literal = format!("{}Builder", struct_name_literal);
    let builder_name_ident = syn::Ident::new(&builder_name_literal, st.span());
    let struct_name_ident = &st.ident;
    let fields = get_filed_from_derive_input_each(st)?;
    let builder_struct_fields_def = generate_builder_struct_fields_def_each(fields)?;
    let builder_struct_fields_init = generate_builder_struct_fields_init_each(fields)?;
    let setter_functions = generate_setter_each(fields)?;
    let build_function = generate_builder_function(fields, &struct_name_ident)?;
    let ret = quote!(
        pub struct #builder_name_ident {
            #builder_struct_fields_def
        }
        impl #struct_name_ident {
            pub fn builder() -> #builder_name_ident {
                #builder_name_ident {
                    #(#builder_struct_fields_init),*
                }
            }
        }
        impl #builder_name_ident {
            #setter_functions
            #build_function
        }
    );
    Ok(ret)
}
fn get_filed_from_derive_input_each(st: &syn::DeriveInput) -> syn::Result<&StructFields> {
    if let syn::Data::Struct(syn::DataStruct {
        fields: syn::Fields::Named(syn::FieldsNamed { ref named, .. }),
        ..
    }) = st.data
    {
        return Ok(named);
    }
    Err(syn::Error::new_spanned(
        st,
        "Must define on Struct, Not on Enum",
    ))
}
fn get_attr_field_ident(field: &syn::Field) -> Option<syn::Ident> {...}
fn get_generic_fields_type_each<'a>(st: &'a syn::Type, outer_ident_name: &str,
) -> Option<&'a syn::Type> {...}
fn generate_builder_struct_fields_def_each(fields: &StructFields,
) -> syn::Result<proc_macro2::TokenStream> {...}
fn generate_builder_struct_fields_init_each(fields: &StructFields,
) -> syn::Result<Vec<proc_macro2::TokenStream>> {...}
fn generate_setter_each(fields: &StructFields) -> syn::Result<proc_macro2::TokenStream> {...}
fn generate_builder_function(fields: &StructFields, origin_struct_ident: &syn::Ident,
) -> syn::Result<proc_macro2::TokenStream> {...}
\end{code-block}

最终，我们看看其使用方式以及结果：
\begin{code-block}{rust}
#[derive(Debug, BuilderEach)]
pub struct CommandEach {
    executable: String,
    #[builder(each = "arg")]
    args: Vec<String>,
    #[builder(each = "env")]
    env: Vec<String>,
    others: Vec<String>,
    current_dir: Option<String>,
}
fn main() {
    let builder = CommandEach::builder()
        .executable("lucifer".to_owned())
        .arg("lucifer".to_owned())
        .arg("titans".to_owned())
        .env("zhangjl".to_owned())
        .env("luoyan".to_owned())
        .others(vec![])
        .build()
        .unwrap();
    info!("{:#?}", builder);
    let builder = CommandEach::builder()
        .executable("lucifer".to_owned())
        .others(vec![])
        .build()
        .unwrap();
    info!("{:#?}", builder);
}
\end{code-block}

如果通过\codeinlinebg{bash}{cargo expand}将代码进行展开，得到的结果类似如下：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_label_expand.png}
  \caption{带标签的结构体展开}
  \label{fig:rust_label_expand}
\end{figure}
而上述代码的执行结果，则大致如下：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_label_result.png}
  \caption{带标签的结构体的执行结果}
  \label{fig:rust_label_result}
\end{figure}
可以看到，CommandEach和Command的结果是截然不同的。

现在结构体支持标签了，但是，新的问题又出现了：上述的过程宏要求的标签是\codeinline{rust}{#[builder(each = "...")]}
这种模式，如果标签写错了，即each写成了其他的字符，从程序安全的角度，应当给予足够
的错误信息提示，因此，之前的获取标签的函数需要进行改写：
\begin{code-block}{rust}
fn get_attr_field_ident(field: &syn::Field) -> syn::Result<Option<syn::Ident>> {
    for attr in &field.attrs {
        // 获得标签的语法树节点
        if let Ok(syn::Meta::List(ref list)) = attr.parse_meta() {
            // 二次解构
            let syn::MetaList {
                ref path,
                ref nested,
                ..
            } = list;
            if let Some(__path__) = path.segments.first() {
                if __path__.ident == "builder" {
                    if let Some(syn::NestedMeta::Meta(syn::Meta::NameValue(__dict__))) =
                        nested.first()
                    {
                        if __dict__.path.is_ident("each") {
                            if let syn::Lit::Str(ref arg_token) = __dict__.lit {
                                return Ok(Some(syn::Ident::new(
                                    arg_token.value().as_str(),
                                    attr.span(),
                                )));
                            }
                        } else {
                            // 如果builder当中的标签不是each，则返回一个错误
                            // 错误的范围则限定在标签的语法树节点
                            return Err(syn::Error::new_spanned(
                                list,
                                r#"expected `builder(each = "...")`"#,
                            ));
                        }
                    }
                }
            }
        }
    }
    Ok(None)
}
\end{code-block}

由于需要返回错误信息，因此，也需要对其他使用到该函数的地方进行修改。对于普通的
使用方式，直接在该方法的后面添加\codeinlinebg{rust}{?}即可，而如果是闭包，则需要
稍微注意一下。调用了\codeinlinebg{rust}{get_attr_field_ident}函数的代码修改如下：
\begin{code-block}{rust}
fn generate_builder_function(
    fields: &StructFields,
    origin_struct_ident: &syn::Ident,
) -> syn::Result<proc_macro2::TokenStream> {
    ...
    for (idx, (__ident__, __type__)) in idents.iter().zip(types.iter()).enumerate() {
        if get_generic_fields_type_each(__type__, "Option").is_none()
            && get_attr_field_ident(&fields[idx])?.is_none()
        ...
    }
    let mut fill_result = Vec::new();
    for (idx, (__ident__, __type__)) in idents.iter().zip(types.iter()).enumerate() {
        if get_attr_field_ident(&fields[idx])?.is_some() {
            fill_result.push(quote!(#__ident__: self.#__ident__.clone()));
        }
        ...
    }
    ...
    Ok(final_token)
}
fn generate_setter_each(fields: &StructFields) -> syn::Result<proc_macro2::TokenStream> {
    ...
    for (idx, (ident, type_)) in idents.iter().zip(types.iter()).enumerate() {
        let mut tokenstream_piece;
        if let Some(inner_type) = get_generic_fields_type_each(type_, "Option") {
            ...
        } else if let Some(ref builder_for_each) = get_attr_field_ident(&fields[idx])? {
            ...
        }
    }
}
fn generate_builder_struct_fields_init_each(
    fields: &StructFields,
) -> syn::Result<Vec<proc_macro2::TokenStream>> {
    let init_data: syn::Result<Vec<proc_macro2::TokenStream>> = fields
        .iter()
        .map(|f| {
            let ident = &f.ident;
            if get_attr_field_ident(f)?.is_some() {
                Ok(quote!(#ident: std::vec::Vec::new()))
            } else {
                Ok(quote!(#ident: std::option::Option::None))
            }
        })
        .collect();
    Ok(init_data?)
}
fn generate_builder_struct_fields_def_each(
    fields: &StructFields,
) -> syn::Result<proc_macro2::TokenStream> {
    let idents: Vec<_> = fields.iter().map(|f| &f.ident).collect();
    let types: syn::Result<Vec<_>> = fields
        .iter()
        .map(|f| {
            if let Some(inner_type) = get_generic_fields_type_each(&f.ty, "Option") {
                Ok(quote!(std::option::Option<#inner_type>))
            } else if get_attr_field_ident(f)?.is_some() {
                let origin_type = &f.ty;
                Ok(quote!(#origin_type))
            } else {
                let origin_type = &f.ty;
                Ok(quote!(std::option::Option<#origin_type>))
            }
        })
        .collect();
    let __types__ = types?;
    Ok(quote!( #(#idents: #__types__), *))
}
\end{code-block}
其余代码保持不变，这样，如果在使用该过程宏时写错了标签，即类似如下：
\begin{code-block}{rust}
#[derive(BuilderEach)]
pub struct CommandEach {
    executable: String,
    #[builder(each = "arg")]
    args: Vec<String>,
    #[builder(eac = "env")]
    env: Vec<String>,
    ...
}
\end{code-block}
则代码在编译的时候，就会出现如下比较明确的错误信息，当然了，正确的标签则不会提示错误：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_label_error.png}
  \caption{处理有错误的标签}
  \label{fig:rust_label_error}
\end{figure}
\input{rust_part_6}
