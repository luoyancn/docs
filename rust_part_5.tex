\subsection{过程宏案例-派生过程宏Builder深入}
通常情况下，Rust的结构体并不是要求所有的字段都必须有值，或者必须初始化，存在可选的
字段，因此，可以继续对Builder过程宏进行改造。比如将上例当中的
\mintinline[breaklines=true,breakanywhere,breaksymbolleft=,breakanywheresymbolpre=,bgcolor=lbcolor]{rust}{Command}结构体
定义修改为如下：
\begin{code-block}{rust}
pub struct Command {
    executable: String,
    args: Vec<String>,
    env: Vec<String>,
    current_dir: Option<String>,
}
\end{code-block}
即\mintinline[breaklines=true,breakanywhere,breaksymbolleft=,breakanywheresymbolpre=,bgcolor=lbcolor]{rust}{current_dir}
为可选字段，而Builder生成的结构体\mintinline[breaklines=true,breakanywhere,breaksymbolleft=,breakanywheresymbolpre=,bgcolor=lbcolor]{rust}{CommandBuilder}
则如下：
\begin{code-block}{rust}
pub struct CommandBuilder {
    executable: Option<String>,
    args: Option<Vec<String>>,
    env: Option<Vec<String>>,
    current_dir: Option<String>,
}
\end{code-block}

而这样的结构体，如果将其展开为语法树，原始结构体的\mintinline[breaklines=true,breakanywhere,breaksymbolleft=,breakanywheresymbolpre=,bgcolor=lbcolor]{rust}{current_dir}
字段形式大致如下：
\begin{code-block}{json}
Path(
    TypePath {
        qself: None,
        path: Path {
            leading_colon: None,
            segments: [
                PathSegment {
                    ident: Ident {
                        ident: "Option",
                        span: #0 bytes(1337..1343),
                    },
                    arguments: AngleBracketed(
                        AngleBracketedGenericArguments {
                            colon2_token: None,
                            lt_token: Lt,
                            args: [
                                Type(
                                    Path(
                                        TypePath {
                                            qself: None,
                                            path: Path {
                                                leading_colon: None,
                                                segments: [
                                                    PathSegment {
                                                        ident: Ident {
                                                            ident: "String",
                                                            span: #0 bytes(1344..1350),
                                                        },
                                                        arguments: None,
                                                    },
                                                ],
                                            },
                                        },
                                    ),
                                ),
                            ],
                            gt_token: Gt,
                        },
                    ),
                },
            ],
        },
    },
)
\end{code-block}
相比之下，普通的字段类型，其语法树结构可能如下：
\begin{code-block}{rust}
Path(
    TypePath {
        qself: None,
        path: Path {
            leading_colon: None,
            segments: [
                PathSegment {
                    ident: Ident {
                        ident: "String",
                        span: #0 bytes(1267..1273),
                    },
                    arguments: None,
                },
            ],
        },
    },
)
\end{code-block}
可以看到，2者的区别比较大。如果还是沿用上一个示例的方式进行Builder的构建，会出现
这样一个问题：Builder宏所生成的结构体会被处理成如下的形式：
\begin{code-block}{rust}
pub struct CommandBuilder {
    executable: std::option::Option<String>,
    args: std::option::Option<Vec<String>>,
    env: std::option::Option<Vec<String>>,
    current_dir: std::option::Option<Option<String>>,   // 被多层Option封装
}
\end{code-block}
上面的形式显然无法满足我们的需求。因此，为达到上述目的，需要对字段的类型进行进
一步的处理。对于过程宏而言（syn包），字段的类型是一个结构体，其定义大致如下\footnote{类型的定义：\url{https://docs.rs/syn/1.0.72/syn/enum.Type.html}}：
\begin{code-block}{rust}
pub enum Type {
    Array(TypeArray),
    BareFn(TypeBareFn),
    Group(TypeGroup),
    ImplTrait(TypeImplTrait),
    Infer(TypeInfer),
    Macro(TypeMacro),
    Never(TypeNever),
    Paren(TypeParen),
    Path(TypePath),
    Ptr(TypePtr),
    Reference(TypeReference),
    Slice(TypeSlice),
    TraitObject(TypeTraitObject),
    Tuple(TypeTuple),
    Verbatim(TokenStream),
    // some variants omitted
}
\end{code-block}

需要做的，就是对字段类型的语法树进行解构，一步一步的按照需求，准确的定位Option所标识的
字段，并将其的内层类型取出来。因此，需要对上一章节\nameref{builder}的代码进行重构。

首先需要实现的，就是对可选字段（Option）的语法树定位和处理，并且返回对应的TokenStream：
\begin{code-block}{rust}
fn get_option_fields(st: &syn::Type) -> Option<&syn::Type> {
    // 对type语法树进行解构
    if let syn::Type::Path(syn::TypePath {
        path: syn::Path { segments, .. },
        ..
    }) = st
    {
        if let Some(segment) = segments.last() {
            // 找到Option字段
            if segment.ident.to_string() == "Option" {
                {
                    if let syn::PathArguments::AngleBracketed(
                        syn::AngleBracketedGenericArguments { ref args, .. },
                    ) = segment.arguments
                    {
                        // 获得真实的数据类型
                        if let Some(syn::GenericArgument::Type(inner_type)) = args.first() {
                            return Some(inner_type);
                        }
                    }
                }
            }
        }
    }
    None
}
\end{code-block}
然后，根据需求，将原有的代码进行改写，比如，Builder的结构体字段定义函数，需要修改
\begin{code-block}{rust}
fn generate_builder_struct_fields_def(
    st: &syn::DeriveInput,
) -> syn::Result<proc_macro2::TokenStream> {
    ...
    let types: Vec<_> = fields
        .iter()
        .map(|f| {
            if let Some(ty) = get_option_fields(&f.ty) {
                ty
            } else {
                &f.ty
            }
        })
        .collect();
    ...
}
\end{code-block}
Builder的setter方法需要修改：
\begin{code-block}{rust}
fn generate_setter(st: &syn::DeriveInput) -> syn::Result<proc_macro2::TokenStream> {
    ...
    for (ident, type_) in idents.iter().zip(types.iter()) {
        let token_stream_slice = if let Some(inner_type) = get_option_fields(type_) {
            quote! {
                pub fn #ident(&mut self, #ident: #inner_type) -> & mut Self {
                    self.#ident = std::option::Option::Some(#ident);
                    self
                }
            }
        } else {
            quote! {
                pub fn #ident(&mut self, #ident: #type_) -> & mut Self {
                    self.#ident = std::option::Option::Some(#ident);
                    self
                }
            }
        };
        final_token_stream.extend(token_stream_slice);
    }
    ...
}
\end{code-block}
同样的，Builder的字段检查和初始化方法也需要修改：
\begin{code-block}{rust}
fn check_fileds(st: &syn::DeriveInput) -> syn::Result<proc_macro2::TokenStream> {
    let fields = get_filed_from_derive_input(st)?;
    let idents: Vec<_> = fields.iter().map(|f| &f.ident).collect();
    let types: Vec<_> = fields.iter().map(|f| &f.ty).collect();
    let mut final_check_stream = proc_macro2::TokenStream::new();

    for (ident, type_) in idents.iter().zip(types.iter()) {
        if get_option_fields(type_).is_some() {
            continue;
        }
        let check_stream_slice = quote! {
            if self.#ident.is_none() {
                let err_msg = format!("{} field is missing", stringify!(#ident));
                return std::result::Result::Err(err_msg.into());
            }
        };
        final_check_stream.extend(check_stream_slice);
    }
    Ok(final_check_stream)
}

fn build_target_fields(st: &syn::DeriveInput) -> syn::Result<proc_macro2::TokenStream> {
    let fields = get_filed_from_derive_input(st)?;
    let idents: Vec<_> = fields.iter().map(|f| &f.ident).collect();
    let types: Vec<_> = fields.iter().map(|f| &f.ty).collect();
    let mut final_init_stream = proc_macro2::TokenStream::new();
    for (ident, types_) in idents.iter().zip(types.iter()) {
        let init_stream_slice = if get_option_fields(types_).is_none() {
            quote! {
                #ident: self.#ident.clone().unwrap(),
            }
        } else {
            quote! {
                #ident: self.#ident.clone(),
            }
        };
        final_init_stream.extend(init_stream_slice);
    }
    Ok(final_init_stream)
}
\end{code-block}

改造之后的完整代码如下：
\begin{code-block}{rust}
use proc_macro::TokenStream;
use proc_macro2;
use quote::quote;
use syn::{self, parse_macro_input, spanned::Spanned};

#[proc_macro_derive(Builder)]
pub fn derive(input: TokenStream) -> TokenStream {
    let st = parse_macro_input!(input as syn::DeriveInput);
    match do_expand(&st) {
        Ok(token_stream) => token_stream.into(),
        Err(error) => error.to_compile_error().into(),
    }
}

fn do_expand(st: &syn::DeriveInput) -> syn::Result<proc_macro2::TokenStream> {
    let struct_name_literal = st.ident.to_string();
    let builder_name_literal = format!("{}Builder", struct_name_literal);
    let builder_name_ident = syn::Ident::new(&builder_name_literal, st.span());
    let struct_name_ident = &st.ident;

    let builder_struct_fields_def = generate_builder_struct_fields_def(st)?;
    let builder_struct_fields_init = generate_builder_struct_fields_init(st)?;

    let setter_functions = generate_setter(st)?;
    let checked_res = check_fileds(st)?;
    let build_res = build_target_fields(st)?;

    let ret = quote!(
        pub struct #builder_name_ident {
            #builder_struct_fields_def
        }

        impl #struct_name_ident {
            pub fn builder() -> #builder_name_ident {
                #builder_name_ident {
                    #(#builder_struct_fields_init),*
                }
            }
        }

        impl #builder_name_ident {
            #setter_functions
            pub fn build(&mut self) -> std::result::Result<#struct_name_ident, std::boxed::Box<dyn std::error::Error>>{
                #checked_res
                Ok(#struct_name_ident {
                    #build_res
                })
            }
        }

    );
    Ok(ret)
}

fn check_fileds(st: &syn::DeriveInput) -> syn::Result<proc_macro2::TokenStream> {
    let fields = get_filed_from_derive_input(st)?;
    let idents: Vec<_> = fields.iter().map(|f| &f.ident).collect();
    let types: Vec<_> = fields.iter().map(|f| &f.ty).collect();
    let mut final_check_stream = proc_macro2::TokenStream::new();

    for (ident, type_) in idents.iter().zip(types.iter()) {
        if get_option_fields(type_).is_some() {
            continue;
        }
        let check_stream_slice = quote! {
            if self.#ident.is_none() {
                let err_msg = format!("{} field is missing", stringify!(#ident));
                return std::result::Result::Err(err_msg.into());
            }
        };
        final_check_stream.extend(check_stream_slice);
    }
    Ok(final_check_stream)
}

fn build_target_fields(st: &syn::DeriveInput) -> syn::Result<proc_macro2::TokenStream> {
    let fields = get_filed_from_derive_input(st)?;
    let idents: Vec<_> = fields.iter().map(|f| &f.ident).collect();
    let types: Vec<_> = fields.iter().map(|f| &f.ty).collect();
    let mut final_init_stream = proc_macro2::TokenStream::new();
    for (ident, types_) in idents.iter().zip(types.iter()) {
        let init_stream_slice = if get_option_fields(types_).is_none() {
            quote! {
                #ident: self.#ident.clone().unwrap(),
            }
        } else {
            quote! {
                #ident: self.#ident.clone(),
            }
        };
        final_init_stream.extend(init_stream_slice);
    }
    Ok(final_init_stream)
}

fn generate_setter(st: &syn::DeriveInput) -> syn::Result<proc_macro2::TokenStream> {
    let fields = get_filed_from_derive_input(st)?;
    let idents: Vec<_> = fields.iter().map(|f| &f.ident).collect();
    let types: Vec<_> = fields.iter().map(|f| &f.ty).collect();

    let mut final_token_stream = proc_macro2::TokenStream::new();
    for (ident, type_) in idents.iter().zip(types.iter()) {
        let token_stream_slice = if let Some(inner_type) = get_option_fields(type_) {
            quote! {
                pub fn #ident(&mut self, #ident: #inner_type) -> & mut Self {
                    self.#ident = std::option::Option::Some(#ident);
                    self
                }
            }
        } else {
            quote! {
                pub fn #ident(&mut self, #ident: #type_) -> & mut Self {
                    self.#ident = std::option::Option::Some(#ident);
                    self
                }
            }
        };
        final_token_stream.extend(token_stream_slice);
    }
    Ok(final_token_stream)
}

type StructFields = syn::punctuated::Punctuated<syn::Field, syn::Token![,]>;

fn get_filed_from_derive_input(st: &syn::DeriveInput) -> syn::Result<&StructFields> {
    if let syn::Data::Struct(syn::DataStruct {
        fields: syn::Fields::Named(syn::FieldsNamed { ref named, .. }),
        ..
    }) = st.data
    {
        return Ok(named);
    }
    Err(syn::Error::new_spanned(
        st,
        "Must define on Struct, Not on Enum",
    ))
}

fn generate_builder_struct_fields_def(
    st: &syn::DeriveInput,
) -> syn::Result<proc_macro2::TokenStream> {
    let fields = get_filed_from_derive_input(st)?;
    let idents: Vec<_> = fields.iter().map(|f| &f.ident).collect();
    let types: Vec<_> = fields
        .iter()
        .map(|f| {
            if let Some(ty) = get_option_fields(&f.ty) {
                ty
            } else {
                &f.ty
            }
        })
        .collect();

    let ret = quote! {
        #(#idents: std::option::Option<#types>), *
    };

    Ok(ret)
}

fn get_option_fields(st: &syn::Type) -> Option<&syn::Type> {
    if let syn::Type::Path(syn::TypePath {
        path: syn::Path { segments, .. },
        ..
    }) = st
    {
        if let Some(segment) = segments.last() {
            if segment.ident.to_string() == "Option" {
                {
                    if let syn::PathArguments::AngleBracketed(
                        syn::AngleBracketedGenericArguments { ref args, .. },
                    ) = segment.arguments
                    {
                        if let Some(syn::GenericArgument::Type(inner_type)) = args.first() {
                            return Some(inner_type);
                        }
                    }
                }
            }
        }
    }
    None
}

fn generate_builder_struct_fields_init(
    st: &syn::DeriveInput,
) -> syn::Result<Vec<proc_macro2::TokenStream>> {
    let fields = get_filed_from_derive_input(st)?;
    let init_data: Vec<_> = fields
        .iter()
        .map(|f| {
            let ident = &f.ident;
            quote! {
                #ident: std::option::Option::None
            }
        })
        .collect();
    Ok(init_data)
}
\end{code-block}

完成上述操作之后，在主函数当中，就可以以多种方式进行builder的初始化：
\begin{code-block}{rust}
fn main(){
    let builder = Command::builder()
        .executable("lucifer".to_owned())
        .args(vec![])
        .env(vec![])
        .current_dir("target".to_owned())
        .build()
        .unwrap();
    info!("{:#?}", builder);

    let builder = Command::builder()
        .executable("lucifer".to_owned())
        .args(vec![])
        .env(vec!["titans".to_owned(), "garuda".to_owned()])
        .build()
        .unwrap();
    info!("{:#?}", builder);
}

#[derive(Debug, Builder)]
pub struct Command {
    executable: String,
    args: Vec<String>,
    env: Vec<String>,
    current_dir: Option<String>,
}
\end{code-block}

\subsection{过程宏案例-派生过程宏Builder的派生属性}
如果继续进行深入，考虑下面的一种形式：
\begin{code-block}{rust}
#[derive(Builder)]
pub struct Command {
    executable: String,
    #[builder(each = "arg")]
    args: Vec<String>,
    #[builder(each = "env")]
    env: Vec<String>,
    current_dir: Option<String>,
}

fn main() {
    ...
    let builder = Command::builder()
        .executable("lucifer".to_owned())
        .arg("first")
        .arg("second")
        .env(vec!["titans".to_owned(), "garuda".to_owned()])
        .build()
        .unwrap();
}
\end{code-block}
即，使用\mintinline[breaklines=true,breakanywhere,breaksymbolleft=,breakanywheresymbolpre=,bgcolor=lbcolor]{rust}{#[builder(each = "arg")]}
这样的代码对结构体的字段进行标记，标记之后，原本对结构体进行初始化，使用的是一个vec结构（args），
后续可以使用单个元素（arg）进行追加的方式进行初始化。通常来说，实现这种宏，都应该要求builder当中的标签
和真实的属性名之间最好有区别。如果要求标签和属性名相同，则需要进行额外的其他特殊处理，即需要避免生成一个一次性通过列表进行赋值的方法。
以上述代码为例，如果使用builder宏装饰env字段，并且标签也是env，那么，针对env字段，最好的方式就是不要实现一个
使用列表直接复制的函数，即\mintinline[breaklines=true,breakanywhere,breaksymbolleft=,breakanywheresymbolpre=,bgcolor=lbcolor]{rust}{builder.env("something")}与
\mintinline[breaklines=true,breakanywhere,breaksymbolleft=,breakanywheresymbolpre=,bgcolor=lbcolor]{rust}{builder.env(vec!["nothing", "ok"])}这2种形式
无法并存，只能存在一个。另外的重点是，这个builder宏，只能在被使用了
\mintinline[breaklines=true,breakanywhere,breaksymbolleft=,breakanywheresymbolpre=,bgcolor=lbcolor]{rust}{#[derive(Builder)]}
修饰之后的结构体当中使用，而不能单独使用，因此，类似builder的宏被称之为惰性属性
宏，其完整的定义形式，一般是\mintinline[breaklines=true,breakanywhere,breaksymbolleft=,breakanywheresymbolpre=,]{rust}{#[proc_macro_derive(Builder, attributes(builder))]}
这种。

惰性属性宏与常见的属性过程宏基本上是一样的，因此，在处理惰性属性宏之前，先看看
常见的属性是什么样式的。简单的查看结构体的属性语法树结构，可以如下进行操作：
\begin{code-block}{rust}
#[proc_macro_derive(Test)]
fn do_expand_each(st: &syn::DeriveInput) -> syn::Result<proc_macro2::TokenStream> {
    let struct_name_literal = st.ident.to_string();
    let attr = st.attrs.first().unwrap();
    eprintln!("{:#?}", attr);
    proc_macro2::TokenStream::new().into()
}

...
#[derive(Test)]
#[blog::com(Bar)]
pub struct CommandEach {
    executable: String,
    #[builder(each = "arg")]
    args: Vec<String>,
    #[builder(each = "env")]
    ...
}
fn main() {
    ...
}
\end{code-block}
通过eprint函数，可以得到关于属性Attribute的详细信息：
\begin{code-block}{json}
Attribute {
    pound_token: Pound,
    style: Outer,
    bracket_token: Bracket,
    path: Path {
        leading_colon: None,
        segments: [
            PathSegment {
                ident: Ident {
                    ident: "blog",
                    span: #0 bytes(1402..1406),
                },
                arguments: None,
            },
            Colon2,
            PathSegment {
                ident: Ident {
                    ident: "com",
                    span: #0 bytes(1408..1411),
                },
                arguments: None,
            },
        ],
    },
    tokens: TokenStream [
        Group {
            delimiter: Parenthesis,
            stream: TokenStream [
                Ident {
                    ident: "Bar",
                    span: #0 bytes(1412..1415),
                },
            ],
            span: #0 bytes(1411..1416),
        },
    ],
}
\end{code-block}

在Rust的语法树当中，如果对一个结构体的字段进行展开，其基本
的语法树结构可能如下：
\begin{code-block}{json}
Field {
    attrs: [],
    vis: Inherited,
    ident: Some(
        Ident {
            ident: "executable",
            span: #0 bytes(1429..1439),
        },
    ),
    colon_token: Some(
        Colon,
    ),
    ty: Path(
        TypePath {
            qself: None,
            path: Path {
                leading_colon: None,
                segments: [
                    PathSegment {
                        ident: Ident {
                            ident: "String",
                            span: #0 bytes(1441..1447),
                        },
                        arguments: None,
                    },
                ],
            },
        },
    ),
}
\end{code-block}
即，每个结构体字段都带有attrs（属性）标记。上述语法树为不带属性标记的字段，而
如果是类似本节开头的部分，在env和args上设置了属性标记，该字段的语法树会变为如下的
模式：
\begin{code-block}{json}
Field {
    attrs: [
        Attribute {
            pound_token: Pound,
            style: Outer,
            bracket_token: Bracket,
            path: Path {
                leading_colon: None,
                segments: [
                    PathSegment {
                        ident: Ident {
                            ident: "builder",
                            span: #0 bytes(1455..1462),
                        },
                        arguments: None,
                    },
                ],
            },
            tokens: TokenStream [
                Group {
                    delimiter: Parenthesis,
                    stream: TokenStream [
                        Ident {
                            ident: "each",
                            span: #0 bytes(1463..1467),
                        },
                        Punct {
                            ch: '=',
                            spacing: Alone,
                            span: #0 bytes(1468..1469),
                        },
                        Literal {
                            kind: Str,
                            symbol: "arg",
                            suffix: None,
                            span: #0 bytes(1470..1475),
                        },
                    ],
                    span: #0 bytes(1462..1476),
                },
            ],
        },
    ],
    ...
},
\end{code-block}
需要注意的是，上述语法树内容，全部表示的是结构体字段的属性标记，并非结构体字段
本身的语法树结构，可以看到，其结构和Rust的Attribute是相同的。

\input{rust_part_6}
