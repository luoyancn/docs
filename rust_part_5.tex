\subsection{排序}
Rust的整数型数组和向量（Vector）的排序是相同的，可以使用相同的方式进行，即采用
sort以及sort\_unstable进行。其中，sort是稳定排序（即不重新排序相等的元素），
sort\_unstable是不稳定排序，\colorunderline{但是通常情况下速度更快}，并且不会进行辅助内存的分配。
\begin{code-block}{rust}
let mut v = vec![2, 21, 12, 32, 12, 45, 90];
v.sort_unstable();
info!("The sorted vector is {:?}", v);
let mut array = [2, 23, 12, 12, 98, 100, 21];
array.sort_unstable();
info!("The sorted array is {:?}", array);
\end{code-block}
默认情况下，排序操作使用的是升序，但是可以通过定制，修改排序方式：
\begin{code-block}{rust}
let mut v = vec![2, 21, 12, 32, 12, 45, 90];
// 降序排列，可替换成v.sort_by
v.sort_unstable_by(|a, b| b.cmp(a));
info!("The sorted vector is {:?}", v);
let mut array = [2i32, -23, 12, 12, 98, -100, 21];
// 根据绝对值升序排列，可以根据其他关键字进行排序
array.sort_unstable_by_key(|k| k.abs());
info!("The sorted array is {:?}", array);
// 根据字符顺序排列，带有缓存cache，闭包函数通常只执行一次，比无缓存的快速
let mut xx = [-5i32, 4, 32, -3, 2];
xx.sort_by_cached_key(|k| k.to_string());
// 字符串排序
let mut array = ["lucifer", "titans", "asura", "garuda"];
array.sort_unstable_by_key(|item| item.to_string());
info!("The string array is {:?}", array);
let mut array = [
    "lucifer".to_string(),
    "titans".to_string(),
    "asura".to_string(),
    "garuda".to_string(),
];
// 可以转换成切片
// array[..].sort_unstable_by_key(|item| item.to_string());                                                                                                                               info!("The string array is {:?}", array);
array.sort_unstable_by_key(|item| item.to_string());                                                                                                                               info!("The string array is {:?}", array);
\end{code-block}

浮点数的排序和最值操作，参见\colorunderlineref{float_sort}

除了基础数据类型可以进行排序，同样可以针对复合数据类型进行排序。在针对复合数据
类型排序时，需要实现\colorunderline{Eq，PartialEq，Ord和PartialOrd}这几个trait：
\begin{code-block}{rust}
#[derive(Eq, PartialEq, Ord, PartialOrd, Debug)]
struct Student {
    name: String,
    age: u8,
}
fn main() {
    let mut stu = [
        Student {
            name: "lucifer".to_string(),
            age: 18,
        },
        Student {
            name: "garuda".to_string(),
            age: 36,
        },
    ];
    // 按照自然序列（name）
    stu.sort();
    info!("The students is {:?}", stu);
    // 根据年龄
    stu.sort_unstable_by(|first, second| first.age.cmp(&second.age));
    info!("The students is {:?}", stu);
}
\end{code-block}

\subsection{压缩与解压}
Rust可以实现文件的压缩与解压，在Linux环境下，通常使用\href{https://github.com/alexcrichton/tar-rs}{tar}（归档）
和\href{https://github.com/rust-lang/flate2-rs}{flate2}（压缩解压），比如Linux下常见的tar.gz文件的处理：
\begin{code-block}{rust}
use flate2::read::GzDecoder;
use flate2::write::GzEncoder;
use flate2::Compression;
use tar::Archive;

let path = "/root/py3.tar.gz";
let targz = match File::open(path) {
    Ok(file) => file,
    Err(error) => {
        crit!("Failed to open the file {}: {}", path, error.to_string());
    }
};
// gz文件的解码器
let tar = GzDecoder::new(targz);
// tar的管理器
let mut archive = Archive::new(tar);
// 将tar.gz解压
match archive.unpack(".") {
    Ok(_) => info!("Sucess to unpack the tar.gz file"),
    Err(error) => {
        crit!("Failed to unpark the tar.gz file: {:?}", error);
    }
}
// 创建tar.gz文件
let targz = match File::create("log.tar.gz") {
    Ok(file) => file,
    Err(error) => {
        crit!(
            "Failed to create the log.tar.gz file : {}",
            error.to_string()
        );
    }
};
// 创建gz文件的编码器，压缩算法使用默认
let encoder = GzEncoder::new(targz, Compression::default());
let mut tarfile = tar::Builder::new(encoder);
// 将文件添加到tar.gz文件当中
match tarfile.append_dir_all("log", "/var/log") {
    Ok(_) => info!("log.tar.gz created sucessful"),
    Err(error) => {
        fs::remove_file("log.tar.gz").unwrap_or_else(|why| {
            error!("Cannot remove the log.tar.gz: {:?}", why.to_string())
        });
        crit!("Failed to park the tar.gz file: {:?}", error);
    }
}
\end{code-block}

当然，归档和压缩也可以单独使用：
\begin{code-block}{rust}
use flate2::read::GzDecoder;
use flate2::write::GzEncoder;
use flate2::Compression;
use tar::Archive;
let tarf = match File::create("log.tar") {
    Ok(file) => file,
    Err(error) => {
        crit!("Failed to create the log.tar file : {}", error.to_string());
    }
};
// 注意和gz文件不一样，只是归档，则不需要创建编码器
let mut tar_file = tar::Builder::new(tarf);
match tar_file.append_dir_all("log", "/var/log") {
    Ok(_) => info!("log.tar created sucessful"),
    Err(error) => {
        fs::remove_file("log.tar")
            .unwrap_or_else(|why| error!("Cannot remove the log.tar: {:?}", why.to_string()));
        crit!("Failed to park the tar.gz file: {:?}", error);
    }
}
let path = "/root/log.tar";
let tarball = match File::open(path) {
    Ok(file) => file,
    Err(error) => {
        crit!("Failed to open the file {}: {}", path, error.to_string());
    }
};
// 同样的，解压tar文件，不需要创建解码器
let mut archive = Archive::new(tarball);
match archive.unpack(".") {
    Ok(_) => info!("Sucess to unpack the tar file"),
    Err(error) => {
        crit!("Failed to unpark the tar file: {:?}", error);
    }
}
\end{code-block}

\section{元编程}
Rust也包含了宏，并且，和C/C++相比，Rust的宏会展开成为抽象语法树（AST，abstract syntax tree），
而不是普通的转换成字符串，因此，不会产生无法预料的优先权错误。Rust的宏包括声明宏以及过程宏。
\subsection{声明宏}
常见的Rust宏大部分都是声明宏，最普通的宏如下：
\begin{code-block}{rust}
extern crate slog_scope;
extern crate slog_stdlog;
#[macro_use]
extern crate log;
extern crate logger;

// macro_rules! 表示后续的内容是一个宏
// greeting表示宏的名称
macro_rules! greeting {
    // () 表示该宏不接收任何参数
    () => {
        // 宏定义展开的具体内容
        info!("hello macro");
    };
}

fn main() {
    let logger = logger::initlogger(false, "", 0);
    let _guard = slog_scope::set_global_logger(logger);
    slog_stdlog::init().unwrap();

    greeting!();
}
\end{code-block}
但是，宏不可能一直是无参数的，它还包含了多种使用方式。宏的参数使用\$符号表示，并
使用指示符来注明类型，如下：
\begin{code-block}{rust}
macro_rules! create_function {
    // 宏接收一个ident指示符表示的参数，并创建一个func_name的函数
    // ident指示符表示变量名（函数名）
    ($func_name: ident) => {
        fn $func_name() {
            // stringify宏负责将ident指示符表示的参数转换成字符串
            info!("You called the {}()", stringify!($func_name));
        }
    };
}

// 使用宏创建函数，函数名为func
create_function!(func);

macro_rules! formatres {
    // 宏接收一个expr指示符表示的表达式（可以是代码块，函数/方法，其他宏）
    // expr指示符表示表达式
    // $expression表示表达式最后的执行结果
    ($expression: expr) => {
        info!("{} = {}", stringify!($expression), $expression)
    };
}

fn main() {
    // 调用func函数
    func();
    formatres!(1 + 32);
    formatres!("lucifer");
    formatres!(format!("{}, age is {}", "zhangjl", 32));
}
\end{code-block}
宏的指示符有很多，各自用于不同的场景，所有的宏指示符如下：
\begin{itemize}
  \item block：代码块，由{}限定的代码
  \item expr：表达式，会生成具体的值
  \item ident：变量名/函数名，标识符
  \item item：语言项，即组成一个Rust包的基本单位，如模块，声明，函数/类型/结构体/impl定义
  \item pat：模式
  \item path：路径，类似std::iter等
  \item stmt：语句，一般以;结尾的代码
  \item tt：标记树
  \item ty：类型
  \item meta：元数据信息，即包含在\#[...]以及\#![...]当中的信息
  \item vis：可见性，如pub
  \item lifetime：指代生命周期参数
\end{itemize}

类似于方法，Rust的宏也可以进行重载，只不过，这个重载的实现比较类似于match的分支
处理流程，分割宏的分支即进行重载，则需要使用符号“:”进行：
\begin{code-block}{rust}
macro_rules! assert_bool {
    // 括号中的分号;表示调用该宏时，需要传递2条语句或者表达式
    ($left: expr; and $right: expr) => {
        info!(
            "{} and {} is {}",
            stringify!($left),
            stringify!($right),
            $left && $right
        )
    };
    // 分支之间需要使用分号;进行分割与结束
    ($left: expr; or $right: expr) => {
        info!(
            "{} or {} is {}",
            stringify!($left),
            stringify!($right),
            $left || $right
        )
    };
}

fn main() {
    assert_bool!(1 + 1 == 2; and 2 * 2 == 4 );
    assert_bool!(1 + 1 == 3; or 2 * 2 == 6 );
}
\end{code-block}

宏定义的另外一个好处就是可以处理不定参数，在处理不定参数时，需要使用+操作符以及*
操作符，+表示参数可能出现一次或多次，*则表示参数可能出现0次或多次：
\begin{code-block}{rust}
use std::cmp;
macro_rules! find_min {
    // 如果传入的只有一个参数，直接返回当前参数值
    ($x: expr) => {
        $x
    };
    // 传入多个参数，表示后续更多的参数，即x后至少还有一个参数
    ($x: expr, $($y: expr), +) => {
        // 递归调用宏本身
        cmp::min($x, find_min!($($y), +))
    };
}

fn main() {
    info!("{}", find_min!(12));
    info!("{}", find_min!(12, 65, 40 - 32));

    let a = 1;
    let b = 2;
    let c = 3;
    info!("{}", find_min!(a, a - b, c));
}
\end{code-block}
上述的宏是使用表达式模式进行的，如果采用变量模式，即使用ident模式，则上述代码需要
变更为如下：
\begin{code-block}{rust}
use std::cmp;

macro_rules! find_min {
    ($x: ident) => {
        $x
    };
    ($x: ident, $($y: ident), +) => {
        cmp::min($x, find_min!($($y), +))
    };
}

fn main() {
    // 错误的使用方式，12是一个表达式，而并非变量名
    // info!("{}", find_min!(12));
    let a = 1;
    let b = 2;
    let c = 3;
    info!("{}", find_min!(a, b, c));
}
\end{code-block}
通过对比，可以发现，在某些场景下，表达式方式比ident方式更加通用，也更加合理一些。

比较奇特的是，在Rust的宏当中，可以使用自定义的关键字，实现特殊功能，比如自定义
关键字evaluation，表示将表达式进行计算：
\begin{code-block}{rust}
macro_rules! calc {
    // 自定义关键字evalution，使用该宏时，前面必须加上evalution前缀关键词
    (evalution $e: expr) => {
        // 强制将表达式e变成数值i32类型，即将表达式e进行计算
        let val: i32 = $e;
        info!("{} = {}", stringify!($e), val);
    };
    // 当传入参数不定时
    (evalution $e: expr, $(evalution $es: expr),+) => {
        calc!(evalution $e);
        calc!($(evalution $es),+)
    }
}

fn main() {
    calc!(evalution 1 + 100);
    calc!(evalution 1+2, evalution 3 + 4, evalution 5 +6 );
    calc!(evalution 1-2, evalution 3 * 4, evalution (5 +6) * (5 - 9) );
}
\end{code-block}
由于宏的高度可定制性，因此，上述的宏代码可以变更为如下的模式，但是2者的功能完全
一样：
\begin{code-block}{rust}
macro_rules! calc {
    (evalution $e:expr) => {{
        let val: i32 = $e;
        info!("{} = {}", stringify! {$e}, val);
    }};
    (evalution $e:expr, $(evalution $es:expr),+) => {{
        calc! { evalution $e }
        calc! { $(evalution $es),+ }
    }};
}

fn main() {
    // 下面两种方式都正确
    calc!{evalution 1 + 100};
    calc!(evalution 1+2, evalution 3 + 4, evalution 5 +6 );
}
\end{code-block}

实际上，*和+不仅可以用于参数处理，也可以用于语法扩展的部分，比如，我们想实现类似
如下的一个宏：
\begin{code-block}{rust}
let empty = hashmap![];
let counts = hashmap!['A' => 0, 'C' => 0, 'G' => 0, 'T' => 0];
\end{code-block}
则宏定义大致可能如下：
\begin{code-block}{rust}
macro_rules! hashmap {
    ($key: expr => $val: expr) => {{
        let mut map = ::std::collections::HashMap::new();
        map.insert($key, $val);
        map
    }};
}
\end{code-block}
但是，到目前为止，上述的宏只能实现对一对数据的操作，无法实现任意对数据的插入操作，
因此，我们需要使用+或者*符号进行扩展，由于我们需要支持初始化一个空的hashmap，因此
选择使用*进行扩展：
\begin{code-block}{rust}
macro_rules! hashmap {
    ($key: expr => $val: expr) => {{
        let mut map = ::std::collections::HashMap::new();
        map.insert($key, $val);
        map
    }};
}
\end{code-block}
虽然参数支持了任意个数，但是，在宏体当中，map的插入操作只执行了一次，我们可以继续
使用*和+对语法部分进行扩展，扩展之后，完整的宏定义如下：
\begin{code-block}{rust}
macro_rules! hashmap {
    ($($key: expr => $val: expr), *) => {{
        let mut map = HashMap::new();
        $(map.insert($key, $val); )*
        map
    }};
}
\end{code-block}
使用时，则按照上述的使用方式即可：
\begin{code-block}{rust}
let map = hashmap!["lucifer" => 12, "titans" => 18];
let mut empty: HashMap<String, u8> = hashmap![];
\end{code-block}
默认情况下，cargo并没有提供将宏定义进行展开显示的功能，但是，我们可以通过rustc
将代码展开，确认宏定义确实是按照我们的想法进行工作的。只是需要注意，将宏定义进行
展开显示，需要使用nightly分支，因此，我们的操作基本如下：
\begin{code-block}{bash}
# 切换到nightly分支
rustup default nightly
# 对代码进行展开
rustc -Z unstable-options --pretty=expanded src/main.rs
cargo rustc -- -Z unstable-options --pretty=expanded
# 如果代码需要依赖其他的非std的crate的，则应当如下执行
# rustc -Z unstable-options --pretty=expanded -L ../target/debug/deps src/main.rs
\end{code-block}
如果一切正常，则我们调用宏的代码就会被展开成如下的形式：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_macro_expand.png}
  \caption{宏展开}
  \label{fig:rust_macro_expand}
\end{figure}

Rust宏的灵活性非常大，可以像C/C++一样，在宏当中嵌套/调用宏：
\begin{code-block}{rust}
macro_rules! serial_cmd {
    ($expression: expr, $port: expr, $item: expr, $timeout: expr) => {{
        let mut cmd = HEADER.to_vec();
        cmd.push($item);
        cmd.push($expression);
        match ($port).write(&cmd) {
            Ok(_) => info!(
                "Sucess {}(0x{:X>02}) the {} board, and command is {:?}",
                stringify!($expression),
                $expression,
                $item,
                &cmd
            ),
            Err(e) => error!(
                "Failed to {}(0x{:X>02}) the {} board: {}",
                stringify!($expression),
                $expression,
                $item,
                e
            ),
        }
        if 0 < $timeout {
            thread::sleep(Duration::from_secs($timeout));
        }
    }};
}

macro_rules! serial_for_all_cmd {
    ($expression: expr, $port: expr, $timeout: expr) => {{
        for item in &CODE {
            serial_cmd!($expression, $port, *item, $timeout);
        }
    }};
}
\end{code-block}
也可以直接在宏当中，插入语句块，作为宏执行的一部分：
\begin{code-block}{rust}
macro_rules! serial_for_only_one {
    ($port: expr, $location: expr, $($command: stmt),*) => {{
        serial_cmd!(POWEROFF, $port, $location, 0);
        trace!("Remove the block file to avoid the unexcepted error ...");
        let _ = fs::remove_file("/dev/sdb");

        serial_cmd!(SWITCH, $port, $location, 5);
        // 执行外部代码块
        $($command )*

        serial_cmd!(POWEROFF, $port, $location, 0);
        let _ = fs::remove_file("/dev/sdb");
    }};
}

fn main() {
    // 调用宏
    serial_for_only_one!(port, location_u8, {println!("hello")});
}
\end{code-block}

\subsection{宏导出}
除了在当前的crate当中使用宏之外，
宏还可以导出，宏之间也可以相互调用。宏的导出通常使用macro\_export关键字，比如：
\begin{code-block}{rust}
#[macro_export]
macro_rules! inc {
    ($x: expr) => {
       println!("{}", $x);
    };
}
\end{code-block}
然后，在其他地方，就可以直接使用这个宏。不过，有的时候，宏的实现可能需要当前包的
一些函数或者方法进行配合，则需要做如下的更改：
\begin{code-block}{rust}
// 必须将方法设置为pub，否则后续在宏定义当中，无法使用
pub fn incr(x: u32) -> u32 {
    x + 1
}

#[macro_export]
macro_rules! inc {
    ($x: expr) => {
        // $crate关键字表示当前的包
        // 当宏被导出时，自动根据上下文选择函数调用路径当中的包名
        $crate::incr($x)
    };
}
\end{code-block}
上述的导出方式，要求宏所依赖的函数，也都必须导出，否则，在外部使用宏时，无法
正常工作。

除了使用普通的函数作为宏的依赖项之外，也可以使用宏作为宏的依赖项。和普通函数一样，
如果一个宏的定义当中，依赖了另外一个宏，则必须同样当对应的依赖项导出为pub类型。
但是，如果可以使用一种额外的方式，将依赖的宏，转变为宏的内部规则进行导出：
\begin{code-block}{rust}
#[macro_export]
macro_rules! hashmap {
    /* hashmap宏的内部规则，相当于如下的一个外部宏，不管接收多少参数，一律返回
       一个空元组()
       macro_rules! unit {
       ($($input:tt),*) => {
                ()
           };
       }
       使用方式
       let res = unit!(), unit!("lucifer"), unit!("garuda", "titans")
    */
    (@unit $($x:tt)*) => (());

    /* hashmap宏的内部规则, 等价于如下的一个宏，作用是返回接收到的元素的个数
       macro_rules! count {
           // <[()]>::len()可以用于求取数组/切片的长度，使用方式如下：
           // let lenth = <[&str]>::len(&["string", "string"])
           // let lenth = <[String]>::len(&["string".to_string(), "string".to_string()])
           // let lenth = <[()]>::len(&[(), ()]) // 性能更好，因为()不占据任何内存空间
           ($($key:expr),*) => (<[()]>::len(&[$(unit! ($key)),*]));
       }
       使用方式
       let res = count!(), count!("lucifer"), count!("lucifer", "titans")

       @符号表示一个宏定义当中的内部规则，如果需要在宏当中使用宏的内部规则，
       则使用方式是 宏名!(@内部规则名 其他变量)，对应到这个hashmap宏，则使用方式
       如下： hashmap!(@unit $key), hashmap!(@count $($rest),*)
    */
    (@count $($rest:expr), *) => (<[()]>::len(&[$(hashmap!(@unit $rest)),*]));

    /* $($key:expr => $value:expr),* 表达式本身可以匹配hashmap!()，hashmap!("1"=>2)
     但是，无法匹配类似hashmap!["2"=>3,]这种末尾包含,符号的模式
     $(,)* 则是用于匹配后续结尾是否带有,符号
     即hashmap!["2"=>3,]和hashmap!["2"=>3]都可以支持
    */
    ($($key:expr => $value:expr),* $(,)*) => {{
        let _cap = hashmap!(@count $($key),*);
        let mut _map = ::std::collections::HashMap::with_capacity(_cap);
        $( _map.insert($key, $value); )*
        _map
    }}
}
\end{code-block}

\subsection{过程宏}
以上提到的宏，都是声明宏，可以直接当作函数/方法使用的类型，但是，如果想实现类似于
\#[derive(Debug)]这种类型的宏，声明宏是做不到的。相对应的，这种类型的宏则被称之
为过程宏。过程宏主要用于下面3种用途：
\begin{itemize}
  \item 自定义派生属性：即类似于\#[derive(Debug)]这样的derive属性
  \item 自定义属性：即类似于实现\#[cfg()]这样的属性
  \item Bang宏：与声明宏类似，但是，是以!结尾的宏，可以当作函数/方法使用
\end{itemize}

过程宏要求必须放到proc\_macro类型的lib包当中，因此，过程宏的创建过程会稍微有一些
区别：
\begin{code-block}{bash}
cargo new --lib procmacro
echo -e "[lib]\nproc_macro=true" >> procmacro/Cargo.toml
\end{code-block}

另外，和其他的mod不太一样的是，过程宏的测试用例，不能放到相同的crate当中，必须以
外部的方式存在，因此，过程宏的文件结构大致如下：
\begin{code-block}{bash}
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    └── test.rs
\end{code-block}

实现derive方式的过程宏，其示例如下：
\begin{code-block}{rust}
// 必须如此进行使用
extern crate proc_macro;
use self::proc_macro::TokenStream;

#[proc_macro_derive(A)]
pub fn derive(input: TokenStream) -> TokenStream {
    let input = input.to_string();
    assert!(input.contains("struct A"));
    r#"
        impl A {
            pub fn a(&self) -> String {
                format!("Hello from impl A")
            }
        }
    "#
    .parse()
    .unwrap()
}
\end{code-block}
上述过程宏表示，使用\#[derive(A)]为结构体A实现一个a方法，方法直接输出一句话。相对应的，
测试用例当中的使用则应当修改如下：
\begin{code-block}{rust}
#[macro_use]
extern crate procmacro;

#[derive(A)]
struct A;
#[test]
fn test_derive_a() {
    assert_eq!("Hello from impl A", A.a());
}
\end{code-block}

而实现自定义属性宏稍微有些区别，就是必须在nightly的rust下编译，目前还没有进入到
stable分支，一个简单的示例如下：
\begin{code-block}{rust}
#![feature(register_attr)]
extern crate proc_macro;
use self::proc_macro::TokenStream;

#[proc_macro_attribute]
pub fn attr_with_args(args: TokenStream, _: TokenStream) -> TokenStream {
    let args = args.to_string();
    //let input = input.to_string();
    format!("fn foo() -> &'static str {{{}}}", args)
        .parse()
        .unwrap()
}
\end{code-block}
同样的，其测试用例如下：
\begin{code-block}{rust}
#![feature(register_attr)]
#[macro_use]
extern crate procmacro;
use procmacro::attr_with_args;

#[attr_with_args("Hello Rust")]
fn foo() {}

#[test]
fn test_foo() {
    assert_eq!("Hello Rust", foo());
}
\end{code-block}
原本的foo方法，不接收参数，同样没有返回值，但是，在attr\_with\_args这个过程宏
当中，将其强行修改为了一个返回为字符串切片的函数。

实现Bang宏的方式则如下：
\begin{code-block}{rust}
#![feature(proc_macro_hygiene)]
extern crate proc_macro;
use self::proc_macro::TokenStream;

#[proc_macro]
pub fn treemap(input: TokenStream) -> TokenStream {
    let input = input.to_string();
    let input = input.trim_end_matches(',');
    let input_v: Vec<String> = input
        .split(",")
        .map(|n| {
            let mut data = if n.contains(":") {
                n.split(":")
            } else {
                n.split("=>")
            };
            let (key, value) = (data.next().unwrap(), data.next().unwrap());
            format!("hm.insert({}, {})", key, value)
        })
        .collect();
    let count: usize = input.len();
    let token = format!(
        "{{
        let mut hm = ::std::collections::HashMap::with_capacity({});
        {}
        hm
    }}",
        count,
        input_v
            .iter()
            .map(|n| format!("{};", n))
            .collect::<String>()
    );
    token.parse().unwrap()
}
\end{code-block}

Bang宏可以如同声明宏一样的进行使用，其使用方式如下：
\begin{code-block}{rust}
#[macro_use]
extern crate procmacro;

#[test]
fn test_treemap() {
    let hm = treemap! {"a":1, "b": 2};
    assert_eq!(hm["a"], 1);
    let hm = treemap! {"a" => 1, "b" => 4};
    assert_eq!(hm["b"], 4);
}
\end{code-block}

过程宏的本质是在函数/方法当中，使用TokenStream重构，本质还是一个特殊的函数/方法。
因此，过程宏不需要像声明宏一样的进行export，但是，必须将过程宏的函数声明为pub，
生成的过程宏才可以被外部使用。

\subsection{语法树}
编写真正可用的过程宏实际上比上面的例子要复杂很多，但不管如何变化，Rust的宏都是依赖于
语法树结构的，而过程宏的实现方式/过程，就是对解析的语法树进行处理的过程。关于语法树
的解析和读取，通常采用的是第三方的Rust Crate进行操作，目前比较常用的是\href{https://github.com/dtolnay/quote}{Quote}，
\href{https://github.com/dtolnay/syn}{Syn}以及\href{https://github.com/alexcrichton/proc-macro2}{Proc-macro2}。
在编写真正的过程宏时，通常都需要上述3个crate的协助，需要在Cargo.toml当中添加如下的内容：
\begin{code-block}{toml}
[dependencies]
quote = "1.0.9"
syn = {version = "1.0.72", features = ["full", "extra-traits"]}
proc-macro2 = "1.0.26"

[lib]
proc-macro = true
\end{code-block}
另外，当lib当中设置\mintinline[breaklines=true,breakanywhere,breaksymbolleft=,breakanywheresymbolpre=,bgcolor=lbcolor]{toml}{proc-macro=true}之后，
则对应的crate只能导出过程宏，不能导出其他的类型数据。

所有的编程语言都离不开词法分析，Rust同样如此。在Rust当中，通常使用TokenStream进行词法分析，
解析代码内容，编写过程宏离不开对TokenStream的解析。在调试过程宏的时候，由于标准输出
不可用，因此通常只能通过标准错误输出进行信息的打印。通常情况下，都是使用\mintinline[breaklines=true,breakanywhere,breaksymbolleft=,breakanywheresymbolpre=,bgcolor=lbcolor]{rust}{eprint!}
或者\mintinline[breaklines=true,breakanywhere,breaksymbolleft=,breakanywheresymbolpre=,bgcolor=lbcolor]{rust}{eprintln!}进行过程宏的调试输出。
一个简单的过程宏示例如下，当然，由于我们进行了输出，也可以看到Rust的语法树的大致结构：
\begin{code-block}{rust}
use proc_macro::TokenStream;
#[proc_macro_attribute]
pub fn test_proc_macro(attr: TokenStream, item: TokenStream) -> TokenStream {
    eprintln!("{:#?}", attr);
    eprintln!("{:#?}", item);
    item
}
\end{code-block}
调用的时候，需要在其他的crate当中引入这个crate：
\begin{code-block}{rust}
use procmacros::test_proc_macro;
fn main() {
    ...
}
#[test_proc_macro("lucifer")]
fn hello() {
    info!("hello");
}
\end{code-block}

默认情况下，代码需要经过编译，才能判断是否存在问题，不过，rust提供了1种简便的思路
来检测代码是否存在问题：\mintinline[breaklines=true,breakanywhere,breaksymbolleft=,breakanywheresymbolpre=,bgcolor=lbcolor]{bash}{cargo check}。
该指令不会对代码进行实质的编译动作，但是会对过程宏进行预处理（即将其转变成正常的Rust代码），
因此，会得到类似如下的一些输出：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_cargo_check.png}
  \caption{代码检测与预处理}
  \label{fig:rust_cargo_check}
\end{figure}

除了使用上述指令之外，也可以采用宏展开的方式，但是默认的宏展开方式需要使用nightly
分支，第三方工具cargo-expand则可以支持在stable分支直接展开。
但是，需要注意expand指令只能在源码（即rs文件）所在路径执行：\mintinline[breaklines=true,breakanywhere,breaksymbolleft=,breakanywheresymbolpre=,bgcolor=lbcolor]{bash}{cargo expand}。
然后会得到类似如下的输出：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_cargo_expand.png}
  \caption{宏代码展开}
  \label{fig:rust_cargo_expand}
\end{figure}
通过expand指令，可以将代码当中的宏代码全部转换为正常的Rust代码，从而方便进行阅读
识别和调试修改。
