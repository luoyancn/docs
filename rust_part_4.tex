\subsection{高级函数式编程}
之前的函数式编程当中，提到了map函数，用于对数据进行处理，比如下面这种：
\begin{code-block}{rust}
let sum: u32 = c1
    .zip(c2.skip(10))
    .map(|(a, b)| a * b)
    .filter(|x| x % 3 == 0)
    .sum();
\end{code-block}

但是，实际使用当中，map还有更加广泛的用途，比如，在特定的情况下，替换match操作，
使得代码更加简单和精炼。比如，在使用match处理Option这种数据类型时，由于Option的
取值范围为Some和None，而map函数对于Option类型的处理，也恰好就是返回Some和None，
因此，可以直接使用map函数对这种Some对Some，None对None的简单映射关系进行处理，
多个不同的map进行组合，形成链式调用，相比而言，比match操作会更加简练：
\begin{code-block}{rust}
#[derive(Debug)]
enum Food {
    Apple,
    Potato,
}

#[derive(Debug)]
struct Peeled(Food);
#[derive(Debug)]
struct Chopped(Food);
#[derive(Debug)]
struct Cooked(Food);

// 常见的处理方法，使用match进行处理，并且返回一个Option
fn peel(food: Option<Food>) -> Option<Peeled> {
    match food {
        Some(food) => Some(Peeled(food)),
        None => None,
    }
}

// 使用map函数进行Option的简单映射
fn process(food: Option<Food>) -> Option<Cooked> {
    food.map(|f| Peeled(f))
        .map(|Peeled(f)| Chopped(f))
        .map(|Chopped(f)| Cooked(f))
}
\end{code-block}

然而，如果返回类型Option需要作为map函数的参数，输入到另外一个闭包或者函数当中，
则有可能出现Option<Option<T>>的结果出现，并不利于结果的解析，此时，则需要采用
and\_then进行处理，比如下方的代码：
\begin{code-block}{rust}
enum Food {
    CordonBleu,
    Steak,
    Sushi,
}

fn have_ingredients(food: Food) -> Option<Food> {
    match food {
        Food1::Sushi => None,
        _ => Some(food),
    }
}

fn have_recipe(food: Food) -> Option<Food> {
    match food {
        Food1::CordonBleu => None,
        _ => Some(food),
    }
}

// 通过map函数将上述2个函数进行连接起来，have_recipe当作一个闭包使用
// 但是，结果将变更为Option<Option<T>>
fn cookable_v1(food: Food) -> Option<Option<Food>> {
    have_ingredients(food).map(|res| have_recipe(res))
}

// 通过and_then将2个函数连接起来，形成链式调用
// have_ingredients返回的是一个Option，and_then会将其进行拆包
// 如果Option是None，则直接返回None；但是，如果是Some<T>，and_then则会将其
// 进行拆包，返回为T，而不是Some<T>
fn cookable_v2(food: Food) -> Option<Food> {
    have_ingredients(food).and_then(have_recipe)
}
\end{code-block}

Result和Option类似，但实质上，Option是Result的一个特化版本，可以将其简单的看作：
\begin{code-block}{rust}
type Option<T> = Result<T, ()>
\end{code-block}

因此，Option的map，and\_then等函数（算子）同样可以作用于Result上，比如下面的例子：
\begin{code-block}{rust}
use std::num::ParseIntError;

// 使用普通的match模式
fn multiply_v1(first_number_str: &str, second_number_str: &str) -> Result<i32, ParseIntError> {
    match first_number_str.parse::<i32>() {
        Ok(first_number)  => {
            match second_number_str.parse::<i32>() {
                Ok(second_number)  => {
                    Ok(first_number * second_number)
                },
                Err(e) => Err(e),
            }
        },
        Err(e) => Err(e),
    }
}

// 使用map与and_then模式
fn multiply_v2(first_number_str: &str, second_number_str: &str) -> Result<i32, ParseIntError> {
    // and_then将Result<T, E>拆分，如果是Err，直接返回，如果是T，即Ok(T)
    // 则进行解析为T
    first_number_str.parse::<i32>().and_then(|first_number| {
        second_number_str.parse::<i32>().map(|second_number| first_number * second_number)
    })
}
\end{code-block}

同样的，Result也可以使用别名系统，比如常见的io::Result，实际上就是Result的一个
别名特化版本：
\begin{code-block}{rust}
type Result<T> = Result<T, Error>;
\end{code-block}
因此，同样可以在代码当中使用Result的别名，对代码进行简化：
\begin{code-block}{rust}
use std::num::ParseIntError;

type AliasedResult<T> = Result<T, ParseIntError>;

fn multiply(first_number_str: &str, second_number_str: &str) -> AliasedResult<i32> {
    first_number_str.parse::<i32>().and_then(|first_number| {
        second_number_str
            .parse::<i32>()
            .map(|second_number| first_number * second_number)
    })
}

fn print(result: AliasedResult<i32>) {
    match result {
        Ok(n) => println!("n is {}", n),
        Err(e) => println!("Error: {}", e),
    }
}

fn main() {
    print(multiply("10", "2"));
    print(multiply("t", "2"));
}
\end{code-block}

由于Option和Result的特殊性，在一些特定的场合，尤其是处理错误的时候，常见的做法就是
混合Option和Result，进行混合类型的错误处理：
\begin{code-block}{rust}
use std::num::ParseIntError;

fn double_first(vec: Vec<&str>) -> Option<Result<i32, ParseIntError>> {
    // map返回Option，使用map包裹parse函数可能带来的错误信息（Result）
    vec.first().map(|first| first.parse::<i32>().map(|n| 2 * n))
}

fn double_first_v2(vec: Vec<&str>) -> Result<Option<i32>, ParseIntError> {
    let opt = vec.first().map(|first| first.parse::<i32>().map(|n| 2 * n));

    // map_or返回Result，其中，Ok子句处理opt为None的情况
    // r则处理opt为Some和Err的情况
    opt.map_or(Ok(None), |r| {
        println!("The r is error {:?}", r);
        r.map(Some)
    })
}

fn main() {
    let empty2 = vec![];

    match double_first_v2(empty2) {
        Ok(Some(x)) => println!("The result is {}", x),
        Err(e) => println!("Error is {:?}", e),
        Ok(None) => println!("None is in result"),
    }
}
\end{code-block}

\subsection{自定义错误}
Rust的错误是可以进行自行定义的，只需要实现一个Error Trait即可。Error Trait的定义
如下：
\begin{code-block}{rust}
pub trait Error: Debug + Display {
    fn source(&self) -> Option<&(dyn Error + 'static)> { ... }
    fn backtrace(&self) -> Option<&Backtrace> { ... }
    fn description(&self) -> &str { ... }
    fn cause(&self) -> Option<&dyn Error> { ... }
}
\end{code-block}
其中：
\begin{itemize}
  \item source是必须实现的函数，并且对应的错误必须实现Debug和Display Trait
  \item backtrace是只能在nightly分支当中实现的函数
  \item description被废弃，使用Display Trait或者to\_string（ToString Trait）替代
  \item cause同样被废弃，被source所取代
\end{itemize}

一个简单的例子如下：
\begin{code-block}{rust}
use std::error::Error;
use std::fmt;

// 定义自定义错误结构体
// 实现Debug Trait
#[derive(Debug)]
struct SuperError {
    msg: String,
}

// 实现Display Trait
impl fmt::Display for SuperError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Super Error: {}", self.msg)
    }
}

// 实现Error Trait
impl Error for SuperError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        Some(self)
    }
}

impl SuperError {
    fn new(err: &str) -> SuperError {
        SuperError {
            msg: err.to_string(),
        }
    }
}

fn err_test() -> Result<(), SuperError> {
    Err(SuperError::new("first error"))
}

fn main() {
    match err_test() {
        // Err(SuperError{msg: e}) => println!("{}", e),
        Err(e) => println!("{}", e),
        _ => println!("no error"),
    }
}
\end{code-block}

错误和自定义错误解决的是对于错误的定义，以及对应错误的处理方式，但是，在实际的生产
使用当中，错误可能是普遍存在的，而我们需要的数据可能并不包含错误信息，而是需要
将错误从正确的结果当中剔除，比如：
\begin{code-block}{rust}
fn main() {
    let strings = vec!["tofu", "93", "18"];
    let possible_numbers: Vec<_> = strings.into_iter().map(|s| s.parse::<i32>()).collect();
    println!("Results: {:?}", possible_numbers);
}
\end{code-block}
我们的本意是将Vec当中的字符串全部格式化为数值，但是，实际的结果当中，却把包含的
错误也一同包含进来了，需要想办法将错误信息过滤掉：
\begin{code-block}{rust}
fn main() {
    let strings = vec!["tofu", "93", "18"];
    let numbers: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        // filter_map进行过滤，只保留结果为ok的数据
        .filter_map(Result::ok)
        .collect();
    println!("Results: {:?}", numbers);
}
\end{code-block}

Result实现了FromIter，因此结果的向量（Vec<Result<T, E>>）可以被转换成结果包裹着
向量（Result<Vec<T>, E>）。一旦找到一个Result::Err，遍历就被终止，即满足另外一种
需求：只要任何一个错误发生，就中断当前的操作：
\begin{code-block}{rust}
fn main() {
    let strings = vec!["tofu", "93", "18"];
    // 注意numbers不再是Vec<_>，而是通过FromIter转换成了Result
    // 转换过程一旦失败，就会出现错误，中断当前的执行流程
    let numbers: Result<Vec<_>, _> = strings.into_iter().map(|s| s.parse::<i32>()).collect();
    println!("Results: {:?}", numbers);
}
\end{code-block}

但是，有的时候，我们也存在另外一种需求：将执行的正确和错误结果分类存放，以待后续
操作，此时则需要使用partition函数，对结果进行区分：
\begin{code-block}{rust}
fn main() {
    let strings = vec!["tofu", "93", "18"];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        // 使用partition函数进行区分
        .partition(Result::is_ok);
    println!("Numbers: {:?}", numbers);
    println!("Errors: {:?}", errors);

    // 对后续的结果进行解构
    let numbers: Vec<_> = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec<_> = errors.into_iter().map(Result::unwrap_err).collect();
    println!("Numbers: {:?}", numbers);
    println!("Errors: {:?}", errors);
}
\end{code-block}

\section{死灵书与实践}

\subsection{随机数实践}
Rust的随机数模块并不包含在标准库当中，需要使用rand这个crate，其基本的使用如下：
\begin{code-block}{rust}
use rand::distributions::{Distribution, Uniform};
use rand::seq::IteratorRandom;
use rand::Rng;

fn main() {
    let mut rng = rand::thread_rng();
    // 生成随机数
    info!("The float64 rand number is {}", rng.gen::<f64>());
    info!("The u32 rand number is {}", rng.gen::<u32>());
    info!("The i32 rand number is {}", rng.gen::<i32>());
    info!("The u8 rand number is {}", rng.gen::<u8>());
    // 从指定区间生成随机数
    info!("The range rand number is {}", rng.gen_range(0..100));
    info!(
        "The range rand float number is {}",
        rng.gen_range(10.0..50.0)
    );
    // 从[0, 5]生成随机数
    info!("The range rand number is {}", rng.gen_range(0..=5));

    // 定义[1, 7)的均匀分布
    let die = Uniform::from(1..7);
    // 从该分布当中生成采样
    let throw = die.sample(&mut rng);
    info!("The sample of uniform is {:>width$}", throw, width = 5);

    // 生成多个随机数
    let tuple: (u8, u8, u8) = rng.gen();
    info!("The tuple of random is {:?}", tuple);
    // 生成随机数组
    let array: [u8; 6] = rng.gen();
    info!("The array of random is {:?}", array);
    let mut exsit_array: [u8; 5] = [1, 2, 34, 5, 6];
    // 使用随机数填充已存在的数组
    rng.fill(&mut exsit_array);
    info!("The array of random is {:?}", exsit_array);

    // 从均匀分布当中随机采样3个数据
    // 得到的结果可能出现重复的情况
    let samples: Vec<u8> = (&mut rng).sample_iter(die).take(3).collect();
    info!("The samples of sample range 1..7 is {:?}", samples);

    let v = vec![1, 2, 3, 4, 5];
    // 从vec当中采样4个数据，得到的结果不会重复
    let sample = v.iter().choose_multiple(&mut rng, 4);
    info!("The samples of sample range 1..5 is {:?}", sample);
    let sample: Vec<u8> = (1..=10).choose_multiple(&mut rng, 4);
    info!("The samples of sample range 1..10 is {:?}", sample);
}
\end{code-block}

Rust的rand crate不仅可以生成随机数，也可以生成自定义的随机数据，比如：
\begin{code-block}{rust}
use rand::distributions::{Distribution, Standard, Uniform};
use rand::seq::IteratorRandom;
use rand::Rng;

struct Point {
    x: u8,
    y: u8,
}

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "x: {}, y: {}", self.x, self.y)
    }
}

// 在 Point 类型之上，对Standard实现Distribution trait，使得Point可以被gen函数随机生成
impl Distribution<Point> for Standard {
    // 默认的实现方法
    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Point {
        let (rand_x, rand_y) = rng.gen();
        Point {
            x: rand_x,
            y: rand_y,
        }
    }
}

fn main() {
    let mut rng = rand::thread_rng();
    let rand_point = rng.gen::<Point>();
    info!("The rand_point is {}", rand_point);
}
\end{code-block}

同样的，可以生成随机的字符串：
\begin{code-block}{rust}
use rand::distributions::{Alphanumeric, Distribution, Standard, Uniform};
use rand::seq::IteratorRandom;
use rand::Rng;

fn main() {
    let mut rng = rand::thread_rng();
    let rand_string: String = (&mut rng)
        // 从a-z，A-Z以及0-9当中进行选择
        .sample_iter(&Alphanumeric)
        // 获取其中的10个元素
        .take(10)
        // 默认的结果是char类型，需要继续转换成String
        .map(char::from)
        .collect();
    info!("The rand_string is {}", rand_string);
}
\end{code-block}

如果默认的字符集不满足要求，还可以自定义字符集，比如下面的示例：
\begin{code-block}{rust}
use rand::distributions::{Alphanumeric, Distribution, Standard, Uniform};
use rand::seq::IteratorRandom;
use rand::Rng;
const CHARSET: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\
    abcdefghijklmnopqrstuvwxyz\
    0123456789)(*&^%$#@!~";
const PASSWORD_LEN: usize = 10;

fn main() {
    let mut rng = rand::thread_rng();
    let password: String = (0..PASSWORD_LEN)
        .map(|_| {
            let idx = rng.gen_range(0..CHARSET.len());
            CHARSET[idx] as char
        })
        .collect();
    info!("The password is {}", password);

    // 也可以更换成之前的采样函数，看起来更为精炼
    let passwd: String = CHARSET
        .choose_multiple(&mut rng, 10)
        .map(|r| *r as char)
        .collect();
    info!("The password is {}", passwd);
}
\end{code-block}

同样的，针对自定义的数据类型，同样可以采用采样方法，进行随机数据的提取：
\begin{code-block}{rust}
use rand::distributions::{Alphanumeric, Distribution, Standard, Uniform};
use rand::seq::IteratorRandom;
use rand::Rng;

#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

fn main() {
    let mut rng = rand::thread_rng();
    let persons = vec![
        Person {
            name: "lucifer".to_string(),
            age: 18,
        },
        Person {
            name: "titans".to_string(),
            age: 19,
        },
        Person {
            name: "garuda".to_string(),
            age: 36,
        },
    ];

    // 从person的vec当中，随机抽取2个元素
    let rand_person: Vec<_> = persons.choose_multiple(&mut rng, 2).collect();
    info!("The rand person is {:?}", rand_person);
}
\end{code-block}

\subsection{类型再论}
Rust的类型比较多，char，字符串，整数，浮点数等等。这些基础类型和其他语言比较类似，
但是也包含了自己的特点：比如，char类型占据4个字节，可以存放任何一个unicode字符；
对于ASCII字符，只需要一个字节即可，而一个字节的数据，则可以放在u8类型的数据当中，
因此，对于ASCII类型的字符串/字符数组，可以使用u8类型（即单字节）的数组进行存放，
这样，占用的资源空间会比char的数组小：
\begin{code-block}{rust}
fn main() {
    // 字符串前面的b，表示将对应的字面量存放在u8类型当中
    let s: &[u8] = b"hello";
    info!("{:?}", s);
}
\end{code-block}
同时，Rust支持的整数类型比较广泛，包括8bit，16bit，32bit，64bit，最大可以支持到
128bit；而特殊的isize和usize，则是和平台相关。如果平台是32位的，则isize和usize为
32位，如果是64位，则其数据宽度为64位。

整个Rust的类型当中，只有空类型占据的空间是最小的，都是0。Rust的空类型包括单元类型
（unit，即空元组）以及空结构体：
\begin{code-block}{rust}
// empty是空元组类型
let empty : () = ();

// 空结构体
struct Empty();
\end{code-block}
为了查看类型所占用的空间，可以使用size\_of函数进行查看：
\begin{code-block}{rust}
use std::mem;

struct Empty();
fn main() {
    info!("The Empty struct size is {}", mem::size_of::<Empty>());
    // 查看空元组所占据的内存大小
    info!("The none tuple size is {}", mem::size_of::<()>());
}
\end{code-block}

\subsection{常见错误处理方法}
由于很多代码都是第三方的，而Rust本身也在不断的发展，有可能出现版本不兼容或者特性
不兼容的情况，此时，则需要进行相关的修改。比如下面的一种错误：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_feature_error.png}
  \caption{缺少特性支持编译失败}
  \label{fig:rust_feature_error}
\end{figure}
遇到这种错误，则需要直接修改对应的类库的源代码。以上述错误为例，编译的help表示
\mintinline[breaklines=true,breakanywhere,breaksymbolleft=,breakanywheresymbolpre=,]{bash}{add `#![feature(array_value_iter_slice)]` to the crate attributes to enable}，
则我们应当在对应的crate的lib.rs的头部当中，添加内容如下：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_feature_add.png}
  \caption{增加特性支持}
  \label{fig:rust_feature_add}
\end{figure}
