\section{Match与模式匹配}
Match是Rust常用的语法糖，其用法不局限于之前所讲的范围。关于match的用法，还有很多，
并且，多数和模式匹配有关，接下来可以看一些常见的match和模式匹配的使用方式。
\begin{outline}[enumerate]
\1 多种匹配模式

在match表达式当中，可以用|匹配多个模式，表示或运算：
\begin{code-block}{rust}
let x = 1;
match x {
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
}
\end{code-block}

\1 使用..=匹配范围

..=语法允许匹配一个数值范围内的任意数据，常用于数值和字符：
\begin{code-block}{rust}
let x = 5;
match x {
    1..=5 => println!("one through five"),
    _ => println!("something else"),
}

let y = 'c';
match y {
    'a'..='j' => println!("early ASCII letter"),
    'k'..='z' => println!("late ASCII letter"),
    _ => println!("something else"),
}
\end{code-block}

\1 解构结构体

Let模式可以将结构体当中的字段/元素进行解构，单独或者批量赋予其他元素：
\begin{code-block}{rust}
struct Point {
    x: i32,
    y: i32,
}
fn main() {
    let p = Point { x: 0, y: 7 };
    // 将p的x字段的值赋予a，y字段的值赋予b，a和b是整数类型，不是引用
    let Point { x: a, y: b } = p;
    // let Point {x: ref a, y: ref b} = p; 和上面类似，但是a和b是整数类型的引用
    // let Point {x: a, y: _} = p; 表示只需要将x的值赋予a，但不需要对y进行解构
    assert_eq!(0, a);
    assert_eq!(7, b);
    // let Point {x, y} = p; 将p的x字段的值赋予变量x，y字段的值赋予变量y
}
\end{code-block}

\1 解构枚举类型

Match本身就是应枚举而生的，因此天然的可以使用它对枚举进行解构：
\begin{code-block}{rust}
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
fn main() {
    let msg = Message::ChangeColor(0, 160, 255);
    match msg {
        Message::Quit => {
            println!("The Quit variant has no data to destructure.")
        }
        Message::Move { x, y } => {
            println!("Move in the x direction {} and in the y direction {}", x, y);
        }
        Message::Write(text) => println!("Text message: {}", text),
        Message::ChangeColor(r, g, b) => {
            println!("Change the color to red {}, green {}, and blue {}", r, g, b)
        }
    }
}
\end{code-block}

同样的，如果枚举当中嵌套了枚举，仍然可以使用match进行解构：
\begin{code-block}{rust}
enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}
fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));
    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) => {
            println!("Change the color to red {}, green {}, and blue {}", r, g, b)
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) => {
            println!(
                "Change the color to hue {}, saturation {}, and value {}",
                h, s, v
            )
        }
        _ => (),
    }
}
\end{code-block}

\1 解构复合数据

用复杂的方式来混合、匹配和嵌套解构模式，解析出我们感兴趣的数据：
\begin{code-block}{rust}
let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });
\end{code-block}

\1 忽略不需要的元素

在Rust的当中，默认可以使用\_对不必要的变量进行忽略，通常用在match的最后分支，但是，
实际上也可以用去其他任意的模式，甚至是函数参数：
\begin{code-block}{rust}
// 需要传入2个参数，但是忽略第一个参数
fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {}", y);
}
fn main() {
    foo(3, 4);
}
\end{code-block}

除了使用\_进行忽略之外，还可以使用..语法糖进行忽略，但是针对结构体和元组存在区别：
结构体当中，忽略的是没有被列出的字段；而元组忽略的则是范围：
\begin{code-block}{rust}
struct Point {
    x: i32,
    y: i32,
    z: i32,
}
fn main() {
    let origin = Point { x: 0, y: 0, z: 0 };
    // 将point的y进行忽略
    match origin {
        Point { x,z, .. } => println!("x is {}, z is {}", x, z),
    }
    let numbers = (2, 4, 8, 16, 32);
    match numbers {
        // 忽略元组当中除第1、2和最后一项的所有元素
        (first, second, .., last) => {
            println!("Some numbers: {}, {}, {}, ", first, second, last);
        }
    }
}
\end{code-block}

同样的，忽略操作也可以用于闭包当中：
\begin{code-block}{rust}
let player_scores = [("Jack", 20), ("Jane", 23), ("Jill", 18), ("John", 19)];
// 对player_scores进行迭代，忽略其中第二个元素，_可以被替换为_score
let players: Vec<_> = player_scores.iter().map(|&(player, _)| player).collect();
// 输出的结果当中将只会有字符串数据
println!("{:?}", players);
\end{code-block}

\1 @绑定

运算符@允许我们在创建一个存放值的变量的同时测试其值是否匹配模式，比如测试字段是
否位于指定范围内，同时也希望能将其值绑定到另外的变量中以便此分支相关联的代码可以
使用它：
\begin{code-block}{rust}
enum Message {
    Hello { id: i32 },
}
let msg = Message::Hello { id: 5 };
match msg {
    // 将变量id保存到另一个变量ip_variable当中
    Message::Hello { id: id_variable @ 3..=7 } => {
        println!("Found an id in range: {}", id_variable)
    },
    Message::Hello { id: 10..=12 } => {
        println!("Found an id in another range")
    },
    Message::Hello { id } => {
        println!("Found some other id: {}", id)
    },
}
\end{code-block}
\end{outline}

\section{高级特征}
Rust设计不仅仅是为了开发应用程序，其设计之初，就是为了解决内存安全的问题，并且可以
广泛用于各种场景，包括C语言的专属领域：操作系统设计。在编写操作系统的过程当中，
C语言使用了很多的高级宏定义以及一些精妙的设计，而Rust同样如此。为了和硬件打交道，
Rust被设计为可以拥有直接操作硬件的能力，这些都是其高级特性的一部分。Rust的高级
特性主要包含下列内容：
\begin{enumerate}
  \item 高级 Trait
  \item 高级函数和闭包
  \item 宏
\end{enumerate}

\subsection{高级Trait}
Trait的语法当中，使用了如下的代码形式：
\begin{code-block}{rust}
impl Iterator for Counter {
    type Item = u32;
    fn next(&mut self) -> Option<Self::Item> {
        ...
    }
}
\end{code-block}
其中，type Item表示关联数据类型，Item表示占位类型，next方法定义表明它返回
Option<Self::Item>类型的值。这个trait的实现者会指定Item的具体类型。
在Trait当中，除了默认方法，方法覆写之外，Rust并不允许创建自定义的运算符，
或者重载任意运算符，只有std::ops当中所列出的运算符和相应的trait可以通过实现
运算符相关的trait来实现重载，比如下面，实现Add trait来实现对+的运算符重载：
\begin{code-block}{rust}
use std::fmt;
use std::ops::{Add, AddAssign};
struct Point {
    x: u8,
    y: u8,
}
// 实现结构体的 c = a + b
impl Add for Point {
    type Output = Point;
    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}
// 实现结构体的 a = a + b;
impl AddAssign for Point {
    fn add_assign(&mut self, other: Point) {
        self.x = self.x + other.x;
        self.y = self.y + other.y;
    }
}
impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "x:{}, y:{}", self.x, self.y)
    }
}
fn main() {
    let a = Point { x: 3, y: 4 };
    let b = Point { x: 5, y: 6 };
    let c = a + b;
    let mut d = Point { x: 100, y: 101 };
    d = d + c;
    println!("{}", d);
}
\end{code-block}

以Add Trait为例，其内部的实现如下：
\begin{code-block}{rust}
#[lang = "add"]
pub trait Add<Rhs = Self> {
    type Output;
    #[must_use]
    fn add(self, rhs: Rhs) -> Self::Output;
}
\end{code-block}
其中，RHS=Self这个语法叫做默认类型参数。RHS是一个泛型类型参数，它用于定义add方法
中的rhs参数。如果实现Add trait时不指定RHS的具体类型，RHS的类型将是默认的Self类型
也就是在实现Add Trait的类型。在上述例子当中，RHS就是Point这个类型。但是，也可以使用
不同的数据类型，比如下面的例子：
\begin{code-block}{rust}
struct Meters(i32);
struct Millimeters(i32);
impl Add<Meters> for Millimeters {
    type Output = Millimeters;
    fn add(self, other: Meters) -> Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
\end{code-block}
定义一个结构体米，和结构体毫米，然后定义毫米与米的加法操作，当结构体毫米与结构体
米进行相加时（注意顺序），将结果转换成毫米结果：
\begin{code-block}{rust}
let meters = Meters(1);
let mill_meters = Millimeters(10);
let mill_meters_other = mill_meters + meters;
\end{code-block}
但是，如果将上述代码的顺序更换如下：
\begin{code-block}{rust}
let mill_meters_other = meters + mill_meters;
\end{code-block}
则会出现如下的错误：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_override_error.png}
  \caption{尝试进行不同类型的加法重载操作}
  \label{fig:rust_override_error}
\end{figure}
修复上述的错误也很简单，增加结构体米的加法操作重载运算符即可：
\begin{code-block}{rust}
struct Meters(i32);
struct Millimeters(i32);
impl Add<Meters> for Millimeters {
    type Output = Millimeters;
    fn add(self, other: Meters) -> Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
impl Add<Millimeters> for Meters {
    type Output = Millimeters;
    fn add(self, other: Millimeters) -> Millimeters {
        Millimeters(self.0 * 1000 + other.0)
    }
}
\end{code-block}
这样，在进行结构体米和结构体毫米之间的加法操作是，无需考虑操作数的顺序。

在之前，也提到了Deref Trait的用法，通常用于进行智能指针的解引用操作，使得智能指针
可以直接当作指定的类型使用。不过Deref Trait不仅仅可以针对智能指针，也可以对自定义
的数据类型添加其他各种操作。比较典型的例子，现在有一个Vec，其中包含的数据类型是
String，如果需要打印这个Vec<String>，则必须使用debug这个宏定义；如果不想使用这个
debug，则必须在Vec<String>上实现Display Trait，但是Display Trait是无法直接作用在
Vec<String>上的，因此我们可以采用一种方式，在一个结构体当中包含匿名的Vec<String>，
然后在这个结构体上实现Display Trait，如下：
\begin{code-block}{rust}
use std::fmt;
use std::ops::{Deref, DerefMut};
struct VecWrapper(Vec<String>);
impl Deref for VecWrapper {
    type Target = Vec<String>;
    fn deref(&self) -> &Vec<String> {
        &self.0
    }
}
impl DerefMut for VecWrapper {
    fn deref_mut(&mut self) -> &mut Vec<String> {
        &mut self.0
    }
}
impl fmt::Display for VecWrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[")?;
        for item in &self.0 {
            write!(f, "{}, ", item)?;
        }
        write!(f, "]")
    }
}
fn main() {
    let mut v = VecWrapper(vec![String::from("hello"), String::from("world")]);
    v.push("zhangjl".to_string());
    for item in &v.0 {
        println!("{}", item);
    }
    println!("{}", v);
}
\end{code-block}
在上述代码当中，使用VecWrapper将Vec<String>进行简单的封装，然后使用Deref Trait
实现对VecWrapper的解引用（包括可变和不可变），将对VecWrapper的解引用操作重定向
到直接访问Vec<String>，这样带来的好处如下：
\begin{enumerate}
  \item 无需针对VecWrapper进行额外的其他操作，即可使用所有Vec<String>的所有方法
  \item 可以如同Vec一样的进行任意的操作
  \item 可以实现VecWrapper的自定义函数/方法，但又不影响原本的Vec操作
\end{enumerate}

另外需要注意，在上述代码当中，我们再次使用了?操作符，由于write本身返回的是一个
Result类型，但是，如果write操作后面添加分号符，表示目前只考虑了正确的模式，忽略
了错误的处理，因此编译器会提示警告。为了消除这个警告，则可以使用?代替Result类型，
同时继续正确和错误分支的处理。

同样的，上述的代码VecWrapper可以做成泛型，如下：
\begin{code-block}{rust}
use std::ops::{Deref, DerefMut};
struct VecWrapper<T>(Vec<T>);
impl<T> Deref for VecWrapper<T> {
    type Target = Vec<T>;
    fn deref(&self) -> &Vec<T> {
        &self.0
    }
}
impl<T> DerefMut for VecWrapper<T> {
    fn deref_mut(&mut self) -> &mut Vec<T> {
        &mut self.0
    }
}
\end{code-block}
上述的代码只是将Vec做了一次封装，可以使用任何的Vec方法，但是，我们将无法对这个
类型实现Display Trait，因为泛型T本身是无法实现Display Trait的。

Trait的另外一个非常重要的用途就是实现继承。涉及到继承实现，不可避免的会遭遇到
函数/方法的重载/覆写，尤其是多重继承的时候。在Rust当中，同样允许不同的Trait有相
同的函数/方法定义，也同样允许一个类型实现多个Trait，比如下面的代码：
\begin{code-block}{rust}
trait Pilot {
    fn fly(&self);
    fn name();
}
trait Wizard {
    fn fly(&self);
    fn name();
}
struct Empty;
impl Pilot for Empty {
    fn fly(&self) {
        println!("This is the implement of Pilot fly method");
    }
    fn name() {
        println!("This is the name method of Pilot implement");
    }
}
impl Wizard for Empty {
    fn fly(&self) {
        println!("This is the implement of Wizard fly method");
    }
    fn name() {
        println!("This is the name method of Wizard implement");
    }
}
\end{code-block}
Trait Pilot和Wizard定义了一个同名的方法，以及一个同名的关联函数（没有self做参数），
然后结构体Empty实现了这2个Trait，但是本身没有任何的方法/函数。但是，在使用的时候，
则必须注意，一定要进行Trait的指定或者转换，否则由于存在同名函数/方法，可能导致
代码的二义性出现，从而导致错误：
\begin{code-block}{rust}
fn main() {
    let empty = Empty {};
    empty.fly();
    Empty::name();
}
\end{code-block}
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_same_name.png}
  \caption{实现包含同名函数/方法的多个Trait}
  \label{fig:rust_same_name}
\end{figure}
解决这种问题的方法主要有2种思路：1是增加Empty结构体自身的同名函数/方法的实现，
但这种思路相当于完全没有利用Trait的任何功能；2是对Empty进行Trait的指定，如下：
\begin{code-block}{rust}
fn main() {
    let empty = Empty {};
    Wizard::fly(&empty);
    Pilot::fly(&empty);
    <Empty as Wizard>::name();
    <Empty as Pilot>::name();
}
\end{code-block}
同样的，如果不同的Trait包含了同名的方法/函数，但是参数和返回值定义不同，在使用的
时候，也需要进行明确的指定：
\begin{code-block}{rust}
trait Pilot {
    fn fly(&self);
    fn name();
}
trait Wizard {
    fn fly(&self, name: &str);
    fn name(age: u8) -> u8;
}
...
fn main() {
    let empty = Empty {};
    Wizard::fly(&empty, "lucifer");
    <Empty as Wizard>::name(64);
}
\end{code-block}

\subsection{高级函数和闭包}
Rust的函数和闭包都有很多类似的地方，和C/C++的函数也类似，确切的说，是非常类似于
C/C++当中的函数指针，因此，Rust的函数和闭包，也可以作为函数的参数以及返回值。但是，
函数作为参数和返回值与闭包有些区别，先看使用函数作为参数与返回值，如下：
\begin{code-block}{rust}
fn newmethod() -> fn(u32) -> u32 {
    calc
}

fn fn_as_params(age: u32, f: fn(u32) -> u32) {
    println!("In the fn_as_params: {}", f(age));
}

fn calc(age: u32) -> u32 {
    age * 100
}

fn main() {
    let b = newmethod();
    println!("{}", b(32));

    fn_as_params(32, calc);
}
\end{code-block}
可以看到，函数作为参数和返回值，基本用法和C/C++当中的方式是一致的。但是，使用闭包
的情形有些区别：闭包缺少具体的大小（size）描述，如果直接传递闭包，则会因为编译器
无法知道当前参数的大小而报错，因此，当使用闭包作为参数时，需要如下进行处理：
\begin{code-block}{rust}
// 直接使用闭包
fn hello(age: u32, func: &dyn Fn(u32) -> u32) {
    println!("{}", func(age));
}

// 使用Box智能指针
fn recv(age: u32, func: Box<dyn Fn(u32) -> u32>) {
    println!("{}", func(age));
}

// 使用Fn Trait
fn asparams(age: u32, func: impl Fn(u32) -> u32) -> u32{
    func(age)
}

fn add(start: u32) -> u32 {
    start + 100
}

fn main() {
    let c = |x| x * 10;
    recv(10, Box::new(c));
    hello(8, &c);
    // 2种方式都可以
    asparams(8, &c);
    asparams(8, c);
    // Fn Trait针对函数
    asparams(8, add);
    asparams(8, &add);
}
\end{code-block}
特别提倡使用Fn Trait的方式，因为这种方式，可以处理闭包和闭包的引用，同时，同样可以
处理函数以及函数的引用，相当于是一种比较万能的方式。

同样的，使用闭包作为函数的返回值，也是需要进行额外的特殊处理：
\begin{code-block}{rust}
// 使用Box智能指针
fn newclosur() -> Box<dyn Fn(u32) -> u32> {
    Box::new(|x| x * 100)
}

// 使用Fn Trait
fn return_closur() -> impl Fn(u32) -> u32 {
    |x| x * 120
}

fn main() {
    let a = newclosur();
    println!("{}", a(12));

    let a = return_closur();
    println!("{}", a(18));
}
\end{code-block}
和上述的使用闭包的情形类似，使用Fn Trait的方式，不仅可以使用闭包作为返回值，同样
可以使用函数作为返回值。

\subsection{高级类型}
默认情况下，我们使用的Rust变量都是有类型的，而这些类型，默认情况下都需要书写完整。
如果名称太长，则会导致阅读比较麻烦，因此，Rust提供了别名。注意，Rust的别名与Golang
的别名不一样：Rust的类型别名拥有和原始类型相同的函数和方法，可以进行原始名称和
别名系统的自动转换和其他操作，但是Golang的类型别名和原始类型无法直接进行自动转换
和计算。Rust的别名如下：
\begin{code-block}{rust}
enum VeryVerboseEnumOfThingsToDoWithNumbers {
    Add,
    Subtract,
}
// 定义别名
type Operations = VeryVerboseEnumOfThingsToDoWithNumbers;
fn main() {
    // 直接使用别名
    let x = Operations::Add;
}
\end{code-block}
同样的，别名还可以用于其它场合，比如在impl的代码当中使用Self别名（注意大写）：
\begin{code-block}{rust}
enum VeryVerboseEnumOfThingsToDoWithNumbers {
    Add,
    Subtract,
}
impl VeryVerboseEnumOfThingsToDoWithNumbers {
    fn run(&self, x: i32, y: i32) -> i32 {
        match self {
            // 替换原本的 VeryVerboseEnumOfThingsToDoWithNumbers::Add方式
            Self::Add => x + y,
            Self::Subtract => x - y,
        }
    }
}
\end{code-block}

Enum这种类型在之前的讲解当中，没有看到使用其当作各种类似于C/C++相同的值应用。但是，
实际上，Enum是可以直接使用变量值的方式的，同样的，Enum是可以转换成整数数值的：
\begin{code-block}{rust}
enum Number {
    Zero,
    One,
    Two,
}
enum Color {
    Red = 0xff0000,
    Green = 0x00ff00,
    Blue = 0x0000ff,
}

fn main() {
    println!("zero is {}", Number::Zero as i32);
    println!("one is {}", Number::One as i32);
    println!("roses are #{:06x}", Color::Red as i32);
    println!("violets are #{:06x}", Color::Blue as i32);
}
\end{code-block}

Rust的类型之间是可以相互进行转换的，但是Rust的类型转换必须使用显式的方式，不支持
隐式数据类型转换，数据类型转换必须使用as关键字，并且，转换也会存在数据溢出的情况：
\begin{code-block}{rust}
let deciamal = 65.81_f32;
let interer: u8 = deciamal as u8;
// 无法从浮点数直接转换成char类型
let charter: char = interer as char;
\end{code-block}
当从任何数转换成无符号数据（比如u64，u32，u8），则会在原始数据上进行加/减当前数据
类型的最大值+1，直到最后的数据处于新的无符号数据的有效数据范围内：
\begin{code-block}{rust}
let start = 1000;
let start_nev = -1000;
// 1000 -(255+1) - (255+1) - (255+1)
let res1 = start as u8;
// -1000 + (255+1) + (255+1) + (255+1) + (255 + 1)
let res2 = start_nev as u8
\end{code-block}

但是，当转换的类型不是数值类型，而是复合数据类型，则需要使用From和Into这2个Trait。
一般情况下，只要实现了From Trait，就默认的实现了Into Trait，比如下方代码：
\begin{code-block}{rust}
use std::convert::From;
struct Point {
    x: i32,
    y: i32,
}

// 实现From trait，只能从(i32,i32)到结构体，不能反向
// 同样的，Into也是只能从(i32,i32)到结构体，不能反向
impl From<(i32, i32)> for Point {
    fn from(item: (i32, i32)) -> Self {
        Point {
            x: item.0,
            y: item.1,
        }
    }
}

// 如果想实现从结构体到(i32, i32)的自动转换，则需要实现另外的From
impl From<Point> for (i32, i32) {
    fn from(item: Point) -> Self {
        (item.x, item.y)
    }
}

fn main() {
    // 显式的调用from
    let p1 = Point::from((81, 99));
    println!("{}, {}", p1.x, p1.y);

    // 显式的调用into（隐式实现的Into Trait）
    let p1: Point = (100, 101).into();
    println!("{}, {}", p1.x, p1.y);

    // 从结构体到(i32, i32)的自动转换
    let (x, y): (i32, i32) = p1.into();
    // 但是通常不这么做，而是使用模式匹配进行解决，而且模式匹配更为灵活，如下
    let Point{x:a, y: b} = p1;
}
\end{code-block}

如果复合数据类型进行转换，不能保证一定成功，则需要使用TryFrom以及TryInfo，如下：
\begin{code-block}{rust}
use std::convert::TryFrom;

struct Point {
    x: u8,
    y: u8,
}

impl TryFrom<(u8, u8)> for Point {
    type Error = ();
    fn try_from(value: (u8, u8)) -> Result<Self, Self::Error> {
        if value.0 % 2 == 0 && value.1 % 2 == 0 {
            Ok(Point {
                x: value.0,
                y: value.1,
            })
        } else {
            Err(())
        }
    }
}

fn main() {
    let tup = (32, 63);
    let p = Point::try_from(tup).expect("Invalid Params");
    println!("{}, {}", p.x, p.y);
}
\end{code-block}

作为通用的需求，将复合数据类型进行打印输出，可以采用debug宏，可以实现Display Trait，
还可以实现to\_string方法（ToString Trait）：
\begin{code-block}{rust}
use std::string::ToString;

struct Point {
    x: u8,
    y: u8,
}

impl ToString for Point {
    fn to_string(&self) -> String {
        format!("Point x:{}, y:{}", self.x, self.y)
    }
}

fn main() {
    let p = Point { x: 12, y: 127 };
    println!("{}", p.to_string());
}
\end{code-block}
通常情况下，Display和ToString两者实现其一即可。除了将结构体转换成字符串，也可以将
字符串转换成结构体，而这时就需要使用FromStr这个Trait，只是普通场景下，使用不多：
\begin{code-block}{rust}
use std::num::ParseIntError;
use std::str::FromStr;
use std::string::ToString;

struct Point {
    x: u8,
    y: u8,
}

impl ToString for Point {
    fn to_string(&self) -> String {
        format!("Point x:{}, y:{}", self.x, self.y)
    }
}

impl FromStr for Point {
    type Err = ParseIntError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let coords: Vec<&str> = s
            .trim_matches(|p| p == '(' || p == ')')
            .split(',')
            .collect();

        let x_fromstr = coords[0].replace(" ", "").parse::<u8>()?;
        let y_fromstr = coords[1].replace(" ", "").parse::<u8>()?;

        Ok(Point {
            x: x_fromstr,
            y: y_fromstr,
        })
    }
}

fn main() {
    let p = Point::from_str("(1, 203   )").unwrap();
    println!("{}", p.to_string());
}
\end{code-block}

Rust当中没有goto语句的存在，对于某些特殊的场景，比如多层循环的内部跳出就显得不是
非常友好。因此，Rust也提供了label的机制，允许直接break对应的label，从而快速跳出
循环结构：
\begin{code-block}{rust}
fn main() {
    // 定义循环的标签
    'outer: loop {
        println!("Entered the outer loop");
        'inner: loop {
            println!("Entered the inner loop");

            // 这只是中断内部的循环
            //break;

            // 这会中断外层循环
            break 'outer;
        }
        println!("This point will never be reached");
    }
    println!("Exited the outer loop");
}
\end{code-block}

除了上述这些类型之外，在之前的Trait当中，提到了关联数据类型。关联数据类型通常用在
Trait当中，比如下方的Trait定义：
\begin{code-block}{rust}
trait Container {
    type A;
    type B;
    fn contains(&self, item_a: Self::A, item_b: Self::B) -> bool;
    fn first(&self) -> Self::A;
    fn last(&self) -> Self::B;
    fn val(&self) -> u8;
}

// 如果没有type A和type B的定义，则下面的方法必须写成如下的形式：
// fn difference<A, B, C>(container: &C) -> u8 where
//    C: Container<A, B> { ... }

fn difference<C: Container>(c1: &C, c2: &C) -> u8 {
    c1.val() - c2.val()
}

struct People<'a> {
    name: &'a str,
    age: u8,
}

impl<'a> Container for People<'a> {
    type A = &'a str;
    type B = u8;

    fn contains(&self, item_a: &str, item_b: u8) -> bool {
        self.age == item_b && self.name == item_a
    }
    fn first(&self) -> &'a str {
        self.name
    }
    fn last(&self) -> u8 {
        self.age
    }
    fn val(&self) -> u8 {
        self.age
    }
}

fn main() {
    let p = People {
        name: "zhangjl",
        age: 32,
    };
    println!("{}", p.last());
    println!("{}", p.first());
    println!("{}", p.contains("zhangjl", 32));
}
\end{code-block}

Rust当中，还存在一种非常特殊的类型：虚类型（phantom type）。这种类型通常用于函数
参数，表示在运行时不出现，但是在进行编译时进行静态检查。这种类型的参数不占据任何
存储空间，也不存在运行时行为，比如，现在设定一个英寸的结构体和一个米的结构体，
要求这2个结构体不能相加，则可以使用phantom虚类型进行解决：
\begin{code-block}{rust}
// 虚类型
use std::marker::PhantomData;
use std::ops::Add;

extern crate slog_scope;
extern crate slog_stdlog;
#[macro_use]
extern crate log;
extern crate logger;

enum Inch {}
enum Mm {}

// 使用虚类型进行定义
struct Length<Unit>(f64, PhantomData<Unit>);

impl<Unit> Add for Length<Unit> {
    type Output = Length<Unit>;

    fn add(self, other: Self) -> Self {
        Length(self.0 + other.0, PhantomData)
    }
}

fn main() {
    let logger = logger::initlogger(false, "", 0);
    let _guard = slog_scope::set_global_logger(logger);
    slog_stdlog::init().unwrap();

    let one_foot: Length<Inch> = Length(12.0, PhantomData);
    let another_foot: Length<Inch> = Length(12.0, PhantomData);
    let one_meter: Length<Mm> = Length(1000.0, PhantomData);
    let another_meter: Length<Mm> = Length(1000.0, PhantomData);

    let two_feet = one_foot + another_foot;
    let two_meters = one_meter + another_meter;

    info!("The feet is {}", two_feet.0);
    info!("The meters is {}", two_meters.0);

    // 由于2者的虚类型不同，编译期间直接提示出错
    let r = one_foot + one_meter;
}
\end{code-block}

迭代器也是常用的数据类型，在之前的介绍当中已经有基本的介绍，在这里，将使用斐波那契
数列来讲述可以无限计算下去的迭代器的实现方式，不管是有限或无限，迭代器都必须实现
Iterator这个Trait：
\begin{code-block}{rust}

// 实现结构体的clone
#[derive(Clone)]
struct Fibonacci {
    current: u64,
    nxt: u64,
}

impl Iterator for Fibonacci {
    type Item = u64;

    fn next(&mut self) -> Option<Self::Item> {
        let tmp = self.current;
        self.current = self.nxt;
        self.nxt = tmp + self.nxt;
        Some(self.nxt)
    }
}

impl Fibonacci {
    fn new() -> Fibonacci {
        Fibonacci { current: 1, nxt: 1 }
    }
}

fn main() {
    let logger = logger::initlogger(false, "", 0);
    let _guard = slog_scope::set_global_logger(logger);
    slog_stdlog::init().unwrap();

    let fib = Fibonacci::new();
    let fib_clone = fib.clone();

    // 忽略数列前10项，然后再取后续的8项
    for item in fib.skip(10).take(8) {
        info!("{}", item);
    }

    for item in fib_clone.skip(20).take(8) {
        info!("{}", item);
    }

}
\end{code-block}


\subsection{条件编译}
C/C++经常使用宏定义实现条件编译，而Rust同样可以。Rust当中，主要有2种方式：通过属性
和通过宏定义：
\begin{code-block}{rust}
// 通过cfg的属性，当目标为linux时，进行编译
#[cfg(target_os = "linux")]
fn are_you_on_linux() {
    println!("You are running linux!")
}

// 通过cfg的属性，当目标不为linux时，进行编译
#[cfg(not(target_os = "linux"))]
fn are_you_on_linux() {
    println!("You are *not* running linux!")
}

fn main() {
    are_you_on_linux();

    println!("Are you sure?");
    // 通过cfg!宏进行判断
    if cfg!(target_os = "linux") {
        println!("Yes. It's definitely linux!");
    } else {
        println!("Yes. It's definitely *not* linux!");
    }
}
\end{code-block}
Target\_os宏为Rust内置，如果想自定义编译条件或者属性，则需要如下进行操作：
\begin{outline}[enumerate]
\1 修改代码
\begin{code-block}{rust}
#[cfg(feature = "debugs")]
fn debugs_print() {
    println!("This is the debugs_print");
}

fn main() {
    if cfg!(feature = "debugs") {
        debugs_print();
    }
    println!("Are you sure?");
}
\end{code-block}

\1 修改cargo工程设置
\begin{code-block}{bash}
echo >> Cargo.toml <<EOF
[features]
debugs = []
EOF
\end{code-block}

\1 使用自定义的debugs宏进行编译
\begin{code-block}{bash}
cargo build --features debugs

# 如果是多项目的管理方式，则需要变更为如下的方式：
# cargo build --bin adclosures --manifest-path adclosures/Cargo.toml --features debugs
\end{code-block}

\end{outline}

\input{rust_part_4}
