\section{高级特征}
Rust设计不仅仅是为了开发应用程序，其设计之初，就是为了解决内存安全的问题，并且可以
广泛用于各种场景，包括C语言的专属领域：操作系统设计。在编写操作系统的过程当中，
C语言使用了很多的高级宏定义以及一些精妙的设计，而Rust同样如此。为了和硬件打交道，
Rust被设计为可以拥有直接操作硬件的能力，这些都是其高级特性的一部分。Rust的高级
特性主要包含下列内容：
\begin{enumerate}
  \item 高级 Trait
  \item 高级函数和闭包
  \item 宏
\end{enumerate}

\subsection{高级Trait}
Trait的语法当中，使用了如下的代码形式：
\begin{code-block}{rust}
impl Iterator for Counter {
    type Item = u32;
    fn next(&mut self) -> Option<Self::Item> {
        ...
    }
}
\end{code-block}
其中，type Item表示关联数据类型，Item表示占位类型，next方法定义表明它返回
Option<Self::Item>类型的值。这个trait的实现者会指定Item的具体类型。
在Trait当中，除了默认方法，方法覆写之外，Rust并不允许创建自定义的运算符，
或者重载任意运算符，只有std::ops当中所列出的运算符和相应的trait可以通过实现
运算符相关的trait来实现重载，比如下面，实现Add trait来实现对+的运算符重载：
\begin{code-block}{rust}
use std::fmt;
use std::ops::{Add, AddAssign};
struct Point {
    x: u8,
    y: u8,
}
// 实现结构体的 c = a + b
impl Add for Point {
    type Output = Point;
    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}
// 实现结构体的 a = a + b;
impl AddAssign for Point {
    fn add_assign(&mut self, other: Point) {
        self.x = self.x + other.x;
        self.y = self.y + other.y;
    }
}
impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "x:{}, y:{}", self.x, self.y)
    }
}
fn main() {
    let a = Point { x: 3, y: 4 };
    let b = Point { x: 5, y: 6 };
    let c = a + b;
    let mut d = Point { x: 100, y: 101 };
    d = d + c;
    println!("{}", d);
}
\end{code-block}

以Add Trait为例，其内部的实现如下：
\begin{code-block}{rust}
#[lang = "add"]
pub trait Add<Rhs = Self> {
    type Output;
    #[must_use]
    fn add(self, rhs: Rhs) -> Self::Output;
}
\end{code-block}
其中，RHS=Self这个语法叫做默认类型参数。RHS是一个泛型类型参数，它用于定义add方法
中的rhs参数。如果实现Add trait时不指定RHS的具体类型，RHS的类型将是默认的Self类型
也就是在实现Add Trait的类型。在上述例子当中，RHS就是Point这个类型。但是，也可以使用
不同的数据类型，比如下面的例子：
\begin{code-block}{rust}
struct Meters(i32);
struct Millimeters(i32);
impl Add<Meters> for Millimeters {
    type Output = Millimeters;
    fn add(self, other: Meters) -> Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
\end{code-block}
定义一个结构体米，和结构体毫米，然后定义毫米与米的加法操作，当结构体毫米与结构体
米进行相加时（注意顺序），将结果转换成毫米结果：
\begin{code-block}{rust}
let meters = Meters(1);
let mill_meters = Millimeters(10);
let mill_meters_other = mill_meters + meters;
\end{code-block}
但是，如果将上述代码的顺序更换如下：
\begin{code-block}{rust}
let mill_meters_other = meters + mill_meters;
\end{code-block}
则会出现如下的错误：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_override_error.png}
  \caption{尝试进行不同类型的加法重载操作}
  \label{fig:rust_override_error}
\end{figure}
修复上述的错误也很简单，增加结构体米的加法操作重载运算符即可：
\begin{code-block}{rust}
struct Meters(i32);
struct Millimeters(i32);
impl Add<Meters> for Millimeters {
    type Output = Millimeters;
    fn add(self, other: Meters) -> Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
impl Add<Millimeters> for Meters {
    type Output = Millimeters;
    fn add(self, other: Millimeters) -> Millimeters {
        Millimeters(self.0 * 1000 + other.0)
    }
}
\end{code-block}
这样，在进行结构体米和结构体毫米之间的加法操作是，无需考虑操作数的顺序。

在之前，也提到了Deref Trait的用法，通常用于进行智能指针的解引用操作，使得智能指针
可以直接当作指定的类型使用。不过Deref Trait不仅仅可以针对智能指针，也可以对自定义
的数据类型添加其他各种操作。比较典型的例子，现在有一个Vec，其中包含的数据类型是
String，如果需要打印这个Vec<String>，则必须使用debug这个宏定义；如果不想使用这个
debug，则必须在Vec<String>上实现Display Trait，但是Display Trait是无法直接作用在
Vec<String>上的，因此我们可以采用一种方式，在一个结构体当中包含匿名的Vec<String>，
然后在这个结构体上实现Display Trait，如下：
\begin{code-block}{rust}
use std::fmt;
use std::ops::{Deref, DerefMut};

struct VecWrapper(Vec<String>);

impl Deref for VecWrapper {
    type Target = Vec<String>;
    fn deref(&self) -> &Vec<String> {
        &self.0
    }
}

impl DerefMut for VecWrapper {
    fn deref_mut(&mut self) -> &mut Vec<String> {
        &mut self.0
    }
}

impl fmt::Display for VecWrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[")?;
        for item in &self.0 {
            write!(f, "{}, ", item)?;
        }
        write!(f, "]")
    }
}

fn main() {
    let mut v = VecWrapper(vec![String::from("hello"), String::from("world")]);
    v.push("zhangjl".to_string());
    for item in &v.0 {
        println!("{}", item);
    }
    println!("{}", v);
}
\end{code-block}
在上述代码当中，使用VecWrapper将Vec<String>进行简单的封装，然后使用Deref Trait
实现对VecWrapper的解引用（包括可变和不可变），将对VecWrapper的解引用操作重定向
到直接访问Vec<String>，这样带来的好处如下：
\begin{enumerate}
  \item 无需针对VecWrapper进行额外的其他操作，即可使用所有Vec<String>的所有方法
  \item 可以如同Vec一样的进行任意的操作
  \item 可以实现VecWrapper的自定义函数/方法，但又不影响原本的Vec操作
\end{enumerate}

另外需要注意，在上述代码当中，我们再次使用了?操作符，由于write本身返回的是一个
Result类型，但是，如果write操作后面添加分号符，表示目前只考虑了正确的模式，忽略
了错误的处理，因此编译器会提示警告。为了消除这个警告，则可以使用?代替Result类型，
同时继续正确和错误分支的处理。

同样的，上述的代码VecWrapper可以做成泛型，如下：
\begin{code-block}{rust}
use std::ops::{Deref, DerefMut};

struct VecWrapper<T>(Vec<T>);

impl<T> Deref for VecWrapper<T> {
    type Target = Vec<T>;
    fn deref(&self) -> &Vec<T> {
        &self.0
    }
}

impl<T> DerefMut for VecWrapper<T> {
    fn deref_mut(&mut self) -> &mut Vec<T> {
        &mut self.0
    }
}
\end{code-block}
上述的代码只是将Vec做了一次封装，可以使用任何的Vec方法，但是，我们将无法对这个
类型实现Display Trait，因为泛型T本身是无法实现Display Trait的。

Trait的另外一个非常重要的用途就是实现继承。涉及到继承实现，不可避免的会遭遇到
函数/方法的重载/覆写，尤其是多重继承的时候。在Rust当中，同样允许不同的Trait有相
同的函数/方法定义，也同样允许一个类型实现多个Trait，比如下面的代码：
\begin{code-block}{rust}
trait Pilot {
    fn fly(&self);
    fn name();
}

trait Wizard {
    fn fly(&self);
    fn name();
}

struct Empty;

impl Pilot for Empty {
    fn fly(&self) {
        println!("This is the implement of Pilot fly method");
    }

    fn name() {
        println!("This is the name method of Pilot implement");
    }
}

impl Wizard for Empty {
    fn fly(&self) {
        println!("This is the implement of Wizard fly method");
    }

    fn name() {
        println!("This is the name method of Wizard implement");
    }
}
\end{code-block}
Trait Pilot和Wizard定义了一个同名的方法，以及一个同名的关联函数（没有self做参数），
然后结构体Empty实现了这2个Trait，但是本身没有任何的方法/函数。但是，在使用的时候，
则必须注意，一定要进行Trait的指定或者转换，否则由于存在同名函数/方法，可能导致
代码的二义性出现，从而导致错误：
\begin{code-block}{rust}
fn main() {
    let empty = Empty {};
    empty.fly();
    Empty::name();
}
\end{code-block}
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_same_name.png}
  \caption{实现包含同名函数/方法的多个Trait}
  \label{fig:rust_same_name}
\end{figure}
解决这种问题的方法主要有2种思路：1是增加Empty结构体自身的同名函数/方法的实现，
但这种思路相当于完全没有利用Trait的任何功能；2是对Empty进行Trait的指定，如下：
\begin{code-block}{rust}
fn main() {
    let empty = Empty {};
    Wizard::fly(&empty);
    Pilot::fly(&empty);
    <Empty as Wizard>::name();
    <Empty as Pilot>::name();
}
\end{code-block}
同样的，如果不同的Trait包含了同名的方法/函数，但是参数和返回值定义不同，在使用的
时候，也需要进行明确的指定：
\begin{code-block}{rust}
trait Pilot {
    fn fly(&self);
    fn name();
}
trait Wizard {
    fn fly(&self, name: &str);
    fn name(age: u8) -> u8;
}
...
fn main() {
    let empty = Empty {};
    Wizard::fly(&empty, "lucifer");
    <Empty as Wizard>::name(64);
}
\end{code-block}

在之前的示例当中，Trait全部是在具体的类型上实现的，但是，Trait本身也可以在智能指针（Box）上实现，比如：
\begin{code-block}{rust}
trait Shape {
    fn area(self: Box<Self>) -> f64;
}
struct Circle {
    radius: f64,
}
impl Shape for Circle {
    fn area(self: Box<Self>) -> f64 {
        PI * self.radius * self.radius
    }
}
fn main() {
    let c = Box::new(Circle { radius: 4f64 });
    info!("{}", c.area());
    // 由于trait实现是在智能指针box上，因此，下面的使用是错误的
    // let c = Circle { radius: 4f64 }
    // c.area()
}
\end{code-block}
甚至在Trait上实现Trait，比如下方：
\begin{code-block}{rust}
trait Shape {
    fn area(&self) -> f64;
}
trait Round {
    fn get_radius(&self) -> f64;
}
struct Circle {
    radius: f64,
}
impl Round for Circle {
    fn get_radius(&self) -> f64 {
        self.radius
    }
}
impl Shape for dyn Round {
    fn area(&self) -> f64 {
        let radius = self.get_radius();
        PI * radius * radius
    }
}
\end{code-block}
Shape是一个Trait，Round同样也是一个Trait，Circle实现了Round，Round实现了Shape，
但是，由于Round本身是一个Trait，拥有不确定性，因此，在实现Shape的时候，需要添加
dyn关键字，提示这个Round不是普通的类型，而是一个Trait。上述代码当中，Circle间接
的实现了Shape，但是，Circle的类型无法直接使用Shape的方法，只能通过智能指针的方
式，将Circle转换成Round的类型，再进行使用，如下：
\begin{code-block}{rust}
fn main() {
    let c: Box<dyn Round> = Box::new(Circle { radius: 4f64 });
    info!("{}", c.area());
}
\end{code-block}
如果再把这个例子改得复杂一些，让Circle和Sphere同时实现Round，则我们可以使用Round
指针计算2个不同类型数据的结果：
\begin{code-block}{rust}
trait Shape {
    fn area(&self) -> f64;
}
trait Round {
    fn calc(&self) -> f64;
}
struct Circle {
    radius: f64,
}
impl Round for Circle {
    fn calc(&self) -> f64 {
        PI * self.radius * self.radius
    }
}
struct Sphere {
    radius: f64,
}
impl Round for Sphere {
    fn calc(&self) -> f64 {
        4f64 * PI * self.radius * self.radius
    }
}
impl Shape for dyn Round {
    fn area(&self) -> f64 {
        self.calc()
    }
}
fn main() {
    let circle: Box<dyn Round> = Box::new(Circle { radius: 4f64 });
    info!("The Circle area is {}", circle.area());
    let sphere: Box<dyn Round> = Box::new(Sphere { radius: 4f64 });
    info!("The Sphere area is {}", sphere.area());
}
\end{code-block}

Trait不仅仅用于实现类型，约束类型，还可以用于为其他现有的数据类型添加方法/函数，
比如：
\begin{code-block}{rust}
impl Round for i32 {
    fn calc(&self) -> f64 {
        *self as f64
    }
}
fn main() {
    let i_struct = 4i32;
    i_struct.calc();
}
\end{code-block}
这种类型的函数/方法，则称之为扩展方法/函数。从上述例子当中，我们似乎可以使用Trait
对任意类型进行函数/方法的扩展，但是，这个是存在前提的：
\begin{itemize}
  \item impl和trait的声明/定义在同一个crate当中
  \item 或者，impl的实现需要和类型的声明在同一个crate当中
\end{itemize}
如果不满足上述条件，则容易出现bug和问题，也会违反Rust的规则。

Rust的Trait支持多种特性，自然也支持继承，但是注意，Rust的结构体和enum数据类型并不
存在继承的概念。Trait的继承方式如下：
\begin{code-block}{rust}
trait Base {}
trait Derived : Base {}
\end{code-block}
当一个结构体实现了上述的Derived这个Trait，则必须同样实现Base这个Trait，否则就会
出现语法错误：
\begin{code-block}{rust}
trait Base {}
trait Derived : Base {}
struct T;
impl Derived for T {}
impl Base for T {}
\end{code-block}

Rust的Trait不仅可以包括函数的定义，同样可以直接定义函数：
\begin{code-block}{rust}
trait Page {
    fn set_page(&self) {
        info!("Page Default: 1");
    }
}
trait PerPage {
    fn set_per_page(&self) {
        info!("Per Page Default: 1");
    }
}
struct Paginate {
    page: u32,
}
impl Page for Paginate {}
impl PerPage for Paginate {}
fn main() {
    let page = Paginate { page: 8 };
    page.set_page();
    page.set_per_page();
    page.set_skip_page();
}
\end{code-block}

甚至于，Trait可以直接给结构体提供更多的组合方法：
\begin{code-block}{rust}
trait PaginateMore: Page + PerPage {
    fn set_skip_page(&self) {
        info!("Skip the page");
    }
}
fn main() {
    ...
    page.set_skip_page();
}
\end{code-block}
结构体根本不用自行实现Trait PaginateMore，就可以直接使用该Trait当中的方法。

Trait不仅仅可以用于接口实现，在Rust当中，更重要的则是类型限定，限定某些数据只能
做某些事情。比如下方的代码：
\begin{code-block}{rust}
...
fn static_dispatch<T>(t: &T) where T: Bar {
    ...
}
fn dynamic_dispatch(t : &Bar) {
    ...
}
\end{code-block}
对于实现了Trait Bar的类型来说，上述2个函数，都可以被调用，但是，从语法上，static\_dispatch
由于使用了where，表示参数必须限定在Trait Bar类型，在编译时就能够确定；而dynamic\_dispatch
则从语法上表示，输入的参数必须是Bar的对象，即Trait Object。运行时，Trait Object会根据虚表
指针从虚表当中查出正确的指针，再进行动态调用，属于在运行时确定。

但是并不是每一个Trait都可以当着Trait Object使用，这个和类型大小是否确定有关系。每一个
Trait的隐藏类型参数Self默认限定为?Sized，?Sized trait包括了所有动态大小类型以及所有
可确定大小的类型。Rust当中大部分类型都是默认可确定大小的，即<T:Sized>。当trait对象
在运行期进行动态分发时，也必须确定大小，否则无法分配内存。只有同时满足下列条件的
trait，才可以当作Trait Object使用：
\begin{itemize}
  \item Trait的Self不能被限定为Sized
  \item Trait当中的所有方法都必须是对象安全的
\end{itemize}

而所谓的对象安全，则必须满足如下的条件\colorblock{之一}：
\begin{itemize}
  \item 当Trait的Self被限定为Sized时，方法受Self:Sized约束
  \item Trait的方法签名必须\colorblock{同时满足以下3点}
  \begin{enumerate}
    \item 不包含任何泛型参数（Self）
    \item 第一个参数必须为Self类型或可解引用为Self类型
    \item Self不能出现在除第一个参数之外的其他地方
  \end{enumerate}
  \item Trait当中不能包含关联常量
\end{itemize}

比如下面的代码，就属于标准的对象安全：
\begin{code-block}{rust}
trait Bar {
    fn bax(self, x: u32);
    fn bay(&self);
    fn baz(&mut self);
}
\end{code-block}
Trait Bar不受Sized限制，Trait的方法没有额外的Self类型参数，没有泛型参数，因此是安全的。
相对应的，不安全的Trait如下：
\begin{code-block}{rust}
// 对象不安全
trait Foo {
    fn bad<T>(&self, x:T);
    fn new() -> Self;
}
// 对象安全
trait Foo {
    fn bad<T>(&self, x: T);
    fn new() -> Self
    where
        Self: Sized;
}
\end{code-block}

当然，Sized约束也可以用于Trait定义当中。比如，自行实现一个类似any的Any Trait。
\begin{code-block}{rust}
use std::ops::Fn;
trait CustomAny {
    fn custom_any<F>(&self, f: F) -> bool
    where
        Self: Sized,
        F: Fn(u32) -> bool;
}
impl CustomAny for Vec<u32> {
    fn custom_any<F>(&self, f: F) -> bool
    where
        Self: Sized,
        F: Fn(u32) -> bool,
    {
        for &x in self {
            if f(x) {
                return true;
            }
        }
        false
    }
}
fn main() {
    let v: Vec<u32> = vec![1, 2, 3];
    info!("{}", v.iter().any(|&x| x == 3));
    info!("{}", v.custom_any(|x| x == 3));
}
\end{code-block}

Trait当中不仅可以包含函数和方法，同样可以包含变量和常量，即所谓的关联变量以及关联
常量。关联常量的使用稍微有些特殊，在Trait当中可以定义关联常量，但是，使用的时候，
却是通过Trait的实现对象来使用这些关联常量的：
\begin{code-block}{rust}
trait Colorize {
    // 定义关联常量
    const FG_RED: &'static str = "31";
    const BG_YELLOW: &'static str = "43";
    fn red(self) -> ColoredString;
    fn on_yellow(self) -> ColoredString;
}
impl Colorize for ColoredString {
    fn red(self) -> ColoredString {
        ColoredString {
            // 使用关联常量，如果是Colorize::FG_RED，则会提示错误
            fg_color: String::from(ColoredString::FG_RED),
            ..self
        }
    }
    fn on_yellow(self) -> ColoredString {
        ColoredString {
            bg_color: String::from(ColoredString::BG_YELLOW),
            ..self
        }
    }
}
\end{code-block}

Trait不仅仅可以实现泛型，泛型也不仅限于Trait和<T>，对于函数/方法，也可以使用在
泛型、生命周期以及Trait当中，比如，显式的指定闭包的生命周期：
\begin{code-block}{rust}
// 将函数作为泛型参数
struct Pick<F> {
    data: (u32, u32),
    func: F,
}
impl<F> Pick<F>
where
    // for<>只能用于标记生命周期
    F: for<'f> Fn(&'f (u32, u32)) -> &'f u32,
{
    fn call(&self) -> &u32 {
        (self.func)(&self.data)
    }
}

fn max(data: &(u32, u32)) -> &u32 {
    if data.0 > data.1 {
        return &data.0;
    }
    &data.1
}
fn main() {
    let pick = Pick {
        data: (32, 34),
        func: max,
    };
    info!("{}", pick.call());
}
\end{code-block}

在之前的trait和泛型示例当中，我们可以看到他们的结合使用，比如如下的代码：
\begin{code-block}{rust}
pub trait Vegetable {
    fn name<'a>(&self) -> &'a str;
}

pub struct Cabege {}
impl Vegetable for Cabege {
    fn name<'a>(&self) -> &'a str {
        stringify!(Cabege)
    }
}

pub struct Apple {}
impl Vegetable for Apple {
    fn name<'a>(&self) -> &'a str {
        stringify!(Apple)
    }
}

pub struct Salad<V: Vegetable> {
    veggies: Vec<V>,
}
\end{code-block}

上述代码是可以正常使用的，不过，当我们尝试如下使用时，会直接出现错误：
\begin{code-block}{rust}
let mut salad = ...
salad.add(Apple {});
salad.add(Cabege {});
salad.show();
\end{code-block}
虽然Cabege和Apple都实现了Vegetable这个trait，但是，由于\codeinline{rust}{Salad<V: Vegetable>}的
存在，导致Salad这个结构体同一时间只能容纳一种具体的实现，即要么是Apple，要么是Cabege。如果需要
同时容纳，则应当如下进行修改：
\begin{code-block}{rust}
pub struct Salad{
    veggies: Vec<Box<dyn Vegetable>>,
}
\end{code-block}

Trait也可以返回具体实现的实例，只是此时需要用到一个特殊的关键字：Self，注意不是小写的self。
\begin{code-block}{rust}
pub trait Spliceable {
    fn clone(&self) -> Self;
    fn splice(&self, other: &Self) -> Self;
}
\end{code-block}

同样的，即使上述Trait同时有多个实现，但是每一个的具体实例所对应的Self都只是自己，
不能映射到其他的实现，即self和other的类型必须完全一致。再来思考这样的问题，代码如下：
\begin{code-block}[escapeinside=~~,mathescape]{rust}
pub trait Spliceable {
    fn clone(&self) -> Self;
    fn splice(&self, other: &Self) -> Self;
}

struct Apple;
struct Cat;
impl Spliceable for Apple{...}
impl Spliceable for Cat{...}

fn main(){
    let apple = Apple();
    let cat = Cat();
    ~\colorbox{WildStrawberry}{apple.splice(cat) \namedlabel{line:error}{\rightpointleft}};~
}
\end{code-block}
问题是，上述代码是否可以正常运行？如果不可以，应该如何修正？很明显是不可以的。
虽然上述的apple和cat都实现了Spliceable，在实例之后，splice当中的Self参数在rust
内部就发生了变化，成为的具体的类型，apple的Self指向了Apple类型，同理，cat的类型
指向了Cat类型。因此，上面标红的代码\colorunderline{\coloref{line:error}}只能接收Apple
类型的数据，所以上述代码无法编译。而改动非常简单：
\begin{code-block}[escapeinside=~~,mathescape]{rust}
pub trait Spliceable {
    fn clone(&self) -> Self;
    ~\colorbox{WildStrawberry}{fn splice(&self, other: &dyn Spliceable) -> Box<dyn Spliceable>}~;
}
\end{code-block}
上述改动当中，other参数不再是Self类型，而是\codeinline{rust}{dyn Spliceable}，这
意味着所有实现的Spliceable都可以作为参数，而这种使用Trait作为参数及返回值的做法
就叫做\colorblock{动态分派}。

现在来分析一段比较复杂的代码，如下：
\begin{code-block}[escapeinside=~~,mathescape]{rust}
#[derive(Clone, Copy, Debug)]
pub struct Complex<T> {
    real: T,
    imaginary: T,
}
impl<T> Complex<T> {
    pub fn new(real: T, imaginary: T) -> Complex<T> {
        Complex {
            real: real,
            imaginary: imaginary,
        }
    }
}
impl~\colorbox{WildStrawberry}{<L, R, O> \ding{202}}~ Add<~\colorbox{WildStrawberry}{Complex<R> \ding{203}}~> for ~\colorbox{WildStrawberry}{Complex<L> \ding{204}}~
where
    ~\colorbox{WildStrawberry}{L: Add<R, Output = O> \ding{205}}~,
{
    type Output = ~\colorbox{WildStrawberry}{Complex<O> \ding{206}}~;
    fn add(self, rhs: Complex<R>) -> Self::Output {
        Complex {
            real: self.real + rhs.real,
            imaginary: self.imaginary + rhs.imaginary,
        }
    }
}
impl<T, O> Neg for Complex<T>
where
    T: Neg<Output = O>,
{
    type Output = Complex<O>;
    fn neg(self) -> Self::Output {
        Complex {
            real: -self.real,
            imaginary: -self.imaginary,
        }
    }
}
\end{code-block}
上述代码当中定义了一个泛型结构体Complex，T为泛型参数，然后又为这个泛型结构体实现了
Add和Neg（即取反操作）这两个Trait。但是，这个泛型结构的Trait实现异常的复杂。以Add
为例，与普通的相比，多出多个泛型参数，并且是前面并没有出现过的，可以简单的分析一下：
Add这个Trait实现的是c=a+b这样的操作，
\begin{itemize}
  \item \ding{202}当中的L表示上述的a，即左操作数，R表示上述的b，即右操作数，而O则表示c，即结果数
  \item \ding{203}与\ding{204}实际上是相同的，只是为了区分左右操作数
  \item \ding{205}则表示左操作数实际就是右操作数，但是，多加了一个限制条件，即+操作的结果必须是\ding{206}
\end{itemize}

但这样的写法对于初学者而言，显然是无法迅速理解的，因此，在新版本的rust当中，上述代码可
以使用如下的方式替换：
\begin{code-block}[escapeinside=~~,mathescape]{rust}
// $\colorbox{WildStrawberry}{impl<T> Add for Complex<T>}$ 这种写法也可以
impl<T> Add<Complex<T>> for Complex<T>
where
    T: Add<Output = T>,
{
    type Output = Complex<T>;
    fn add(self, rhs: Self) -> Self::Output {
        Complex {
            real: self.real + rhs.real,
            imaginary: self.imaginary + rhs.imaginary,
        }
    }
}

impl<T> Neg for Complex<T>
where
    T: Neg<Output = T>,
{
    type Output = Complex<T>;
    fn neg(self) -> Self::Output {
        Complex {
            real: -self.real,
            imaginary: -self.imaginary,
        }
    }
}
\end{code-block}
但是，还是无法如同下方所示代码使用：
\begin{code-block}{rust}
impl<T> Add<Complex<T>> for Complex<T>
// 注意，缺少了where限定子句
{
    type Output = Complex<T>;
    fn add(self, rhs: Self) -> Self::Output {
        Complex {
            real: self.real + rhs.real,
            imaginary: self.imaginary + rhs.imaginary,
        }
    }
}
\end{code-block}
原因很简单：Rust编译器无法区分或者推断左右操作数的类型是否相同或者可操作，会提示
如下的错误：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_add_trait_error_for_t.png}
  \caption{无法区分泛型操作数的错误Trait实现}
  \label{fig:rust_add_trait_error_for_t}
\end{figure}

利用Trait与绑定以及泛型，可以实现函数的重载，比如：
\begin{code-block}{rust}
pub fn ping<A>(address: A)
where
    A: Into<Ipv4Addr>,
{
    ...
}

ping(Ipv4Addr::new(23, 21, 219, 98));
ping([66, 146, 219, 98]);
\end{code-block}
Ping这个函数接收参数address，该参数只需要实现了到Ipv4Addr的转换（即实现了\codeinline{rust}{Into<Ipv4Addr}）即可。
在例子当中，恰好[u8]也实现了这个Trait，因此，可以直接将[u8]当成ip地址参数传递给函数。

\subsection{高级函数和闭包}
Rust的函数和闭包都有很多类似的地方，和C/C++的函数也类似，确切的说，是非常类似于
C/C++当中的函数指针，因此，Rust的函数和闭包，也可以作为函数的参数以及返回值。但是，
函数作为参数和返回值与闭包有些区别，先看使用函数作为参数与返回值，如下：
\begin{code-block}{rust}
fn newmethod() -> fn(u32) -> u32 {
    calc
}

fn fn_as_params(age: u32, f: fn(u32) -> u32) {
    println!("In the fn_as_params: {}", f(age));
}

fn calc(age: u32) -> u32 {
    age * 100
}

fn main() {
    let b = newmethod();
    println!("{}", b(32));

    fn_as_params(32, calc);
}
\end{code-block}
可以看到，函数作为参数和返回值，基本用法和C/C++当中的方式是一致的。但是，使用闭包
的情形有些区别：闭包缺少具体的大小（size）描述，如果直接传递闭包，则会因为编译器
无法知道当前参数的大小而报错，因此，当使用闭包作为参数时，需要如下进行处理：
\begin{code-block}{rust}
// 直接使用闭包
fn hello(age: u32, func: &dyn Fn(u32) -> u32) {
    println!("{}", func(age));
}

// 使用Box智能指针
fn recv(age: u32, func: Box<dyn Fn(u32) -> u32>) {
    println!("{}", func(age));
}

// 使用Fn Trait
fn asparams(age: u32, func: impl Fn(u32) -> u32) -> u32{
    func(age)
}

fn add(start: u32) -> u32 {
    start + 100
}

fn main() {
    let c = |x| x * 10;
    recv(10, Box::new(c));
    hello(8, &c);
    // 2种方式都可以
    asparams(8, &c);
    asparams(8, c);
    // Fn Trait针对函数
    asparams(8, add);
    asparams(8, &add);
}
\end{code-block}
特别提倡使用Fn Trait的方式，因为这种方式，可以处理闭包和闭包的引用，同时，同样可以
处理函数以及函数的引用，相当于是一种比较万能的方式。

同样的，使用闭包作为函数的返回值，也是需要进行额外的特殊处理：
\begin{code-block}{rust}
// 使用Box智能指针
fn newclosur() -> Box<dyn Fn(u32) -> u32> {
    Box::new(|x| x * 100)
}

// 使用Fn Trait
fn return_closur() -> impl Fn(u32) -> u32 {
    |x| x * 120
}

fn main() {
    let a = newclosur();
    println!("{}", a(12));

    let a = return_closur();
    println!("{}", a(18));
}
\end{code-block}
和上述的使用闭包的情形类似，使用Fn Trait的方式，不仅可以使用闭包作为返回值，同样
可以使用函数作为返回值。

\subsection{高级类型}
默认情况下，我们使用的Rust变量都是有类型的，而这些类型，默认情况下都需要书写完整。
如果名称太长，则会导致阅读比较麻烦，因此，Rust提供了别名。注意，Rust的别名与Golang
的别名不一样：Rust的类型别名拥有和原始类型相同的函数和方法，可以进行原始名称和
别名系统的自动转换和其他操作，但是Golang的类型别名和原始类型无法直接进行自动转换
和计算。Rust的别名如下：
\begin{code-block}{rust}
enum VeryVerboseEnumOfThingsToDoWithNumbers {
    Add,
    Subtract,
}
// 定义别名
type Operations = VeryVerboseEnumOfThingsToDoWithNumbers;
fn main() {
    // 直接使用别名
    let x = Operations::Add;
}
\end{code-block}
同样的，别名还可以用于其它场合，比如在impl的代码当中使用Self别名（注意大写）：
\begin{code-block}{rust}
enum VeryVerboseEnumOfThingsToDoWithNumbers {
    Add,
    Subtract,
}
impl VeryVerboseEnumOfThingsToDoWithNumbers {
    fn run(&self, x: i32, y: i32) -> i32 {
        match self {
            // 替换原本的 VeryVerboseEnumOfThingsToDoWithNumbers::Add方式
            Self::Add => x + y,
            Self::Subtract => x - y,
        }
    }
}
\end{code-block}

Enum这种类型在之前的讲解当中，没有看到使用其当作各种类似于C/C++相同的值应用。但是，
实际上，Enum是可以直接使用变量值的方式的，同样的，Enum是可以转换成整数数值的：
\begin{code-block}{rust}
enum Number {
    Zero,
    One,
    Two,
}
enum Color {
    Red = 0xff0000,
    Green = 0x00ff00,
    Blue = 0x0000ff,
}

fn main() {
    println!("zero is {}", Number::Zero as i32);
    println!("one is {}", Number::One as i32);
    println!("roses are #{:06x}", Color::Red as i32);
    println!("violets are #{:06x}", Color::Blue as i32);
}
\end{code-block}

Rust的类型之间是可以相互进行转换的，但是Rust的类型转换必须使用显式的方式，不支持
隐式数据类型转换，数据类型转换必须使用as关键字，并且，转换也会存在数据溢出的情况：
\begin{code-block}{rust}
let deciamal = 65.81_f32;
let interer: u8 = deciamal as u8;
// 无法从浮点数直接转换成char类型
let charter: char = interer as char;
\end{code-block}
当从任何数转换成无符号数据（比如u64，u32，u8），则会在原始数据上进行加/减当前数据
类型的最大值+1，直到最后的数据处于新的无符号数据的有效数据范围内：
\begin{code-block}{rust}
let start = 1000;
let start_nev = -1000;
// 1000 -(255+1) - (255+1) - (255+1)
let res1 = start as u8;
// -1000 + (255+1) + (255+1) + (255+1) + (255 + 1)
let res2 = start_nev as u8
\end{code-block}

但是，当转换的类型不是数值类型，而是复合数据类型，则需要使用From和Into这2个Trait。
一般情况下，只要实现了From Trait，就默认的实现了Into Trait，比如下方代码：
\begin{code-block}{rust}
use std::convert::From;
struct Point {
    x: i32,
    y: i32,
}

// 实现From trait，只能从(i32,i32)到结构体，不能反向
// 同样的，Into也是只能从(i32,i32)到结构体，不能反向
impl From<(i32, i32)> for Point {
    fn from(item: (i32, i32)) -> Self {
        Point {
            x: item.0,
            y: item.1,
        }
    }
}

// 如果想实现从结构体到(i32, i32)的自动转换，则需要实现另外的From
impl From<Point> for (i32, i32) {
    fn from(item: Point) -> Self {
        (item.x, item.y)
    }
}

fn main() {
    // 显式的调用from
    let p1 = Point::from((81, 99));
    println!("{}, {}", p1.x, p1.y);

    // 显式的调用into（隐式实现的Into Trait）
    let p1: Point = (100, 101).into();
    println!("{}, {}", p1.x, p1.y);

    // 从结构体到(i32, i32)的自动转换
    let (x, y): (i32, i32) = p1.into();
    // 但是通常不这么做，而是使用模式匹配进行解决，而且模式匹配更为灵活，如下
    let Point{x:a, y: b} = p1;
}
\end{code-block}

如果复合数据类型进行转换，不能保证一定成功，则需要使用TryFrom以及TryInfo，如下：
\begin{code-block}{rust}
use std::convert::TryFrom;

struct Point {
    x: u8,
    y: u8,
}

impl TryFrom<(u8, u8)> for Point {
    type Error = ();
    fn try_from(value: (u8, u8)) -> Result<Self, Self::Error> {
        if value.0 % 2 == 0 && value.1 % 2 == 0 {
            Ok(Point {
                x: value.0,
                y: value.1,
            })
        } else {
            Err(())
        }
    }
}

fn main() {
    let tup = (32, 63);
    let p = Point::try_from(tup).expect("Invalid Params");
    println!("{}, {}", p.x, p.y);
}
\end{code-block}

作为通用的需求，将复合数据类型进行打印输出，可以采用debug宏，可以实现Display Trait，
还可以实现to\_string方法（ToString Trait）：
\begin{code-block}{rust}
use std::string::ToString;

struct Point {
    x: u8,
    y: u8,
}

impl ToString for Point {
    fn to_string(&self) -> String {
        format!("Point x:{}, y:{}", self.x, self.y)
    }
}

fn main() {
    let p = Point { x: 12, y: 127 };
    println!("{}", p.to_string());
}
\end{code-block}
通常情况下，Display和ToString两者实现其一即可。除了将结构体转换成字符串，也可以将
字符串转换成结构体，而这时就需要使用FromStr这个Trait，只是普通场景下，使用不多：
\begin{code-block}{rust}
use std::num::ParseIntError;
use std::str::FromStr;
use std::string::ToString;

struct Point {
    x: u8,
    y: u8,
}

impl ToString for Point {
    fn to_string(&self) -> String {
        format!("Point x:{}, y:{}", self.x, self.y)
    }
}

impl FromStr for Point {
    type Err = ParseIntError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let coords: Vec<&str> = s
            .trim_matches(|p| p == '(' || p == ')')
            .split(',')
            .collect();

        let x_fromstr = coords[0].replace(" ", "").parse::<u8>()?;
        let y_fromstr = coords[1].replace(" ", "").parse::<u8>()?;

        Ok(Point {
            x: x_fromstr,
            y: y_fromstr,
        })
    }
}

fn main() {
    let p = Point::from_str("(1, 203   )").unwrap();
    println!("{}", p.to_string());
}
\end{code-block}

Rust当中没有goto语句的存在，对于某些特殊的场景，比如多层循环的内部跳出就显得不是
非常友好。因此，Rust也提供了label的机制，允许直接break对应的label，从而快速跳出
循环结构：
\begin{code-block}{rust}
fn main() {
    // 定义循环的标签
    'outer: loop {
        println!("Entered the outer loop");
        'inner: loop {
            println!("Entered the inner loop");

            // 这只是中断内部的循环
            //break;

            // 这会中断外层循环
            break 'outer;
        }
        println!("This point will never be reached");
    }
    println!("Exited the outer loop");
}
\end{code-block}

除了上述这些类型之外，在之前的Trait当中，提到了关联数据类型。关联数据类型通常用在
Trait当中，比如下方的Trait定义：
\begin{code-block}{rust}
trait Container {
    type A;
    type B;
    fn contains(&self, item_a: Self::A, item_b: Self::B) -> bool;
    fn first(&self) -> Self::A;
    fn last(&self) -> Self::B;
    fn val(&self) -> u8;
}

// 如果没有type A和type B的定义，则下面的方法必须写成如下的形式：
// fn difference<A, B, C>(container: &C) -> u8 where
//    C: Container<A, B> { ... }

fn difference<C: Container>(c1: &C, c2: &C) -> u8 {
    c1.val() - c2.val()
}

struct People<'a> {
    name: &'a str,
    age: u8,
}

impl<'a> Container for People<'a> {
    type A = &'a str;
    type B = u8;

    fn contains(&self, item_a: &str, item_b: u8) -> bool {
        self.age == item_b && self.name == item_a
    }
    fn first(&self) -> &'a str {
        self.name
    }
    fn last(&self) -> u8 {
        self.age
    }
    fn val(&self) -> u8 {
        self.age
    }
}

fn main() {
    let p = People {
        name: "zhangjl",
        age: 32,
    };
    println!("{}", p.last());
    println!("{}", p.first());
    println!("{}", p.contains("zhangjl", 32));
}
\end{code-block}

Rust当中，还存在一种非常特殊的类型：虚类型（phantom type）。这种类型通常用于函数
参数，表示在运行时不出现，但是在进行编译时进行静态检查。这种类型的参数不占据任何
存储空间，也不存在运行时行为，比如，现在设定一个英寸的结构体和一个米的结构体，
要求这2个结构体不能相加，则可以使用phantom虚类型进行解决：
\begin{code-block}{rust}
// 虚类型
use std::marker::PhantomData;
use std::ops::Add;

extern crate slog_scope;
extern crate slog_stdlog;
#[macro_use]
extern crate log;
extern crate logger;

enum Inch {}
enum Mm {}

// 使用虚类型进行定义
struct Length<Unit>(f64, PhantomData<Unit>);

impl<Unit> Add for Length<Unit> {
    type Output = Length<Unit>;

    fn add(self, other: Self) -> Self {
        Length(self.0 + other.0, PhantomData)
    }
}

fn main() {
    let logger = logger::initlogger(false, "", 0);
    let _guard = slog_scope::set_global_logger(logger);
    slog_stdlog::init().unwrap();

    let one_foot: Length<Inch> = Length(12.0, PhantomData);
    let another_foot: Length<Inch> = Length(12.0, PhantomData);
    let one_meter: Length<Mm> = Length(1000.0, PhantomData);
    let another_meter: Length<Mm> = Length(1000.0, PhantomData);

    let two_feet = one_foot + another_foot;
    let two_meters = one_meter + another_meter;

    info!("The feet is {}", two_feet.0);
    info!("The meters is {}", two_meters.0);

    // 由于2者的虚类型不同，编译期间直接提示出错
    let r = one_foot + one_meter;
}
\end{code-block}

迭代器也是常用的数据类型，在之前的介绍当中已经有基本的介绍，在这里，将使用斐波那契
数列来讲述可以无限计算下去的迭代器的实现方式，不管是有限或无限，迭代器都必须实现
Iterator这个Trait：
\begin{code-block}{rust}

// 实现结构体的clone
#[derive(Clone)]
struct Fibonacci {
    current: u64,
    nxt: u64,
}

impl Iterator for Fibonacci {
    type Item = u64;

    fn next(&mut self) -> Option<Self::Item> {
        let tmp = self.current;
        self.current = self.nxt;
        self.nxt = tmp + self.nxt;
        Some(self.nxt)
    }
}

impl Fibonacci {
    fn new() -> Fibonacci {
        Fibonacci { current: 1, nxt: 1 }
    }
}

fn main() {
    let logger = logger::initlogger(false, "", 0);
    let _guard = slog_scope::set_global_logger(logger);
    slog_stdlog::init().unwrap();

    let fib = Fibonacci::new();
    let fib_clone = fib.clone();

    // 忽略数列前10项，然后再取后续的8项
    for item in fib.skip(10).take(8) {
        info!("{}", item);
    }

    for item in fib_clone.skip(20).take(8) {
        info!("{}", item);
    }

}
\end{code-block}

\subsection{深入类型}
Rust的类型比较多，char，字符串，整数，浮点数等等。这些基础类型和其他语言比较类似，
但是也包含了自己的特点：比如，char类型占据4个字节，可以存放任何一个unicode字符；
对于ASCII字符，只需要一个字节即可，而一个字节的数据，则可以放在u8类型的数据当中，
因此，对于ASCII类型的字符串/字符数组，可以使用u8类型（即单字节）的数组进行存放，
这样，占用的资源空间会比char的数组小：
\begin{code-block}{rust}
fn main() {
    // 字符串前面的b，表示将对应的字面量存放在u8类型当中
    let s: &[u8] = b"hello";
    info!("{:?}", s);
}
\end{code-block}
同时，Rust支持的整数类型比较广泛，包括8bit，16bit，32bit，64bit，最大可以支持到
128bit；而特殊的isize和usize，则是和平台相关。如果平台是32位的，则isize和usize为
32位，如果是64位，则其数据宽度为64位。

整个Rust的类型当中，只有空类型占据的空间是最小的，都是0。Rust的空类型包括单元类型
（unit，即空元组）以及空结构体：
\begin{code-block}{rust}
// empty是空元组类型
let empty : () = ();
// 空结构体
struct Empty();
\end{code-block}
为了查看类型所占用的空间，可以使用size\_of函数进行查看：
\begin{code-block}{rust}
use std::mem;
struct Empty();
fn main() {
    info!("The Empty struct size is {}", mem::size_of::<Empty>());
    // 查看空元组所占据的内存大小
    info!("The none tuple size is {}", mem::size_of::<()>());
}
\end{code-block}

在Rust当中，浮点类型是非常特殊的数据类型。浮点类型当中，存在一个特殊的值：NaN，
即非法的浮点数值，因为该数据的存在，浮点数不具备全序关系（total order）。所谓的
全序，偏序，Rust当中的定义如下：对于集合X当中的元素a，b，c
\begin{itemize}
  \item 如果a<b，则!(a>b)一定成立；反之，如果a>b，则!(a<b)一定成立，即反对称性
  \item 如果a<b，b<c，则a<c，即传递性
  \item 对于X当中的所有元素，都存在a<b，或者a>b，或者a==b，三者必居其一，即完全性
\end{itemize}
如果X集合只满足前面2条，则称之为偏序；具备上述所有特征，则为全序。由于浮点数的NaN
不满足上述第3条规则，因此，Rust的浮点数属于偏序，而非全序，这回导致一个问题：浮点
数无法排序——非NaN的数值无法与NaN进行比较：
\begin{code-block}{rust}
let nan = std::f32::NAN;
let x = 0.4f32;
// 下列结果全部为false
info!("{}", nan > x);
info!("{}", nan < x);
info!("{}", nan == x);
\end{code-block}
为此，Rust设计了2个Trait表示全序与偏序：\codeinline{rust}{std::cmp::Ord}（全序）以及
\codeinline{rust}{std::cmd::PartialOrd}（偏序）。
PartialOrd这个Trait的partial\_cmp方法返回的是Option<Ordering>，而Ord返回的却是
Ordering。Rust的f32和f64都只实现了PartialOrd，因此，浮点类型无法进行排序，也同样无法
求取最值，如下列代码，则是无法运行的：
\begin{code-block}{rust}
let f_vec = vec![1f32, 2.0, 4.0, 0.0, -1.2];
let bigest_f = f_vec.iter().max();
\end{code-block}
对上诉代码进行编译，会直接提示如下类似的错误：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_float_cmp_error.png}
  \caption{浮点数的最值错误求解}
  \label{fig:rust_float_cmp_error}
\end{figure}
浮点数的排序只能通过partial\_cmp（比较相等关系）进行变换处理，如下方代码：
\label{float_sort}
\begin{code-block}{rust}
let mut f_vec = vec![1f32, 2.0, 4.0, 0.0, -1.2];
// 升序排列
f_vec.sort_by(|first, second| first.partial_cmp(second).unwrap());
// 获取排序后的最后一位
let max = f_vec.last().unwrap();
// 或者如下进行
// let max = f_vec.as_slice().last().unwrap();
// 降序排列
f_vec.sort_by(|first, second| second.partial_cmp(first).unwrap());
\end{code-block}

作为常用数据类型之一，Rust的数组也存在自己的特点，比如同类型的数组之间可以相互赋值：
\begin{code-block}{rust}
let mut array: [u32; 4] = [1, 23, 4, 5];
let array_copy: [u32; 4] = [5, 6, 7, 8];
array = array_copy;
\end{code-block}
支持数组之间的直接比较，只是数组当中的元素本身就可以进行比较才行：
\begin{code-block}{rust}
let array: [u32; 4] = [1, 23, 4, 5];
let array_copy: [u32; 4] = [5, 6, 7, 8];
info!("{:?}", array < array_copy);
\end{code-block}

Rust当中的函数也可以称之为类型的一种，并且，每个函数都有自己单独的类型，函数的类型
是fn。但是，函数的参数列表会影响fn类型的判断和表达，比如下面的例子：
\begin{code-block}{rust}
fn add_tuple(t: (u32, u32)) -> u32 {
    t.0 + t.1
}
fn add_two((x, y): (u32, u32)) -> u32 {
    x + y
}
fn add_normal(x: u32, y: u32) -> u32 {
    x + y
}
\end{code-block}
实际上，add\_tuple和add\_two这2个函数被fn类型识别成为具有相同签名的类型，因此，
在理论上，我们可以使用同一个变量，接收这2个函数的指针：
\begin{code-block}{rust}
fn main() {
    let mut func = add_tuple;
    func = add_two;
    ...
}
\end{code-block}
但是，上述代码却是错误的：虽然签名相同，但是，类型不同：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_func_type.png}
  \caption{相同签名的不同函数类型}
  \label{fig:rust_func_type}
\end{figure}
解决方法，则是将其转换成通用的fn类型：
\begin{code-block}{rust}
fn main() {
    // 显示指定func的类型
    let mut func: fn((u32, u32)) -> u32 = add_tuple;
    // 使用as进行类型的转换
    // let mut func = add_tuple as fn((u32, u32)) -> u32;
    func = add_two;
    ...
}
\end{code-block}
但是，需要注意，add\_normal的功能看上去和前面两个函数的功能相同，但是，他们的
函数签名完全不同，因此，不能将其转换成func。

函数是Rust的头等公民，可以在函数/方法当中定义函数，也可以在函数/方法当中定义结构
体，甚至于定义结构体的方法和实现，以及静态变量，常量等：
\begin{code-block}{rust}
fn func_as_first(x: u32, y: u32) -> (u32, u32) {
    struct Point {
        x: u32,
        y: u32,
    };
    impl Point {
        fn area(&self) -> u32 {
            self.x * self.y
        }
        fn cycle(&self) -> u32 {
            self.x + self.y
        }
    };
    let p = Point { x: x, y: y };
    (p.area(), p.cycle())
}
\end{code-block}

常规的函数类型，都会存在返回值，这些返回值要么是特定的类型，要么就是()，即类似
C/C++的返回void。如果需要什么都不返回，则可以使用!，这种函数称之为发散函数，比如
在处理panic时，有时就需要使用发散函数：
\begin{code-block}{rust}
fn diverges() -> ! {
    panic!("This function never returns!");
}
\end{code-block}
Panic操作会直接导致软件栈展开，因此，后续的操作都不会执行，其返回的就是一个!。
发散函数的最大特点，就是可以被转换成任意一个类型，虽然执行的时候最终还是会崩溃，
如下：
\begin{code-block}{rust}
let x : i32 = diverges();
let y : String = diverges();
\end{code-block}
但是，发散函数最大的作用，在于解决编译器的类型检查：
\begin{code-block}{rust}
let p = if x {
    panic!("error");
} else {
    100
};
\end{code-block}
对于let-if而言，if-else的每个分支都必须是相同的数据类型，通过发散函数的任意类型
转换特性即!与任何类型兼容，所以上述代码才能编译通过。

所有的Rust变量，函数都是类型的一种，都可以通过一定的手段和方式，获得类型的具体信息。
常见的方式有两种，一种是使用错误信息进行推断，一种则是使用标准库函数进行获得。

通过构造一个特殊的函数，然后调用该函数，则可以获得相关的类型信息：
\begin{code-block}{rust}
// 接收一个unit参数
fn type_id(_: ()) {}

fn main() {
    let ref i = 5;
    type_id(i);
}
\end{code-block}

而另外的方式，则是使用标准库函数，不过，这个标准库函数在Rust的默认stable分支当中
是不可用的，需要在nightly分支当中进行编译使用，并且，还需要启用一些特性：
\begin{code-block}{rust}
#![feature(core_intrinsics)]
use std;
// 使用泛型参数进行不同类型的数据接收
fn print_type<T>(_arg: &T) {
    println!(
        "The type name of arg is {}",
        std::intrinsics::type_name::<T>()
    );
}
fn main() {
    let ref x = 5;
    print_type(&x);
}
\end{code-block}
编译上述代码时，则需要对编译指令进行部分的调整：
\codeinline{bash}{cargo +nightly build}，
然后即可实现对参数类型的打印输出。

在Rust当中，与Python不同，函数/方法并不存在默认参数，但是，结构体当中的字段，却可以
有默认值，只是，这个默认值的实现，必须和Default Trait相结合，如下：
\begin{code-block}{rust}
struct ColoredString {
    input: String,
    fg_color: String,
    bg_color: String,
}
impl Default for ColoredString {
    fn default() -> Self {
        ColoredString {
            input: String::default(),
            fg_color: String::default(),
            bg_color: String::default(),
        }
    }
}
fn main() {
    let color = ColoredString::default();
}
\end{code-block}
从上述代码当中可以看出，实际上，并不是Rust的结构体字段赋予了初始值，而是通过一个
名为default的方法，构造一个我们认为应该具有默认值的结构体。在Rust当中，常用的基本
数据类型都实现了Default Trait，可以直接使用对应的default方法。

在使用泛型时，可能由于理解的问题，有的时候会写出有问题的代码，比如如下：
\begin{code-block}{rust}
#[derive(Debug)]
struct MyWriter<W> {
    writer: W,
}

impl<W> MyWriter<W>
where
    W: Write,
{
    fn write(&mut self, buf: &str) -> std::io::Result<()> {
       self.writer.write_all(buf.as_bytes())
    }
}

impl<W> MyWriter<W> {
    fn new() -> Self {
       let stream = TcpStream::connect("127.0.0.1:8080").unwrap();
       let mut writer = BufWriter::new(stream);
       Self { writer }
    }
}
\end{code-block}
乍一看貌似没问题，但实际上，代码在编译阶段就会提示错误：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{rust_type_error.png}
  \caption{类型不匹配-泛型与特化}
  \label{fig:rust_type_error}
\end{figure}
实际上，上述错误多半是由于泛型与泛型特化（实例化）的问题。函数new当中的struct需要的是一个
泛型参数，但实际给出的却是一个特化的struct，因此就出现了上述的错误。修正上述的
错误比较简单，示例如下：
\begin{code-block}{rust}
impl<W> MyWriter<W> {
    fn new(writer:W ) -> Self {
       Self { writer }
    }
}
\end{code-block}

\subsection{条件编译}
C/C++经常使用宏定义实现条件编译，而Rust同样可以。Rust当中，主要有2种方式：通过属性
和通过宏定义：
\begin{code-block}{rust}
// 通过cfg的属性，当目标为linux时，进行编译
#[cfg(target_os = "linux")]
fn are_you_on_linux() {
    println!("You are running linux!")
}

// 通过cfg的属性，当目标不为linux时，进行编译
#[cfg(not(target_os = "linux"))]
fn are_you_on_linux() {
    println!("You are *not* running linux!")
}

fn main() {
    are_you_on_linux();

    println!("Are you sure?");
    // 通过cfg!宏进行判断
    if cfg!(target_os = "linux") {
        println!("Yes. It's definitely linux!");
    } else {
        println!("Yes. It's definitely *not* linux!");
    }
}
\end{code-block}
Target\_os宏为Rust内置，如果想自定义编译条件或者属性，则需要如下进行操作：
\begin{outline}[enumerate]
\1 修改代码
\begin{code-block}{rust}
#[cfg(feature = "debugs")]
fn debugs_print() {
    println!("This is the debugs_print");
}

fn main() {
    if cfg!(feature = "debugs") {
        debugs_print();
    }
    println!("Are you sure?");
}
\end{code-block}

\1 修改cargo工程设置
\begin{code-block}{bash}
echo >> Cargo.toml <<EOF
[features]
debugs = []
EOF
\end{code-block}

\1 使用自定义的debugs宏进行编译
\begin{code-block}{bash}
cargo build --features debugs

# 如果是多项目的管理方式，则需要变更为如下的方式：
# cargo build --bin adclosures --manifest-path adclosures/Cargo.toml --features debugs
\end{code-block}

\end{outline}

\input{rust_part_4}
