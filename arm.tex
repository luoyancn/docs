\chapter{ARM与嵌入式}

\section{ARM Cortex的指令集}
ARM Cortex主要有9种运行模式，每一种运行模式的代码及说明如下图\nameref{fig:arm_arch}所示
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.8]{arm_models.png}
  \caption{ARM的运行模式}
  \label{fig:arm_arch}
\end{figure}

ARM还拥有18个寄存器，每个寄存器长度为32位，R0～R12为通用寄存器，R13为栈指针寄存器（SP），R14为
链接指针寄存器（LP），R15为程序计数器（PC），如下图\nameref{fig:arm_reg}所示
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.6]{arm_reg.png}
  \caption{ARM寄存器分类}
  \label{fig:arm_reg}
\end{figure}

除了这16个寄存器之外，ARM根据模式的不同，还有APSR（应用程序寄存器）/CPSR（当前程序寄存器）和SPSR（已存储程序寄存器）。
R0-R12寄存器，在所有模式（除快速中断模式）当中共享；快速中断（通常与硬件相关，FIQ）独占R8~R12寄存器；PC和CPSR寄存器是所有模式共享；
其余的寄存器基本是每种模式自己独占；用户模式（Usr）下不存在SPSR。

每一条ARM指令都是32位长度的，CPSR指令的格式大致如下图\nameref{fig:arm_command}所示：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{arm_command.png}
  \caption{ARM指令}
  \label{fig:arm_command}
\end{figure}

其中，指令的最后5位（M[4:0]）正好表示本条指令的运行模式；第5位T，表示该指令是否使用是
Thumb指令集，1表示使用；第6位F表示FIQ，表示是否禁用FIQ中断；第7位I表示是否禁用IRQ；
第8位A表示是否禁用异步的abort；第9位E表示操作的字节序，即大小端；10-15位（IT[7:2]）表示
Thumb2指令集当中的if-then条件执行；16-19位（GE[3:0]）表示SIMD指令（单指令多数据）；20-23位
为保留位；24位J表示Jazell状态，是否启用java加速；25-26（IT[1:0]）表示Thumb指令集当中的if-then；
27到31分别为Q（累计饱和），V（ALU操作溢出），C（ALU进位操作），Z（ALU零位），N（ALU负数）。

\section{OpenCV交叉编译}
OpenCV是广泛使用的图形图像处理的C/C++函数库，在嵌入式当中，也使用非常广泛。但是，
嵌入式的计算性能毕竟有限，因此，在嵌入式设备上进行OpenCV的编译是非常耗时的。通常采用
交叉编译的方式进行OpenCV的编译，然后再将其移植到ARM等嵌入式设备上，具体操作如下：
\footnote{来源：\url{http://www.studiow.cf/blog/post/how-to-cross-compile-opencv-for-armbian-with-gtk}

\url{https://gist.github.com/Garrus007/6e43211c7a48b4f8600efc6d86d44703}}。

\begin{outline}[enumerate]

\1 安装交叉编译工具链

交叉编译的环境通常在X86的虚拟机或者服务器上，这样能够保证编译的时间。必须注意的是，
由于OpenCV编译完成之后，大多数是so文件，而so文件属于运行时的文件，因此，交叉编译环境
的ldd必须与嵌入式平台的版本一致，否则即使编译完成，也无法进行运行。比较好的做法是，
保持交叉编译环境的操作系统版本和开发板所运行的操作系统版本一致。
\begin{code-in-enumerate}{bash}
apt-get install gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf \
    pkg-config-arm-linux-gnueabihf -y
\end{code-in-enumerate}

\1 连接嵌入式平台

交叉编译环境上，有很多的类库以及依赖文件，是X86平台上没有或者不匹配的，因此，
我们通过远程连接的方式，将远程的嵌入式平台的操作系统链接到交叉编译环境中。假设
嵌入式平台的ip为172.16.1.155，则操作如下：
\begin{code-in-enumerate}{bash}
sshfs root@172.16.1.155:/ /mnt -o transform_symlinks -o allow_other
\end{code-in-enumerate}

\1 链接嵌入式平台上的开发库以及相关文件

在X86平台上，直接将嵌入式平台上的开发库文件链接到X86本地，方便进行编译开发。
\begin{code-in-enumerate}{bash}
ln -s /mnt/usr/lib/arm-linux-gnueabihf/ /usr/lib/arm-linux-gnueabihf
ln -s /mnt/lib/arm-linux-gnueabihf/ /lib/arm-linux-gnueabihf
ln -s /mnt/usr/share /usr/share/arm-linux-gnueabihf
ln -s /mnt/usr/include/arm-linux-gnueabihf /usr/include/arm-linux-gnueabihf
\end{code-in-enumerate}

注意，由于是通过远程挂载的方式进行交叉编译，因此，需要在嵌入式平台（ARM）上进行
编译所需要的依赖关系的安装。
\begin{code-in-enumerate}{bash}
apt-get install libjpeg-dev libtiff5-dev libjasper-dev libpng12-dev \
    libavcodec-dev libavformat-dev libswscale-dev libv4l-dev \
    libxvidcore-dev libx264-dev libgtk2.0-dev libatlas-base-dev \
    libglib2.0-dev gfortran python2.7-dev python3-dev ffmpeg libgtk-3-dev -y
\end{code-in-enumerate}

回到X86交叉编译环境，执行下面命令，以上面安装的libgtk2.0-dev为例：
\begin{code-in-enumerate}{bash}
arm-linux-gnueabihf-pkg-config --list-all | grep gtk
arm-linux-gnueabihf-pkg-config --libs gtk+-2.0
arm-linux-gnueabihf-pkg-config --cflags gtk+-2.0
\end{code-in-enumerate}
如果出现下面图\nameref{fig:cross_cv}的显示，则说明交叉编译的依赖关系没有问题了，可以进行编译了。
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{cross_cv.png}
  \caption{交叉编译的类库}
  \label{fig:cross_cv}
\end{figure}

如果提示错误，则需要按照下面的操作进行：
\begin{code-in-enumerate}{bash}
export PKG_CONFIG_SYSROOT_DIR=/mnt
export PKG_CONFIG_PATH=/usr/share/arm-linux-gnueabihf/pkgconfig:/mnt/usr/lib/pkgconfig
arm-linux-gnueabihf-pkg-config --libs gtk+-2.0
arm-linux-gnueabihf-pkg-config --cflags gtk+-2.0
\end{code-in-enumerate}

\1 下载代码

需要下载OpenCV和OpenCV-Contrib的代码，进行完整编译和模块编译。
\begin{code-in-enumerate}{bash}
git clone https://github.com/opencv/opencv.git
cd opencv && git checkout 3.2.0 && cd
git clone https://github.com/opencv/opencv_contrib.git
cd opencv_contrib && git checkout 3.2.0 && cd ../opencv
\end{code-in-enumerate}

\1 编译代码

首先需要准备编译目录，假设命名为build\_arm
\begin{code-in-enumerate}{bash}
cd opencv
mkdir build_arm
cd build_arm
\end{code-in-enumerate}

修改编译链工具文件
\begin{code-in-enumerate}{bash}
vi ../platforms/linux/arm-gnueabi.toolchain.cmake
\end{code-in-enumerate}

在该文件开始的地方，加入以下的代码：
\begin{code-in-enumerate}{bash}
set(ENV{PKG_CONFIG_PATH} "/usr/share/arm-linux-gnueabihf/pkgconfig:/mnt/usr/lib/pkgconfig")
set(ENV{PKG_CONFIG_SYSROOT_DIR} "/mnt")
set(PKG_CONFIG_EXECUTABLE "/usr/bin/arm-linux-gnueabihf-pkg-config")
set(ENV{LD_LIBRARY_PATH} "/mnt/usr/lib")
set(ENV{C_INCLUDE_PATH} "/mnt/usr/include")
set(ENV{CPLUS_INCLUDE_PATH} "/mnt/usr/include")
\end{code-in-enumerate}

OpenCV3.2.0版本的分支还存在一个小小的bug，需要手动修复一下，否则会影响交叉编译。
修改opencv\_contrib/modules/freetype/CMakeLists.txt，将第22行修改为如下内容：
\footnote{来源：\url{https://github.com/opencv/opencv_contrib/pull/926}}。
\begin{code-in-enumerate}{bash}
ocv_define_module(freetype opencv_core opencv_imgproc PRIVATE_REQUIRED ${FREETYPE_LIBRARIES} ${HARFBUZZ_LIBRARIES} WRAP python)
\end{code-in-enumerate}

然后生成makefile文件：
\begin{code-in-enumerate}{bash}
cmake -DENABLE_NEON=ON -DENABLE_VFPV3=ON  -D WITH_V4L=ON  -D WITH_GTK=ON \
    -D CMAKE_BUILD_TYPE=Release -D BUILD_TESTS=OFF \
    -D CMAKE_TOOLCHAIN_FILE=/root/opencv/platforms/linux/arm-gnueabi.toolchain.cmake \
    /root/opencv/ -D OPENCV_EXTRA_MODULES_PATH=/root/opencv_contrib/modules ..
\end{code-in-enumerate}

如果cmake的信息当中，提示GUI没有支持，如图\nameref{fig:cross_gui}所示，一定要在嵌入式平台端安装GTK或者QT等图形化开发
的lib库，否则，OpenCV在运行时，将无法显示图像。
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.3]{cross_gui.png}
  \caption{图形化支持}
  \label{fig:cross_gui}
\end{figure}

随后进行OpenCV的编译：
\begin{code-in-enumerate}{bash}
make
make install
\end{code-in-enumerate}
如果一切顺利，将在opencv/build\_arm/install生成我们所需要的OpenCV文件，包括头文件，
so文件和其他的文件，大致如下图\nameref{fig:cross_finish}所示：
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{cross_finish.png}
  \caption{交叉编译的结果}
  \label{fig:cross_finish}
\end{figure}

然后将install下的所有文件，放到嵌入式系统的/usr/local当中对应的目录即可，注意，需要
修改install/lib/pkgconfig/opencv.pc文件，将prefix修改，修改为如下：
\begin{code-in-enumerate}{bash}
prefix=/usr/local
\end{code-in-enumerate}

断开交叉编译环境与嵌入式系统的文件链接：
\begin{code-in-enumerate}{bash}
fusermount -u /mnt
\end{code-in-enumerate}

完成上述操作之后，在嵌入式系统当中，执行指令：
\begin{code-in-enumerate}{bash}
ldconfig -v
\end{code-in-enumerate}

如果输出结果类似下面图\nameref{fig:cross_transplant}所示，则说明编译OpenCV移植成功，则ARM的嵌入式系统当中，可以正常使用。
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{cross_transplant.png}
  \caption{移植到嵌入式系统}
  \label{fig:cross_transplant}
\end{figure}

\1 测试功能

移植之后，需要调用OpenCV的函数，才知道最终的结果。为此，我们编写一个简易的OpenCV应用程序，
只要能够将图片显示出来，就基本表明OpenCV的移植是没有问题的了。

代码的功能比较简单，就是读取一张图片，并显示出来，具体的代码如下：
\begin{code-in-enumerate}{cpp}
#include <opencv2/opencv.hpp>

using namespace cv;

int main(void)
{
        Mat img, gray;
        img = imread("lena.bmp", CV_LOAD_IMAGE_COLOR);
        imwrite("show", img);
        waitKey(0);
        destroyAllWindows();
        return 0;
}
\end{code-in-enumerate}

使用编译指令进行编译：
\begin{code-in-enumerate}{bash}
g++ -std=c++11 -Wall `pkg-config --cflags opencv` \
    -o canny canny.cc  `pkg-config --libs opencv` -lpthread
\end{code-in-enumerate}

也可以使用Makefile：
\begin{code-in-enumerate}{make}
TARGET = canny

CFLAGS = -Ofast -Wall -std=c++11 `pkg-config --cflags opencv`
LDFLAGS = -Ofast -Wall -std=c++11 `pkg-config --libs opencv`
CC = g++

all: $(TARGET)

$(TARGET): $(TARGET).o
        $(CC) $(LDFLAGS) -o $@ $^ `pkg-config --libs opencv` -lpthread

%.o: %.cpp
        $(CC) $(CFLAGS) -c -o $@ $<

clean:
        rm -f $(TARGET) *.a *.o *~
\end{code-in-enumerate}

执行该代码，如果该代码正常运行，且将图片正常显示，则表明OpenCV的移植没有任何
问题了，整个移植过程成功了。

\end{outline}

\section{构建ARM的rootfs}
首先是生成一个rootfs。
\begin{code-block}{bash}
apt-get install qemu-user-static
mkdir -p /opt/armhf-16.04-glibc-2.23
cd /opt/armhf-16.04-glibc-2.23
wget http://cdimage.ubuntu.com/ubuntu-base/releases/16.04/release/ubuntu-base-16.04.6-base-armhf.tar.gz
tar -zxvf ubuntu-base-16.04.6-base-armhf.tar.gz && rm -rf ubuntu-base-16.04.6-base-armhf.tar.gz
cp /usr/bin/qemu-arm-static usr/bin
cp /etc/resolv.conf etc/resolv.conf
\end{code-block}

创建一个脚本，用于进入rootfs环境，脚本内容大致如下：
\begin{code-block}{bash}
#!/bin/bash
function mnt() {
    echo "MOUNTING"
    sudo mount -t proc /proc ${2}proc
    sudo mount -t sysfs /sys ${2}sys
    sudo mount -o bind /dev ${2}dev
    sudo mount -o bind /dev/pts ${2}dev/pts
    sudo chroot ${2} /bin/bash --login
}

function umnt() {
    echo "UNMOUNTING"
    sudo umount ${2}proc
    sudo umount ${2}sys
    sudo umount ${2}dev/pts
    sudo umount ${2}dev
}

if [ "$1" == "-m" ] && [ -n "$2" ] ;
then
    mnt $1 $2
elif [ "$1" == "-u" ] && [ -n "$2" ];
then
    umnt $1 $2
else
    echo ""
    echo "Either 1'st, 2'nd or both parameters were missing"
    echo ""
    echo "1'st parameter can be one of these: -m(mount) OR -u(umount)"
    echo "2'nd parameter is the full path of rootfs directory(with trailing '/')"
    echo ""
    echo "For example: ch-mount -m /media/sdcard/"
    echo ""
    echo 1st parameter : ${1}
    echo 2nd parameter : ${2}
fi
\end{code-block}

执行该脚本，进入rootfs环境：
\begin{code-block}{bash}
./ch-mount -m /opt/armhf-16.04-glibc-2.23
\end{code-block}

升级rootfs，并安装必要的软件包：
\begin{code-block}{bash}
apt-get update -y && apt-get upgrade -y
apt-get install vim pkg-config git sudo ssh net-tools ethtool wireless-tools \
    lxde xfce4-power-manager xinit xorg network-manager iputils-ping rsyslog \
    lightdm-gtk-greeter alsa-utils lightdm bash-completion lxtask htop \
    python-gobject-2 python-gtk2 synaptic libjpeg-dev libtiff5-dev libjasper-dev \
    libpng12-dev libavcodec-dev libavformat-dev libswscale-dev libv4l-dev \
    libxvidcore-dev libx264-dev libgtk2.0-dev libatlas-base-dev libglib2.0-dev \
    gfortran libgtk-3-dev gcc cmake ifupdown qt5-default -y
\end{code-block}

添加必要的服务：
\begin{code-block}{bash}
ln -s /lib/systemd/system/serial-getty\@.service \
    /etc/systemd/system/getty.target.wants/serial-getty@ttyS0.service
echo "auto eth0" > /etc/network/interfaces.d/eth0
echo "iface eth0 inet dhcp" >> /etc/network/interfaces.d/eth0
echo "127.0.0.1    localhost.localdomain localhost" > /etc/hosts
echo "127.0.0.1    armhf" >> /etc/hosts
\end{code-block}

修改登录选项：
\begin{code-block}{bash}
cd /usr/share/lightdm/lightdm.conf.d/
# 在所有文件当中添加下面一行：
# greeter-show-manual-login=true
\end{code-block}

退出rootfs环境：
\begin{code-block}{bash}
exit
/opt/ch-mount -u /opt/armhf-16.04-glibc-2.23
\end{code-block}


基本到此处，整个rootfs已经定制完成。当然，还可以根据需要，添加用户，修改用户密码等。

\section{利用rootfs编译ARM的软件}
既然可以构建一个ARM的rootfs，这个rootfs当中，所有的类库都是armhf架构的，那是否可以
直接在rootfs当中编译ARM或者运行的软件？答案是肯定的。以编译ARM的OpenCV为例。

首先是进入ARM的rootfs，然后安装OpenCV相关的编译依赖包。退出rootfs，在X86的主机上，
下载OpenCV和OpenCV-Contribe的代码，统一放到/opt/opencv下，然后挂载到rootfs环境：
\begin{code-block}{bash}
bindfs -u root -g root -p +rw /opt/opencv/ /opt/arm-16.04-glibc-2.23/mnt
\end{code-block}

然后再次进入rootfs，按照前面所述，修改Opencv-Contrib的代码。注意，由于我们是在rootfs
下进行编译，该环境中的软件架构已经是ARM的了，因此，无需修改OpenCV的Cmake文件。紧接着开始进行
编译安装：
\begin{code-block}{bash}
cmake -DENABLE_NEON=ON -DENABLE_VFPV3=ON  -D WITH_V4L=ON  \
    -D WITH_GTK=ON -D CMAKE_BUILD_TYPE=Release -D BUILD_TESTS=OFF  \
    /mnt/opencv -D OPENCV_EXTRA_MODULES_PATH=/mnt/opencv_contrib/modules ..
make
make install
\end{code-block}

如果一切正常，在rootfs的/usr/local下，将生成相关的OpenCV文件。余下的操作和交叉编译OpenCV
的操作类似。

最后退出rootfs，并卸载相关的目录：
\begin{code-block}{bash}
umount /opt/arm-16.04-glibc-2.23/mnt
\end{code-block}

注意，该种编译方式的效率其实是比较低的，因此，大多数情况下，除非条件不允许，一般不推荐
使用rootfs的方式进行交叉编译。但是，也可以换一个思路：使用rootfs的文件，替换远程链接的嵌入式系统。
