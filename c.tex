\chapter{C}

\section{通用交换函数}
通用的交换函数（非字符串）
\begin{code-block}{c}
#include <stdlib.h>
#include <string.h>
void swap_object(void * first, void * last, size_t size)
{
    void * tmp = malloc(size);
    memcpy(tmp, first, size);
    memcpy(first, last, size);
    memcpy(last, tmp, size);
    free(tmp);
}
\end{code-block}

\section{柔性数组}
C语言的数据和python的不一样，是一个定长的，也就是说，需要预先设定好长度。如果需要
使用变长数组，则需要使用指针。通过指针的方式，一个一个的分配。但是，这种方式，不利于
计算数组长度，当需要使用数据长度时，就会出现问题。柔性数组则不一样，可以当成变长
数据使用，同时，还可以确定长度。

柔性数据的定义如下
\begin{code-block}{c}
typedef struct _soft_array * array_ptr;
typedef struct _soft_array{
    size_t lenth;
    int members[1];
}soft_array;
\end{code-block}

柔性数组一般由2部分组成，第一个表示数组长度，第二个表示数据的元素。但是，由于
各个c/c++编译器的不一致，第二个参数，一定要是一个数组，并且，最好这个数组的长度
为1。在gcc当中，这个members的长度可以为0，但在clang/virsual c++当中，则可能报错。
统一设置为1，则不会出现这个问题。

柔性数组的使用
\begin{code-block}{c}
array_ptr init_soft_array(size_t lenth){
    array_ptr arrays = NULL;
    if(NULL == (arrays = malloc(
        offsetof(soft_array, members) + sizeof(int) * lenth))){
        printf("Cannot allocate more memory\n");
        return NULL;
    }
    arrays->lenth = lenth;
    for(size_t index = 0; index < lenth; index++){
        arrays->members[index] = index;
    }
    return arrays;
}
\end{code-block}

\section{指向指针的指针}
指向指针的指针，通常用在需要改变指针的地方。常见的操作，就是使用指向指针的指针
来删除单链表。
\begin{code-block}{c}
void delete_link(nodeptr * header, nodeptr delete_node) {
    nodeptr * current = header;
    nodeptr entry = NULL;
    while(*current) {
        entry = *current;
        if(entry == delete_node) {
            *current = entry -> next;
            free(delete_node);
            delete_node= NULL;
            return;
        } else {
            current = &(entry->next);
        }
    }
}
\end{code-block}

\section{二叉树的简单实现}
通常的，二叉树都是有序的二叉树，因此，插入时，一般都应当对其进行排序操作。
\begin{code-block}{c}
typedef struct _tnode * tree;
typedef void (*visit_func)(tree * root);

typedef struct _tnode{
    tree leftchild;
    tree rightchild;
    int value;
}tnode;

void insert_tree(tree *root, int value){
    if(NULL == *root){
        *root = MALLOC(1, tnode);
        if(NULL == *root){
            printf("Cannot allocate more memory for tree\n");
            return;
        }
        (*root)->value = value;
        (*root)->leftchild = NULL;
        (*root)->rightchild = NULL;
        return;
    }
    if((*root)->value > value){
        insert_tree(&((*root)->leftchild), value);
    }else{
        insert_tree(&((*root)->rightchild), value);
    }
}
\end{code-block}

对于二叉树而言，最重要的操作莫过于遍历。所有的二叉树操作都是基于遍历进行的。
二叉树的遍历操作通常有3种：前序，中序和后序。其中，最重要的，就是后序遍历。

\begin{code-block}{c}
// 前序遍历
void visit_tree_root_first(tree root, visit_func visit){
    if(NULL == root){
        return;
    }
    visit(&root);
    visit_tree_root_first(root->leftchild, visit);
    visit_tree_root_first(root->rightchild, visit);
}

// 中序遍历
void visit_tree_root_second(tree root, visit_func visit){
    if(NULL == root){
        return;
    }
    visit_tree_root_second(root->leftchild, visit);
    visit(&root);
    visit_tree_root_second(root->rightchild, visit);
}

// 后续遍历
void visit_tree_root_last(tree *root, visit_func visit){
    if(NULL == *root){
        return;
    }
    visit_tree_root_last(&((*root)->leftchild), visit);
    visit_tree_root_last(&((*root)->rightchild), visit);
    visit(root);
}
\end{code-block}

二叉树其他的操作，基本上也是根据遍历操作来实现的。比如，一颗二叉树的销毁。
\begin{code-block}{c}
static void _destroy_tree(tree * root){
    (*root)->leftchild = NULL;
    (*root)->rightchild = NULL;
    free(*root);
    *root = NULL;
}

void destroy_tree(tree *root){
    visit_func visit = _destroy_tree;
    visit_tree_root_last(root, visit);
}
\end{code-block}

\section{宏定义的高级使用}
\begin{outline}[enumerate]

\1 使用typeof创建范型宏
\begin{code-in-enumerate}{c}
#define MIN(x, y) ({                \
    typeof(x) _min1 = (x);          \
    typeof(y) _min2 = (y);          \
    (void) (&_min1 == &_min2);      \
    _min1 < _min2 ? _min1 : _min2; })
\end{code-in-enumerate}
\par\parshape0 \linewidth\textwidth
\setlength{\parindent}{2em}
但是，如果在编译的时候，使用了-std和-ansi参数，则上面的宏会失效。需要对他做部分的修改。
\begin{code-in-enumerate}{c}
#define MIN(x, y) ({                    \
    __typeof__(x) _min1 = (x);          \
    __typeof__(y) _min2 = (y);          \
    (void) (&_min1 == &_min2);          \
    _min1 < _min2 ? _min1 : _min2; })
\end{code-in-enumerate}
\par\parshape0 \linewidth\textwidth
\setlength{\parindent}{2em}
另外，使用-std和-ansi参数的时候，typeof需要替换为\_\_typeof\_\_, asm需要替换为
\_\_asm\_\_，inline也需要替换为\_\_inline\_\_。

\1 定义通用的错误处理
\begin{code-in-enumerate}{c}
#define errout(...) fprintf(stderr, "File %s Function %s Line %d ", \
        __FILE__, __FUNCTION__, __LINE__);                          \
        fprintf(stderr, ##__VA_ARGS__)
int main(int argc, char * argv[])
{
    errout("swap_object function %d\n", 123);
    errout("swap_object function\n");
    return 0;
}
\end{code-in-enumerate}

\1 使用\#\#连接不同的标识符
\begin{code-in-enumerate}{c}
#define appendidentify(first, last) first##last
int main(int argc, char * argv[])
{
    char * first = "lucifer";
    char * last = "garuda";
    char * firstlast = "let`s go";
    printf("%s\n", appendidentify(first, last));
    // 实际上相当与 printf("%s\n", firstlast);
    return 0;
}
\end{code-in-enumerate}

\1 使用宏定义修改函数入口
\begin{code-in-enumerate}{c}
#ifdef CONFIG_SDL
int qemu_main(int argc, char **argv, char **envp);

int main(int argc, char **argv)
{
    printf("hello main with 2 params\n");
    return qemu_main(argc, argv, NULL);
}
#undef main
#define main qemu_main
#endif

int main(int argc, char **argv, char **envp)
{
    printf("main with envp\n");
    return 0;
}
\end{code-in-enumerate}
\par\parshape0 \linewidth\textwidth
\setlength{\parindent}{2em}
由于main方法可以接收多个参数，因此上述代码是正确合法的。现在简单的分析一下。
分析的手法是直接使用gcc -E参数来观察预处理的结果。

\setlength{\parindent}{2em}
不添加CONFIG\_SDL宏，其结果是：
\begin{code-in-enumerate}{bash}
gcc -E test.c
int main(int argc, char **argv, char **envp)
{
    printf("main with envp\n");
    return 0;
}
\end{code-in-enumerate}
\par\parshape0 \linewidth\textwidth
\setlength{\parindent}{2em}
添加CONFIG\_SDL宏，其结果是：
\begin{code-in-enumerate}{bash}
gcc -E -D CONFIG_SDL test.c
int qemu_main(int argc, char **argv, char **envp);
int main(int argc, char **argv)
{
    printf("hello main with 2 params\n");
    return qemu_main(argc, argv, ((void *)0));
}

int qemu_main(int argc, char **argv, char **envp)
{
    printf("main with envp\n");
    return 0;
}
\end{code-in-enumerate}
\par\parshape0 \linewidth\textwidth
\setlength{\parindent}{2em}
从代码中可以看到，实际上，整个处理过程中通过undefine main和define main qemu\_main
这2条语句，就直接修改了整个操作的入口。实际上，这个代码的核心，就是将函数名当作
了一个宏定义，通过简单的名称替换，达到更改程序入口的目的。以上代码的用法，在qemu的
源码vl.c代码当中。
\end{outline}

\section{匿名结构体}
在定义结构体时，可以嵌入一个另外的结构体
\begin{code-block}{c}
typedef struct _user {
    char * name;
    uint8_t age;
    struct {
        char * child_name;
        uint8_t child_age;
    };
}user_struct;

int main(int argc, char * argv[])
{
    user user_ptra = malloc(sizeof(user_struct));
    user_ptra -> age = 20;
    user_ptra -> name = "zhangjl";
    user_ptra -> child_name = "zhangzz";
    user_ptra -> child_age = 18;
    printf("%s\t%d ==> %s\t%d\n", user_ptra -> name, user_ptra -> age,
           user_ptra -> child_name, user_ptra -> child_age);
    return 0;
}
\end{code-block}

\section{定义函数别名}
在gcc当中提供了一系列的扩展功能，包含了定义方法的别名。函数的别名可以是强引用，也可以是弱引用。
\begin{code-block}{c}
void __swap_object(void * first, void * last, size_t size)
{
    void * tmp = malloc(size);
    memcpy(tmp, first, size);
    memcpy(first, last, size);
    memcpy(last, tmp, size);
    free(tmp);
}

// 弱引用别名
void swap_weak(void * first, void *last, size_t size)
        __attribute__ ((weak, alias("__swap_object")));
// 强引用别名
void swap_strone(void * first, void *last, size_t size)
        __attribute__ ((alias("__swap_object")));
\end{code-block}

\section{标记函数被废弃}
在gcc也支持标记函数为废弃，来警示相关人员不要使用这样的函数。
\begin{code-block}{c}
void print_hello() __attribute__ ((deprecated));
void print_hello()
{
    printf("hello\n");
}
\end{code-block}

通过以上的方式进行标记时候，在调用printf\_hello这个方法的时候，编译过程中会提示
如下的信息：
\begin{code-block}{bash}
test.c:74:5: 警告：‘print_hello’ is deprecated [-Wdeprecated-declarations]
     print_hello();
     ^~~~~~~~~~~
test.c:46:6: 附注：在此声明
 void print_hello()
\end{code-block}

\section{特殊的gcc扩展}
有的时候，我们可能需要在执行main方法之前执行一些动作，在执行完main方法之后，再
进行一些扫尾的动作。Gcc提供了这样的支持。
\begin{code-block}{c}
// 进入main方法之前就执行该方法
void hello() __attribute__ ((constructor));
void hello()
{
    printf("hello\n");
}

// 退出main方法之后，执行该方法
void bye() __attribute__ ((destructor));
void bye()
{
    printf("bye\n");
}

int main(int argc, char * argv[])
{
    return 0;
}
\end{code-block}

以上代码编译执行之后，其输出为：
\begin{code-block}{bash}
helllo
bye
\end{code-block}
