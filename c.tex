\chapter{C}

\section{通用交换函数}
通用的交换函数（非字符串）
\begin{code-block}{c}
#include <stdlib.h>
#include <string.h>
void swap_object(void * first, void * last, size_t size)
{
    void * tmp = malloc(size);
    memcpy(tmp, first, size);
    memcpy(first, last, size);
    memcpy(last, tmp, size);
    free(tmp);
}
\end{code-block}

\section{柔性数组}
C语言的数据和python的不一样，是一个定长的，也就是说，需要预先设定好长度。如果需要
使用变长数组，则需要使用指针。通过指针的方式，一个一个的分配。但是，这种方式，不利于
计算数组长度，当需要使用数据长度时，就会出现问题。柔性数组则不一样，可以当成变长
数据使用，同时，还可以确定长度。

柔性数据的定义如下
\begin{code-block}{c}
typedef struct _soft_array * array_ptr;
typedef struct _soft_array{
    size_t lenth;
    int members[1];
}soft_array;
\end{code-block}

柔性数组一般由2部分组成，第一个表示数组长度，第二个表示数据的元素。但是，由于
各个c/c++编译器的不一致，第二个参数，一定要是一个数组，并且，最好这个数组的长度
为1。在gcc当中，这个members的长度可以为0，但在clang/virsual c++当中，则可能报错。
统一设置为1，则不会出现这个问题。

柔性数组的使用
\begin{code-block}{c}
array_ptr init_soft_array(size_t lenth){
    array_ptr arrays = NULL;
    if(NULL == (arrays = malloc(
        offsetof(soft_array, members) + sizeof(int) * lenth))){
        printf("Cannot allocate more memory\n");
        return NULL;
    }
    arrays->lenth = lenth;
    for(size_t index = 0; index < lenth; index++){
        arrays->members[index] = index;
    }
    return arrays;
}
\end{code-block}

\section{指向指针的指针}
指向指针的指针，通常用在需要改变指针的地方。常见的操作，就是使用指向指针的指针
来删除单链表。
\begin{code-block}{c}
void delete_link(nodeptr * header, nodeptr delete_node) {
    nodeptr * current = header;
    nodeptr entry = NULL;
    while(*current) {
        entry = *current;
        if(entry == delete_node) {
            *current = entry -> next;
            free(delete_node);
            delete_node= NULL;
            return;
        } else {
            current = &(entry->next);
        }
    }
}
\end{code-block}

\section{二叉树的简单实现}
通常的，二叉树都是有序的二叉树，因此，插入时，一般都应当对其进行排序操作。
\begin{code-block}{c}
typedef struct _tnode * tree;
typedef void (*visit_func)(tree * root);

typedef struct _tnode{
    tree leftchild;
    tree rightchild;
    int value;
}tnode;

void insert_tree(tree *root, int value){
    if(NULL == *root){
        *root = MALLOC(1, tnode);
        if(NULL == *root){
            printf("Cannot allocate more memory for tree\n");
            return;
        }
        (*root)->value = value;
        (*root)->leftchild = NULL;
        (*root)->rightchild = NULL;
        return;
    }
    if((*root)->value > value){
        insert_tree(&((*root)->leftchild), value);
    }else{
        insert_tree(&((*root)->rightchild), value);
    }
}
\end{code-block}

对于二叉树而言，最重要的操作莫过于遍历。所有的二叉树操作都是基于遍历进行的。
二叉树的遍历操作通常有3种：前序，中序和后序。其中，最重要的，就是后序遍历。

\begin{code-block}{c}
// 前序遍历
void visit_tree_root_first(tree root, visit_func visit){
    if(NULL == root){
        return;
    }
    visit(&root);
    visit_tree_root_first(root->leftchild, visit);
    visit_tree_root_first(root->rightchild, visit);
}

// 中序遍历
void visit_tree_root_second(tree root, visit_func visit){
    if(NULL == root){
        return;
    }
    visit_tree_root_second(root->leftchild, visit);
    visit(&root);
    visit_tree_root_second(root->rightchild, visit);
}

// 后续遍历
void visit_tree_root_last(tree *root, visit_func visit){
    if(NULL == *root){
        return;
    }
    visit_tree_root_last(&((*root)->leftchild), visit);
    visit_tree_root_last(&((*root)->rightchild), visit);
    visit(root);
}
\end{code-block}

二叉树其他的操作，基本上也是根据遍历操作来实现的。比如，一颗二叉树的销毁。
\begin{code-block}{c}
static void _destroy_tree(tree * root){
    (*root)->leftchild = NULL;
    (*root)->rightchild = NULL;
    free(*root);
    *root = NULL;
}

void destroy_tree(tree *root){
    visit_func visit = _destroy_tree;
    visit_tree_root_last(root, visit);
}
\end{code-block}

\section{宏定义的高级使用}
\begin{outline}[enumerate]

\1 使用typeof创建范型宏
\begin{code-in-enumerate}{c}
#define MIN(x, y) ({                \
    typeof(x) _min1 = (x);          \
    typeof(y) _min2 = (y);          \
    (void) (&_min1 == &_min2);      \
    _min1 < _min2 ? _min1 : _min2; })
\end{code-in-enumerate}
但是，如果在编译的时候，使用了-std和-ansi参数，则上面的宏会失效。需要对他做部分的修改。
\begin{code-in-enumerate}{c}
#define MIN(x, y) ({                    \
    __typeof__(x) _min1 = (x);          \
    __typeof__(y) _min2 = (y);          \
    (void) (&_min1 == &_min2);          \
    _min1 < _min2 ? _min1 : _min2; })
\end{code-in-enumerate}
另外，使用-std和-ansi参数的时候，typeof需要替换为\_\_typeof\_\_, asm需要替换为
\_\_asm\_\_，inline也需要替换为\_\_inline\_\_。

\1 定义通用的错误处理
\begin{code-in-enumerate}{c}
#define errout(...) fprintf(stderr, "File %s Function %s Line %d ", \
        __FILE__, __FUNCTION__, __LINE__);                          \
        fprintf(stderr, ##__VA_ARGS__)
int main(int argc, char * argv[])
{
    errout("swap_object function %d\n", 123);
    errout("swap_object function\n");
    return 0;
}
\end{code-in-enumerate}

\1 使用\#\#连接不同的标识符
\begin{code-in-enumerate}{c}
#define appendidentify(first, last) first##last
int main(int argc, char * argv[])
{
    char * first = "lucifer";
    char * last = "garuda";
    char * firstlast = "let`s go";
    printf("%s\n", appendidentify(first, last));
    // 实际上相当与 printf("%s\n", firstlast);
    return 0;
}
\end{code-in-enumerate}

\1 使用宏定义修改函数入口
\begin{code-in-enumerate}{c}
#ifdef CONFIG_SDL
int qemu_main(int argc, char **argv, char **envp);

int main(int argc, char **argv)
{
    printf("hello main with 2 params\n");
    return qemu_main(argc, argv, NULL);
}
#undef main
#define main qemu_main
#endif

int main(int argc, char **argv, char **envp)
{
    printf("main with envp\n");
    return 0;
}
\end{code-in-enumerate}
由于main方法可以接收多个参数，因此上述代码是正确合法的。现在简单的分析一下。
分析的手法是直接使用gcc -E参数来观察预处理的结果。

不添加CONFIG\_SDL宏，其结果是：
\begin{code-in-enumerate}{bash}
gcc -E test.c
int main(int argc, char **argv, char **envp)
{
    printf("main with envp\n");
    return 0;
}
\end{code-in-enumerate}
添加CONFIG\_SDL宏，其结果是：
\begin{code-in-enumerate}{bash}
gcc -E -D CONFIG_SDL test.c
int qemu_main(int argc, char **argv, char **envp);
int main(int argc, char **argv)
{
    printf("hello main with 2 params\n");
    return qemu_main(argc, argv, ((void *)0));
}

int qemu_main(int argc, char **argv, char **envp)
{
    printf("main with envp\n");
    return 0;
}
\end{code-in-enumerate}
从代码中可以看到，实际上，整个处理过程中通过undefine main和define main qemu\_main
这2条语句，就直接修改了整个操作的入口。实际上，这个代码的核心，就是将函数名当作
了一个宏定义，通过简单的名称替换，达到更改程序入口的目的。以上代码的用法，在qemu的
源码vl.c代码当中。

\1 获取结构体的数据偏移量
\begin{code-in-enumerate}{c}
#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
typedef struct user user;
struct user{
    char * name;
    uint8_t age:7; // 表示只占用该数据类型的最后7 bit，也就是说限制age不能大于127
    user* prev;
    user* next;
};

int main(int argc, char * argv[])
{
    printf("%ld\n",offsetof(user, name);
    printf("%ld\n",offsetof(user, age);
    printf("%ld\n",offsetof(user, prev);
    printf("%ld\n",offsetof(user, next);
    return 0;
}
\end{code-in-enumerate}

在((TYPE *)0)->MEMBER)这个其实就是提取type类型中的member成员，那么\&((TYPE *)0)->MEMBER)
得到member成员的地址，再强制转换成size\_t类型（unsigned int）。
但是这个地址很特别，因为TYPE类型是从0x0开始定义的，那么我们现在得到的这个地址就是
member成员在TYPE数据类型中的偏移量。这个宏定义的效果和c库当中的offsetof（stddef.h）功能一样。
以上的代码当中，输出的结果是0,8,16和24（64位平台）。原因是每一个指针的大小固定为
平台的位数，64位为8字节，32位为4字节。

\1 根据偏移量获取数据地址
\begin{code-in-enumerate}{c}
#define container_of(ptr, type, member) ({                           \
        const typeof( ((type *)0)->member ) *__mptr = (ptr);         \
        (type *)( (char *)__mptr - offsetof(type,member) );})
#define list_entry(ptr, type, member)                                \
        container_of(ptr, type, member)
\end{code-in-enumerate}

const typeof(((type *)0)->member) *\_\_mptr = (ptr);首先将0转化成type类型的指针变量
（这个指针变量的地址为0x0），然后再引用member成员（对应就是((type *)0)->member )）。
注意这里的typeof（x），是返回x的数据类型，那么 typeof(((type *)0)->member)其实就是
返回member成员的数据类型。那么这条语句整体就是将\_\_mptr强制转换成member成员的数据类型，
再将ptr的赋给它(ptr本身就是指向member的指针)。offsetof得到的是member成员在TYPE数据类型
中的偏移量。 (type *)((char *)\_\_mptr – offsetof(type,member))求的就是type的地址，
即指向type的指针。不过这里要注意\_\_mptr被强制转换成了(char *)，为何要这么做？
因为如果member是非char型的变量，比如为int型，并且假设返回值为offset，那么这样直接减去偏移量，
实际上\_\_mptr会减去sizeof(int)*offset！这一点和指针加一减一的原理相同。当然，char*指针可以
替换为void*指针，可能会更加通用。有了这个指针，那么就可以随意引用其内的成员了。关于container\_of
的第二行，其效果类似如下。通过这个测试代码，可以发现pos的值和zhangjl的地址的值是
一模一样的，因此，可以通过pos指针访问student zhangjl当中的所有数据。
\begin{code-in-enumerate}{c}
int main(int argc, char * argv[])
{
        LIST_HEAD(first);
        student zhangjl = {.name="zhangjl", .age=18, .order=head};
        student *pos;
        printf("%x\n", &zhangjl);
        printf("%x\n", &zhangjl.order);
        printf("%ld\n", offsetof(student, order));
        //printf("%x\n", (void * )&zhangjl.order - offsetof(student, order));
        printf("%x\n", (char * )&zhangjl.order - offsetof(student, order));
        pos = (student*)((void *)&zhangjl.order - offsetof(student, order));
        printf("%x\n", pos);
        return 0;
}
\end{code-in-enumerate}

具体使用可以参见下方完整代码。
\begin{code-in-enumerate}{c}
typedef struct list_head list_head;
struct list_head {
        list_head *next, *prev;
};

typedef struct student student;
struct student {
        char * name;
        int age;
        list_head order;
};

#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)

#define LIST_HEAD_INIT(name) { &(name), &(name) }
#define LIST_HEAD(name)                                              \
        list_head name = LIST_HEAD_INIT(name)

#define container_of(ptr, type, member) ({                           \
        const typeof( ((type *)0)->member ) *__mptr = (ptr);         \
        (type *)( (char *)__mptr - offsetof(type,member) );})

#define list_entry(ptr, type, member)                                \
        container_of(ptr, type, member)

#define list_for_each_entry(pos, head, member)                       \
        for (pos = list_entry((head)->next, typeof(*pos), member);   \
            &pos->member != (head);                                  \
            pos = list_entry(pos->member.next, typeof(*pos), member))

static inline void __list_add(list_head *_new,
                list_head *prev, list_head *next)
{
        next->prev = _new;
        _new->next = next;
        _new->prev = prev;
        prev->next = _new;
}

static inline void list_add_tail(list_head *_new, list_head *head)
{
        __list_add(_new, head->prev, head);
}

int main(int argc, char * argv[])
{
        LIST_HEAD(head);
        student zhangjl = {.name="zhangjl", .age=18, .order=head};
        //student luoyan = {.name="luoyan", .age=18, .order=first};
        student luoyan = {.name="luoyan", .age=18, .order=LIST_HEAD_INIT(luoyan.order)};
        list_add_tail(&(luoyan.order), &(zhangjl.order));

        student *pos;

        list_for_each_entry(pos, &head, order){
        //list_for_each_entry(pos, &zhangjl.order, order){
                printf("%ld\n", pos);
                printf("%s\n", pos->name);
        }

        return 0;
}
\end{code-in-enumerate}

\end{outline}

\section{匿名结构体}
在定义结构体时，可以嵌入一个另外的结构体
\begin{code-block}{c}
typedef struct _user {
    char * name;
    uint8_t age;
    struct {
        char * child_name;
        uint8_t child_age;
    };
}user_struct;

int main(int argc, char * argv[])
{
    user user_ptra = malloc(sizeof(user_struct));
    user_ptra -> age = 20;
    user_ptra -> name = "zhangjl";
    user_ptra -> child_name = "zhangzz";
    user_ptra -> child_age = 18;
    printf("%s\t%d ==> %s\t%d\n", user_ptra -> name, user_ptra -> age,
           user_ptra -> child_name, user_ptra -> child_age);
    return 0;
}
\end{code-block}

\section{定义函数别名}
在gcc当中提供了一系列的扩展功能，包含了定义方法的别名。函数的别名可以是强引用，也可以是弱引用。
\begin{code-block}{c}
void __swap_object(void * first, void * last, size_t size)
{
    void * tmp = malloc(size);
    memcpy(tmp, first, size);
    memcpy(first, last, size);
    memcpy(last, tmp, size);
    free(tmp);
}

// 弱引用别名
void swap_weak(void * first, void *last, size_t size)
        __attribute__ ((weak, alias("__swap_object")));
// 强引用别名
void swap_strone(void * first, void *last, size_t size)
        __attribute__ ((alias("__swap_object")));
\end{code-block}

\section{标记函数被废弃}
在gcc也支持标记函数为废弃，来警示相关人员不要使用这样的函数。
\begin{code-block}{c}
void print_hello() __attribute__ ((deprecated));
void print_hello()
{
    printf("hello\n");
}
\end{code-block}

通过以上的方式进行标记时候，在调用printf\_hello这个方法的时候，编译过程中会提示
如下的信息：
\begin{code-block}{bash}
test.c:74:5: 警告：‘print_hello’ is deprecated [-Wdeprecated-declarations]
     print_hello();
     ^~~~~~~~~~~
test.c:46:6: 附注：在此声明
 void print_hello()
\end{code-block}

\section{特殊的gcc扩展}
有的时候，我们可能需要在执行main方法之前执行一些动作，在执行完main方法之后，再
进行一些扫尾的动作。Gcc提供了这样的支持。
\begin{code-block}{c}
// 进入main方法之前就执行该方法
void hello() __attribute__ ((constructor));
void hello()
{
    printf("hello\n");
}

// 退出main方法之后，执行该方法
void bye() __attribute__ ((destructor));
void bye()
{
    printf("bye\n");
}

int main(int argc, char * argv[])
{
    return 0;
}
\end{code-block}

以上代码编译执行之后，其输出为：
\begin{code-block}{bash}
helllo
bye
\end{code-block}
