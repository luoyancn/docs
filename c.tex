\chapter{C}

\section{通用交换函数}
通用的交换函数（非字符串）
\begin{code-block}{c}
#include <stdlib.h>
#include <string.h>
void swap_object(void * first, void * last, size_t size)
{
    void * tmp = malloc(size);
    memcpy(tmp, first, size);
    memcpy(first, last, size);
    memcpy(last, tmp, size);
    free(tmp);
}
\end{code-block}

\section{柔性数组}
C语言的数据和python的不一样，是一个定长的，也就是说，需要预先设定好长度。如果需要
使用变长数组，则需要使用指针。通过指针的方式，一个一个的分配。但是，这种方式，不利于
计算数组长度，当需要使用数据长度时，就会出现问题。柔性数组则不一样，可以当成变长
数据使用，同时，还可以确定长度。

柔性数据的定义如下
\begin{code-block}{c}
typedef struct _soft_array * array_ptr;
typedef struct _soft_array{
    size_t lenth;
    int members[1];
}soft_array;
\end{code-block}

柔性数组一般由2部分组成，第一个表示数组长度，第二个表示数据的元素。但是，由于
各个c/c++编译器的不一致，第二个参数，一定要是一个数组，并且，最好这个数组的长度
为1。在gcc当中，这个members的长度可以为0，但在clang/virsual c++当中，则可能报错。
统一设置为1，则不会出现这个问题。

柔性数组的使用
\begin{code-block}{c}
array_ptr init_soft_array(size_t lenth){
    array_ptr arrays = NULL;
    if(NULL == (arrays = malloc(
        offsetof(soft_array, members) + sizeof(int) * lenth))){
        printf("Cannot allocate more memory\n");
        return NULL;
    }
    arrays->lenth = lenth;
    for(size_t index = 0; index < lenth; index++){
        arrays->members[index] = index;
    }
    return arrays;
}
\end{code-block}

\section{指向指针的指针}
指向指针的指针，通常用在需要改变指针的地方。常见的操作，就是使用指向指针的指针
来删除单链表。
\begin{code-block}{c}
void delete_link(nodeptr * header, nodeptr delete_node) {
    nodeptr * current = header;
    nodeptr entry = NULL;
    while(*current) {
        entry = *current;
        if(entry == delete_node) {
            *current = entry -> next;
            free(delete_node);
            delete_node= NULL;
            return;
        } else {
            current = &(entry->next);
        }
    }
}
\end{code-block}

\section{二叉树的简单实现}
通常的，二叉树都是有序的二叉树，因此，插入时，一般都应当对其进行排序操作。
\begin{code-block}{c}
typedef struct _tnode * tree;
typedef void (*visit_func)(tree * root);

typedef struct _tnode{
    tree leftchild;
    tree rightchild;
    int value;
}tnode;

void insert_tree(tree *root, int value){
    if(NULL == *root){
        *root = MALLOC(1, tnode);
        if(NULL == *root){
            printf("Cannot allocate more memory for tree\n");
            return;
        }
        (*root)->value = value;
        (*root)->leftchild = NULL;
        (*root)->rightchild = NULL;
        return;
    }
    if((*root)->value > value){
        insert_tree(&((*root)->leftchild), value);
    }else{
        insert_tree(&((*root)->rightchild), value);
    }
}
\end{code-block}

对于二叉树而言，最重要的操作莫过于遍历。所有的二叉树操作都是基于遍历进行的。
二叉树的遍历操作通常有3种：前序，中序和后序。其中，最重要的，就是后序遍历。

\begin{code-block}{c}
// 前序遍历
void visit_tree_root_first(tree root, visit_func visit){
    if(NULL == root){
        return;
    }
    visit(&root);
    visit_tree_root_first(root->leftchild, visit);
    visit_tree_root_first(root->rightchild, visit);
}

// 中序遍历
void visit_tree_root_second(tree root, visit_func visit){
    if(NULL == root){
        return;
    }
    visit_tree_root_second(root->leftchild, visit);
    visit(&root);
    visit_tree_root_second(root->rightchild, visit);
}

// 后续遍历
void visit_tree_root_last(tree *root, visit_func visit){
    if(NULL == *root){
        return;
    }
    visit_tree_root_last(&((*root)->leftchild), visit);
    visit_tree_root_last(&((*root)->rightchild), visit);
    visit(root);
}
\end{code-block}

二叉树其他的操作，基本上也是根据遍历操作来实现的。比如，一颗二叉树的销毁。
\begin{code-block}{c}
static void _destroy_tree(tree * root){
    (*root)->leftchild = NULL;
    (*root)->rightchild = NULL;
    free(*root);
    *root = NULL;
}

void destroy_tree(tree *root){
    visit_func visit = _destroy_tree;
    visit_tree_root_last(root, visit);
}
\end{code-block}

\section{宏定义的高级使用}
\begin{outline}[enumerate]

\1 使用typeof创建范型宏
\begin{code-in-enumerate}{c}
#define MIN(x, y) ({\
    typeof(x) _min1 = (x);          \
    typeof(y) _min2 = (y);          \
    (void) (&_min1 == &_min2);      \
    _min1 < _min2 ? _min1 : _min2; })
\end{code-in-enumerate}

\1 定义通用的错误处理
\begin{code-in-enumerate}{c}
#define errout(...) fprintf(stderr, "File %s Line %d ", __FILE__, __LINE__);\
        fprintf(stderr, ##__VA_ARGS__)
int main(int argc, char * argv[])
{
    errout("swap_object function %d\n", 123);
    errout("swap_object function\n");
    return 0;
}
\end{code-in-enumerate}

\end{outline}
